diff --git a/bin/shortlog_mesa.sh b/bin/shortlog_mesa.sh
new file mode 100755
index 0000000..b20c52f
--- /dev/null
+++ b/bin/shortlog_mesa.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+# This script is used to generate the list of changes that
+# appears in the release notes files, with HTML formatting.
+
+
+typeset -i in_log=0
+
+git shortlog $* | while read l
+do
+    if [ $in_log -eq 0 ]; then
+	echo '<p>'$l'</p>'
+	echo '<ul>'
+	in_log=1
+    elif echo "$l" | egrep -q '^$' ; then
+	echo '</ul>'
+	echo
+	in_log=0
+    else
+        mesg=$(echo $l | sed 's/ (cherry picked from commit [0-9a-f]\+)//;s/\&/&amp;/g;s/</\&lt;/g;s/>/\&gt;/g')
+	echo '  <li>'${mesg}'</li>'
+    fi
+done
diff --git a/docs/relnotes-8.0.4.html b/docs/relnotes-8.0.4.html
index d5792aa..529140a 100644
--- a/docs/relnotes-8.0.4.html
+++ b/docs/relnotes-8.0.4.html
@@ -1,16 +1,13 @@
-<HTML>
-
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
 <head>
-<TITLE>Mesa Release Notes</TITLE>
-<link rel="stylesheet" type="text/css" href="mesa.css">
-<meta http-equiv="content-type" content="text/html; charset=utf-8" />
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="mesa.css">
 </head>
+<body>
 
-<BODY>
-
-<body bgcolor="#eeeeee">
-
-<H1>Mesa 8.0.4 Release Notes / July 10, 2012</H1>
+<h1>Mesa 8.0.4 Release Notes / July 10, 2012</h1>
 
 <p>
 Mesa 8.0.4 is a bug fix release which fixes bugs found since the 8.0.2 release.
@@ -28,7 +25,9 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-TBD
+02b96082d2f1ad72e7385f4022afafb9  MesaLib-8.0.4.tar.gz
+d546f988adfdf986cff45b1efa2d8a46  MesaLib-8.0.4.tar.bz2
+1f0fdabe6e8019d4de6c16e20e74d163  MesaLib-8.0.4.zip
 </pre>
 
 <h2>New features</h2>
@@ -68,18 +67,18 @@ TBD
   git log mesa-8.0.3..mesa-8.0.4
 </pre>
 
-<p>Andreas Betz (1):
+<p>Andreas Betz (1):</p>
 <ul>
   <li>vega: fix 565 color unpacking bug</li>
-</ul></p>
+</ul>
 
-<p>Antoine Labour (2):
+<p>Antoine Labour (2):</p>
 <ul>
   <li>meta: Cleanup the resources we allocate.</li>
   <li>mesa: Free uniforms correclty.</li>
-</ul></p>
+</ul>
 
-<p>Brian Paul (22):
+<p>Brian Paul (22):</p>
 <ul>
   <li>docs: add link to 8.0.3 release notes</li>
   <li>mesa: fix Z32_FLOAT -&gt; uint conversion functions</li>
@@ -103,39 +102,39 @@ TBD
   <li>st/mesa: fix mipmap image size computation w.r.t. texture arrays</li>
   <li>draw: fix missing immediates bug in polygon stipple code</li>
   <li>st/mesa: fix max_offset computation for base vertex</li>
-</ul></p>
+</ul>
 
-<p>Christoph Bumiller (1):
+<p>Christoph Bumiller (1):</p>
 <ul>
   <li>nv50: handle NEG,ABS modifiers for short RCP encoding</li>
-</ul></p>
+</ul>
 
-<p>Dylan Noblesmith (1):
+<p>Dylan Noblesmith (1):</p>
 <ul>
   <li>mesa: require GL_MAX_SAMPLES &gt;= 4 for GL 3.0</li>
-</ul></p>
+</ul>
 
-<p>Eric Anholt (1):
+<p>Eric Anholt (1):</p>
 <ul>
   <li>i965/vs: Fix texelFetchOffset()</li>
-</ul></p>
+</ul>
 
-<p>Ian Romanick (5):
+<p>Ian Romanick (5):</p>
 <ul>
   <li>docs: Add 8.0.3 release md5sums</li>
   <li>glx/tests: Fix off-by-one error in allocating extension string buffer</li>
   <li>glsl: Remove spurious printf messages</li>
   <li>glsl: Fix pi/2 constant in acos built-in function</li>
   <li>mesa: Bump version number to 8.0.4</li>
-</ul></p>
+</ul>
 
-<p>José Fonseca (2):
+<p>José Fonseca (2):</p>
 <ul>
   <li>mesa: Avoid void acinclude.m4 Android.common.mk Android.mk autogen.sh bin common.py configs configure.ac docs doxygen include Makefile scons SConstruct src tests arithmetic.</li>
   <li>draw: Ensure that prepare is always run after LLVM garbagge collection.</li>
-</ul></p>
+</ul>
 
-<p>Kenneth Graunke (15):
+<p>Kenneth Graunke (15):</p>
 <ul>
   <li>mesa: Check for a negative "size" parameter in glCopyBufferSubData().</li>
   <li>i965: Fix brw_swap_cmod() for LE/GE comparisons.</li>
@@ -152,51 +151,51 @@ TBD
   <li>i965/fs: Fix user-defined FS outputs with less than four components.</li>
   <li>glsl: Hook up loop_variable_state destructor to plug a memory leak.</li>
   <li>glsl: Don't trust loop analysis in the presence of function calls.</li>
-</ul></p>
+</ul>
 
-<p>Kurt Roeckx (1):
+<p>Kurt Roeckx (1):</p>
 <ul>
   <li>i830: Fix crash for GL_STENCIL_TEST in i830Enable()</li>
-</ul></p>
+</ul>
 
-<p>Lukas Rössler (1):
+<p>Lukas Rössler (1):</p>
 <ul>
   <li>glu: fix two Clang warnings</li>
-</ul></p>
+</ul>
 
-<p>Marek Olšák (2):
+<p>Marek Olšák (2):</p>
 <ul>
   <li>mesa: allow exposing GL3 without EXT_texture_integer</li>
   <li>st/mesa: don't do srgb-&gt;linear conversion in decompress_with_blit</li>
-</ul></p>
+</ul>
 
-<p>Paul Seidler (1):
+<p>Paul Seidler (1):</p>
 <ul>
   <li>tests: include mesa headers</li>
-</ul></p>
+</ul>
 
-<p>Stéphane Marchesin (3):
+<p>Stéphane Marchesin (3):</p>
 <ul>
   <li>glx: Handle a null reply in QueryVersion.</li>
   <li>i915g: Don't invert signalled/unsignalled fences</li>
   <li>i915g: Don't avoid flushing when we have a pending fence.</li>
-</ul></p>
+</ul>
 
-<p>Thomas Gstädtner (1):
+<p>Thomas Gstädtner (1):</p>
 <ul>
   <li>gallium/targets: pass ldflags parameter to MKLIB</li>
-</ul></p>
+</ul>
 
-<p>Vadim Girlin (2):
+<p>Vadim Girlin (2):</p>
 <ul>
   <li>st/mesa: set stObj-&gt;lastLevel in guess_and_alloc_texture</li>
   <li>r600g: check gpr count limit</li>
-</ul></p>
+</ul>
 
-<p>Vinson Lee (1):
+<p>Vinson Lee (1):</p>
 <ul>
   <li>st/mesa: Fix uninitialized members in glsl_to_tgsi_visitor constructor.</li>
-</ul></p>
+</ul>
 
 </body>
 </html>
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index 1998941..1d99539 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -498,6 +498,14 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
       for (j = 0; dri2_dpy->driver_configs[j]; j++) {
          const EGLint surface_type = EGL_WINDOW_BIT | EGL_PBUFFER_BIT;
          struct dri2_egl_config *dri2_conf;
+         unsigned int double_buffered = 0;
+
+         dri2_dpy->core->getConfigAttrib(dri2_dpy->driver_configs[j],
+            __DRI_ATTRIB_DOUBLE_BUFFER, &double_buffered);
+
+         /* support only double buffered configs */
+         if (!double_buffered)
+            continue;
 
          dri2_conf = dri2_add_config(dpy, dri2_dpy->driver_configs[j],
                count + 1, visuals[i].size, surface_type, NULL,
@@ -523,17 +531,6 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
       /* there is no front buffer so no OpenGL */
       dri2_conf->base.RenderableType &= ~EGL_OPENGL_BIT;
       dri2_conf->base.Conformant &= ~EGL_OPENGL_BIT;
-
-      /*
-       * We want to make sure GL_DRAW_BUFFER for windows or pbuffers is always
-       * GL_BACK.  For EGL configs that do not have a double DRI config, clear
-       * the surface type.
-       *
-       * This is just to be on the safe side.  dri2_add_config never sets
-       * EGL_WINDOW_BIT or EGL_PBUFFER_BIT for such configs.
-       */
-      if (!dri2_conf->dri_double_config)
-         dri2_conf->base.SurfaceType = 0;
    }
 
    return (count != 0);
diff --git a/src/gallium/state_trackers/egl/x11/native_ximage.c b/src/gallium/state_trackers/egl/x11/native_ximage.c
index c0108fc..ae9c3b2 100644
--- a/src/gallium/state_trackers/egl/x11/native_ximage.c
+++ b/src/gallium/state_trackers/egl/x11/native_ximage.c
@@ -455,7 +455,7 @@ ximage_display_copy_to_pixmap(struct native_display *ndpy,
    if (src->bind & PIPE_BIND_DISPLAY_TARGET) {
       struct ximage_display *xdpy = ximage_display(ndpy);
       enum pipe_format fmt = get_pixmap_format(&xdpy->base, pix);
-      const struct ximage_config *xconf;
+      const struct ximage_config *xconf = NULL;
       struct xlib_drawable xdraw;
       int i;
 
diff --git a/src/mesa/drivers/dri/common/xmlconfig.c b/src/mesa/drivers/dri/common/xmlconfig.c
index 6d1d5ec..039e98a 100644
--- a/src/mesa/drivers/dri/common/xmlconfig.c
+++ b/src/mesa/drivers/dri/common/xmlconfig.c
@@ -86,7 +86,7 @@ static const char *__getProgramName () {
 #endif
 
 #if !defined(GET_PROGRAM_NAME)
-#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__)
+#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__) || defined(ANDROID)
 /* This is a hack. It's said to work on OpenBSD, NetBSD and GNU.
  * Rogelio M.Serrano Jr. reported it's also working with UCLIBC. It's
  * used as a last resort, if there is no documented facility available. */
diff --git a/src/mesa/drivers/dri/i915/i830_state.c b/src/mesa/drivers/dri/i915/i830_state.c
index 669fea8..647ba62 100644
--- a/src/mesa/drivers/dri/i915/i830_state.c
+++ b/src/mesa/drivers/dri/i915/i830_state.c
@@ -30,6 +30,7 @@
 #include "main/context.h"
 #include "main/macros.h"
 #include "main/enums.h"
+#include "main/fbobject.h"
 #include "main/dd.h"
 #include "main/state.h"
 
@@ -545,7 +546,7 @@ i830Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
 
    DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);
 
-   if (ctx->DrawBuffer->Name == 0) {
+   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       x1 = x;
       y1 = ctx->DrawBuffer->Height - (y + h);
       x2 = x + w - 1;
diff --git a/src/mesa/drivers/dri/i915/i915_state.c b/src/mesa/drivers/dri/i915/i915_state.c
index 94c7327..3ab75a9 100644
--- a/src/mesa/drivers/dri/i915/i915_state.c
+++ b/src/mesa/drivers/dri/i915/i915_state.c
@@ -30,6 +30,7 @@
 #include "main/context.h"
 #include "main/macros.h"
 #include "main/enums.h"
+#include "main/fbobject.h"
 #include "main/dd.h"
 #include "main/state.h"
 #include "tnl/tnl.h"
@@ -400,7 +401,7 @@ intelCalcViewport(struct gl_context * ctx)
 {
    struct intel_context *intel = intel_context(ctx);
 
-   if (ctx->DrawBuffer->Name == 0) {
+   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       _math_matrix_viewport(&intel->ViewportMatrix,
 			    ctx->Viewport.X,
 			    ctx->DrawBuffer->Height - ctx->Viewport.Y,
@@ -518,7 +519,7 @@ i915Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
 
    DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);
 
-   if (ctx->DrawBuffer->Name == 0) {
+   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       x1 = x;
       y1 = ctx->DrawBuffer->Height - (y + h);
       x2 = x + w - 1;
@@ -577,7 +578,7 @@ i915CullFaceFrontFace(struct gl_context * ctx, GLenum unused)
    else if (ctx->Polygon.CullFaceMode != GL_FRONT_AND_BACK) {
       mode = S4_CULLMODE_CW;
 
-      if (ctx->DrawBuffer && ctx->DrawBuffer->Name != 0)
+      if (ctx->DrawBuffer && _mesa_is_user_fbo(ctx->DrawBuffer))
          mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
       if (ctx->Polygon.CullFaceMode == GL_FRONT)
          mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index a66ccc7..78bc6f9 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -240,7 +240,7 @@ brwCreateContext(int api,
    /* WM maximum threads is number of EUs times number of threads per EU. */
    if (intel->gen >= 7) {
       if (intel->gt == 1) {
-	 brw->max_wm_threads = 86;
+	 brw->max_wm_threads = 48;
 	 brw->max_vs_threads = 36;
 	 brw->max_gs_threads = 36;
 	 brw->urb.size = 128;
diff --git a/src/mesa/drivers/dri/i965/brw_fs.cpp b/src/mesa/drivers/dri/i965/brw_fs.cpp
index 20b57bd..f213ca2 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs.cpp
@@ -35,6 +35,7 @@ extern "C" {
 #include "main/macros.h"
 #include "main/shaderobj.h"
 #include "main/uniforms.h"
+#include "main/fbobject.h"
 #include "program/prog_parameter.h"
 #include "program/prog_print.h"
 #include "program/register_allocate.h"
@@ -1595,6 +1596,9 @@ fs_visitor::compute_to_mrf()
       }
    }
 
+   if (progress)
+      live_intervals_valid = false;
+
    return progress;
 }
 
@@ -1671,6 +1675,9 @@ fs_visitor::remove_duplicate_mrf_writes()
       }
    }
 
+   if (progress)
+      live_intervals_valid = false;
+
    return progress;
 }
 
@@ -1883,6 +1890,7 @@ brw_fs_precompile(struct gl_context *ctx, struct gl_shader_program *prog)
    struct gl_fragment_program *fp = (struct gl_fragment_program *)
       prog->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program;
    struct brw_fragment_program *bfp = brw_fragment_program(fp);
+   bool program_uses_dfdy = fp->UsesDFdy;
 
    memset(&key, 0, sizeof(key));
 
@@ -1921,7 +1929,10 @@ brw_fs_precompile(struct gl_context *ctx, struct gl_shader_program *prog)
 
    if (fp->Base.InputsRead & FRAG_BIT_WPOS) {
       key.drawable_height = ctx->DrawBuffer->Height;
-      key.render_to_fbo = ctx->DrawBuffer->Name != 0;
+   }
+
+   if ((fp->Base.InputsRead & FRAG_BIT_WPOS) || program_uses_dfdy) {
+      key.render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    }
 
    key.nr_color_regions = 1;
diff --git a/src/mesa/drivers/dri/i965/brw_fs.h b/src/mesa/drivers/dri/i965/brw_fs.h
index d43a782..f557138 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.h
+++ b/src/mesa/drivers/dri/i965/brw_fs.h
@@ -410,6 +410,7 @@ public:
 
       this->frag_depth = NULL;
       memset(this->outputs, 0, sizeof(this->outputs));
+      memset(this->output_components, 0, sizeof(this->output_components));
       this->first_non_payload_grf = 0;
       this->max_grf = intel->gen >= 7 ? GEN7_MRF_HACK_START : BRW_MAX_GRF;
 
@@ -542,7 +543,8 @@ public:
 			   struct brw_reg src);
    void generate_discard(fs_inst *inst);
    void generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
-   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src);
+   void generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
+                     bool negate_value);
    void generate_spill(fs_inst *inst, struct brw_reg src);
    void generate_unspill(fs_inst *inst, struct brw_reg dst);
    void generate_pull_constant_load(fs_inst *inst, struct brw_reg dst);
diff --git a/src/mesa/drivers/dri/i965/brw_fs_emit.cpp b/src/mesa/drivers/dri/i965/brw_fs_emit.cpp
index cc70904..e7871a0 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_emit.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_emit.cpp
@@ -475,8 +475,13 @@ fs_visitor::generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src)
    brw_ADD(p, dst, src0, negate(src1));
 }
 
+/* The negate_value boolean is used to negate the derivative computation for
+ * FBOs, since they place the origin at the upper left instead of the lower
+ * left.
+ */
 void
-fs_visitor::generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src)
+fs_visitor::generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
+                         bool negate_value)
 {
    struct brw_reg src0 = brw_reg(src.file, src.nr, 0,
 				 BRW_REGISTER_TYPE_F,
@@ -490,7 +495,10 @@ fs_visitor::generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src)
 				 BRW_WIDTH_4,
 				 BRW_HORIZONTAL_STRIDE_0,
 				 BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
-   brw_ADD(p, dst, src0, negate(src1));
+   if (negate_value)
+      brw_ADD(p, dst, src1, negate(src0));
+   else
+      brw_ADD(p, dst, src0, negate(src1));
 }
 
 void
@@ -913,7 +921,11 @@ fs_visitor::generate_code()
 	 generate_ddx(inst, dst, src[0]);
 	 break;
       case FS_OPCODE_DDY:
-	 generate_ddy(inst, dst, src[0]);
+         /* Make sure fp->UsesDFdy flag got set (otherwise there's no
+          * guarantee that c->key.render_to_fbo is set).
+          */
+         assert(fp->UsesDFdy);
+	 generate_ddy(inst, dst, src[0], c->key.render_to_fbo);
 	 break;
 
       case FS_OPCODE_SPILL:
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 07462d3..d2c9246 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -40,6 +40,8 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 
+#include "main/fbobject.h"
+
 /* Constant single cliprect for framebuffer object or DRI2 drawing */
 static void upload_drawing_rect(struct brw_context *brw)
 {
@@ -376,6 +378,24 @@ static void emit_depthbuffer(struct brw_context *brw)
       assert(intel->gen < 6 || region->tiling == I915_TILING_Y);
       assert(!hiz_region || region->tiling == I915_TILING_Y);
 
+      /* According to the Sandy Bridge PRM, volume 2 part 1, pp326-327
+       * (3DSTATE_DEPTH_BUFFER dw5), in the documentation for "Depth
+       * Coordinate Offset X/Y":
+       *
+       *   "The 3 LSBs of both offsets must be zero to ensure correct
+       *   alignment"
+       *
+       * We have no guarantee that tile_x and tile_y are correctly aligned,
+       * since they are determined by the mipmap layout, which is only aligned
+       * to multiples of 4.
+       *
+       * So, to avoid hanging the GPU, just smash the low order 3 bits of
+       * tile_x and tile_y to 0.  This is a temporary workaround until we come
+       * up with a better solution.
+       */
+      tile_x &= ~7;
+      tile_y &= ~7;
+
       BEGIN_BATCH(len);
       OUT_BATCH(_3DSTATE_DEPTH_BUFFER << 16 | (len - 2));
       OUT_BATCH(((region->pitch * region->cpp) - 1) |
@@ -506,7 +526,7 @@ static void upload_polygon_stipple(struct brw_context *brw)
     * to a FBO (i.e. any named frame buffer object), we *don't*
     * need to invert - we already match the layout.
     */
-   if (ctx->DrawBuffer->Name == 0) {
+   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       for (i = 0; i < 32; i++)
 	  OUT_BATCH(ctx->PolygonStipple[31 - i]); /* invert */
    }
@@ -549,15 +569,13 @@ static void upload_polygon_stipple_offset(struct brw_context *brw)
 
    /* _NEW_BUFFERS
     *
-    * If we're drawing to a system window (ctx->DrawBuffer->Name == 0),
-    * we have to invert the Y axis in order to match the OpenGL
-    * pixel coordinate system, and our offset must be matched
-    * to the window position.  If we're drawing to a FBO
-    * (ctx->DrawBuffer->Name != 0), then our native pixel coordinate
-    * system works just fine, and there's no window system to
-    * worry about.
+    * If we're drawing to a system window we have to invert the Y axis
+    * in order to match the OpenGL pixel coordinate system, and our
+    * offset must be matched to the window position.  If we're drawing
+    * to a user-created FBO then our native pixel coordinate system
+    * works just fine, and there's no window system to worry about.
     */
-   if (brw->intel.ctx.DrawBuffer->Name == 0)
+   if (_mesa_is_winsys_fbo(brw->intel.ctx.DrawBuffer))
       OUT_BATCH((32 - (ctx->DrawBuffer->Height & 31)) & 31);
    else
       OUT_BATCH(0);
diff --git a/src/mesa/drivers/dri/i965/brw_sf.c b/src/mesa/drivers/dri/i965/brw_sf.c
index ccef3e83..4c605dd 100644
--- a/src/mesa/drivers/dri/i965/brw_sf.c
+++ b/src/mesa/drivers/dri/i965/brw_sf.c
@@ -32,7 +32,9 @@
 
 #include "main/glheader.h"
 #include "main/macros.h"
+#include "main/mtypes.h"
 #include "main/enums.h"
+#include "main/fbobject.h"
 
 #include "intel_batchbuffer.h"
 
@@ -136,7 +138,7 @@ brw_upload_sf_prog(struct brw_context *brw)
    struct gl_context *ctx = &brw->intel.ctx;
    struct brw_sf_prog_key key;
    /* _NEW_BUFFERS */
-   bool render_to_fbo = ctx->DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
 
    memset(&key, 0, sizeof(key));
 
diff --git a/src/mesa/drivers/dri/i965/brw_sf_state.c b/src/mesa/drivers/dri/i965/brw_sf_state.c
index d7e7aa1..7c29ba2 100644
--- a/src/mesa/drivers/dri/i965/brw_sf_state.c
+++ b/src/mesa/drivers/dri/i965/brw_sf_state.c
@@ -31,10 +31,12 @@
    
 
 
+#include "main/mtypes.h"
+#include "main/macros.h"
+#include "main/fbobject.h"
 #include "brw_context.h"
 #include "brw_state.h"
 #include "brw_defines.h"
-#include "main/macros.h"
 #include "brw_sf.h"
 
 static void upload_sf_vp(struct brw_context *brw)
@@ -44,7 +46,7 @@ static void upload_sf_vp(struct brw_context *brw)
    const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
    struct brw_sf_viewport *sfv;
    GLfloat y_scale, y_bias;
-   const bool render_to_fbo = (ctx->DrawBuffer->Name != 0);
+   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    const GLfloat *v = ctx->Viewport._WindowMap.m;
 
    sfv = brw_state_batch(brw, AUB_TRACE_SF_VP_STATE,
@@ -142,7 +144,7 @@ static void upload_sf_unit( struct brw_context *brw )
    struct brw_sf_unit_state *sf;
    drm_intel_bo *bo = intel->batch.bo;
    int chipset_max_threads;
-   bool render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(brw->intel.ctx.DrawBuffer);
 
    sf = brw_state_batch(brw, AUB_TRACE_SF_STATE,
 			sizeof(*sf), 64, &brw->sf.state_offset);
diff --git a/src/mesa/drivers/dri/i965/brw_vs_constval.c b/src/mesa/drivers/dri/i965/brw_vs_constval.c
index 5b26c7a..3d53843 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_constval.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_constval.c
@@ -143,14 +143,12 @@ static void calc_sizes( struct tracker *t )
    /* Examine vertex program output sizes to set the size_masks[] info
     * which describes the fragment program input sizes.
     */
-   for (vertRes = VERT_RESULT_TEX0; vertRes < VERT_RESULT_MAX; vertRes++) {
+   for (vertRes = 0; vertRes < VERT_RESULT_MAX; vertRes++) {
 
       /* map vertex program output index to fragment program input index */
       GLint fragAttrib = _mesa_vert_result_to_frag_attrib(vertRes);
       if (fragAttrib < 0)
          continue;
-      assert(fragAttrib >= FRAG_ATTRIB_TEX0);
-      assert(fragAttrib <= FRAG_ATTRIB_MAX);
 
       switch (get_output_size(t, vertRes)) {
       case 4: t->size_masks[4-1] |= 1 << fragAttrib;
diff --git a/src/mesa/drivers/dri/i965/brw_wm.c b/src/mesa/drivers/dri/i965/brw_wm.c
index 7dee20b..86bc182 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.c
+++ b/src/mesa/drivers/dri/i965/brw_wm.c
@@ -33,6 +33,7 @@
 #include "brw_wm.h"
 #include "brw_state.h"
 #include "main/formats.h"
+#include "main/fbobject.h"
 #include "main/samplerobj.h"
 #include "program/prog_parameter.h"
 
@@ -416,6 +417,7 @@ static void brw_wm_populate_key( struct brw_context *brw,
    GLuint lookup = 0;
    GLuint line_aa;
    GLuint i;
+   bool program_uses_dfdy = fp->program.UsesDFdy;
 
    memset(key, 0, sizeof(*key));
 
@@ -515,7 +517,10 @@ static void brw_wm_populate_key( struct brw_context *brw,
     */
    if (fp->program.Base.InputsRead & FRAG_BIT_WPOS) {
       key->drawable_height = ctx->DrawBuffer->Height;
-      key->render_to_fbo = ctx->DrawBuffer->Name != 0;
+   }
+
+   if ((fp->program.Base.InputsRead & FRAG_BIT_WPOS) || program_uses_dfdy) {
+      key->render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    }
 
    /* _NEW_BUFFERS */
diff --git a/src/mesa/drivers/dri/i965/brw_wm.h b/src/mesa/drivers/dri/i965/brw_wm.h
index 8f1cb8c..2cde2a0 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.h
+++ b/src/mesa/drivers/dri/i965/brw_wm.h
@@ -346,7 +346,8 @@ void emit_ddxy(struct brw_compile *p,
 	       const struct brw_reg *dst,
 	       GLuint mask,
 	       bool is_ddx,
-	       const struct brw_reg *arg0);
+	       const struct brw_reg *arg0,
+	       bool negate_value);
 void emit_delta_xy(struct brw_compile *p,
 		   const struct brw_reg *dst,
 		   GLuint mask,
diff --git a/src/mesa/drivers/dri/i965/brw_wm_emit.c b/src/mesa/drivers/dri/i965/brw_wm_emit.c
index 270e321..f98d2f7 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_emit.c
@@ -457,12 +457,16 @@ void emit_frontfacing(struct brw_compile *p,
  * between each other.  We could probably do it like ddx and swizzle the right
  * order later, but bail for now and just produce
  * ((ss0.tl - ss0.bl)x4 (ss1.tl - ss1.bl)x4)
+ *
+ * The negate_value boolean is used to negate the d/dy computation for FBOs,
+ * since they place the origin at the upper left instead of the lower left.
  */
 void emit_ddxy(struct brw_compile *p,
 	       const struct brw_reg *dst,
 	       GLuint mask,
 	       bool is_ddx,
-	       const struct brw_reg *arg0)
+	       const struct brw_reg *arg0,
+               bool negate_value)
 {
    int i;
    struct brw_reg src0, src1;
@@ -498,7 +502,10 @@ void emit_ddxy(struct brw_compile *p,
 			   BRW_HORIZONTAL_STRIDE_0,
 			   BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
 	 }
-	 brw_ADD(p, dst[i], src0, negate(src1));
+         if (negate_value)
+            brw_ADD(p, dst[i], src1, negate(src0));
+         else
+            brw_ADD(p, dst[i], src0, negate(src1));
       }
    }
    if (mask & SATURATE)
@@ -1739,11 +1746,15 @@ void brw_wm_emit( struct brw_wm_compile *c )
 	 break;
 
       case OPCODE_DDX:
-	 emit_ddxy(p, dst, dst_flags, true, args[0]);
+	 emit_ddxy(p, dst, dst_flags, true, args[0], false);
 	 break;
 
       case OPCODE_DDY:
-	 emit_ddxy(p, dst, dst_flags, false, args[0]);
+         /* Make sure fp->program.UsesDFdy flag got set (otherwise there's no
+          * guarantee that c->key.render_to_fbo is set).
+          */
+         assert(c->fp->program.UsesDFdy);
+	 emit_ddxy(p, dst, dst_flags, false, args[0], c->key.render_to_fbo);
 	 break;
 
       case OPCODE_DP2:
diff --git a/src/mesa/drivers/dri/i965/gen6_hiz.c b/src/mesa/drivers/dri/i965/gen6_hiz.c
index a86c147..92cf1d4 100644
--- a/src/mesa/drivers/dri/i965/gen6_hiz.c
+++ b/src/mesa/drivers/dri/i965/gen6_hiz.c
@@ -489,6 +489,24 @@ gen6_hiz_exec(struct intel_context *intel,
          offset = intel_renderbuffer_tile_offsets(&rb, &tile_x, &tile_y);
       }
 
+      /* According to the Sandy Bridge PRM, volume 2 part 1, pp326-327
+       * (3DSTATE_DEPTH_BUFFER dw5), in the documentation for "Depth
+       * Coordinate Offset X/Y":
+       *
+       *   "The 3 LSBs of both offsets must be zero to ensure correct
+       *   alignment"
+       *
+       * We have no guarantee that tile_x and tile_y are correctly aligned,
+       * since they are determined by the mipmap layout, which is only aligned
+       * to multiples of 4.
+       *
+       * So, to avoid hanging the GPU, just smash the low order 3 bits of
+       * tile_x and tile_y to 0.  This is a temporary workaround until we come
+       * up with a better solution.
+       */
+      tile_x &= ~7;
+      tile_y &= ~7;
+
       uint32_t format;
       switch (mt->format) {
       case MESA_FORMAT_Z16:       format = BRW_DEPTHFORMAT_D16_UNORM; break;
diff --git a/src/mesa/drivers/dri/i965/gen6_scissor_state.c b/src/mesa/drivers/dri/i965/gen6_scissor_state.c
index feeca28..4c7f81c 100644
--- a/src/mesa/drivers/dri/i965/gen6_scissor_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_scissor_state.c
@@ -29,13 +29,14 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 #include "intel_batchbuffer.h"
+#include "main/fbobject.h"
 
 static void
 gen6_upload_scissor_state(struct brw_context *brw)
 {
    struct intel_context *intel = &brw->intel;
    struct gl_context *ctx = &intel->ctx;
-   const bool render_to_fbo = (ctx->DrawBuffer->Name != 0);
+   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    struct gen6_scissor_rect *scissor;
    uint32_t scissor_state_offset;
 
diff --git a/src/mesa/drivers/dri/i965/gen6_sf_state.c b/src/mesa/drivers/dri/i965/gen6_sf_state.c
index 07b8e6d..d099b45 100644
--- a/src/mesa/drivers/dri/i965/gen6_sf_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_sf_state.c
@@ -30,6 +30,7 @@
 #include "brw_defines.h"
 #include "brw_util.h"
 #include "main/macros.h"
+#include "main/fbobject.h"
 #include "intel_batchbuffer.h"
 
 /**
@@ -123,7 +124,7 @@ upload_sf_state(struct brw_context *brw)
    uint32_t dw1, dw2, dw3, dw4, dw16, dw17;
    int i;
    /* _NEW_BUFFER */
-   bool render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(brw->intel.ctx.DrawBuffer);
    int attr = 0, input_index = 0;
    int urb_entry_read_offset = 1;
    float point_size;
diff --git a/src/mesa/drivers/dri/i965/gen6_viewport_state.c b/src/mesa/drivers/dri/i965/gen6_viewport_state.c
index 9ff2bd9..f787ac7 100644
--- a/src/mesa/drivers/dri/i965/gen6_viewport_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_viewport_state.c
@@ -29,6 +29,7 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 #include "intel_batchbuffer.h"
+#include "main/fbobject.h"
 
 /* The clip VP defines the guardband region where expensive clipping is skipped
  * and fragments are allowed to be generated and clipped out cheaply by the SF.
@@ -70,7 +71,7 @@ gen6_upload_sf_vp(struct brw_context *brw)
    const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
    struct brw_sf_viewport *sfv;
    GLfloat y_scale, y_bias;
-   const bool render_to_fbo = (ctx->DrawBuffer->Name != 0);
+   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    const GLfloat *v = ctx->Viewport._WindowMap.m;
 
    sfv = brw_state_batch(brw, AUB_TRACE_SF_VP_STATE,
diff --git a/src/mesa/drivers/dri/i965/gen7_clip_state.c b/src/mesa/drivers/dri/i965/gen7_clip_state.c
index c32cd98..2e4daf9 100644
--- a/src/mesa/drivers/dri/i965/gen7_clip_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_clip_state.c
@@ -26,6 +26,7 @@
 #include "brw_defines.h"
 #include "brw_util.h"
 #include "intel_batchbuffer.h"
+#include "main/fbobject.h"
 
 static void
 upload_clip_state(struct brw_context *brw)
@@ -40,7 +41,7 @@ upload_clip_state(struct brw_context *brw)
    const struct gl_fragment_program *fprog = brw->fragment_program;
 
    /* _NEW_BUFFERS */
-   bool render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(brw->intel.ctx.DrawBuffer);
 
    if (brw_fprog_uses_noperspective(fprog)) {
       nonperspective_barycentric_enable_flag =
diff --git a/src/mesa/drivers/dri/i965/gen7_hiz.c b/src/mesa/drivers/dri/i965/gen7_hiz.c
index 34e51ab..962079e 100644
--- a/src/mesa/drivers/dri/i965/gen7_hiz.c
+++ b/src/mesa/drivers/dri/i965/gen7_hiz.c
@@ -349,6 +349,24 @@ gen7_hiz_exec(struct intel_context *intel,
          offset = intel_renderbuffer_tile_offsets(&rb, &tile_x, &tile_y);
       }
 
+      /* According to the Sandy Bridge PRM, volume 2 part 1, pp326-327
+       * (3DSTATE_DEPTH_BUFFER dw5), in the documentation for "Depth
+       * Coordinate Offset X/Y":
+       *
+       *   "The 3 LSBs of both offsets must be zero to ensure correct
+       *   alignment"
+       *
+       * We have no guarantee that tile_x and tile_y are correctly aligned,
+       * since they are determined by the mipmap layout, which is only aligned
+       * to multiples of 4.
+       *
+       * So, to avoid hanging the GPU, just smash the low order 3 bits of
+       * tile_x and tile_y to 0.  This is a temporary workaround until we come
+       * up with a better solution.
+       */
+      tile_x &= ~7;
+      tile_y &= ~7;
+
       intel_emit_depth_stall_flushes(intel);
 
       BEGIN_BATCH(7);
diff --git a/src/mesa/drivers/dri/i965/gen7_misc_state.c b/src/mesa/drivers/dri/i965/gen7_misc_state.c
index d0ce542..870702f 100644
--- a/src/mesa/drivers/dri/i965/gen7_misc_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_misc_state.c
@@ -93,6 +93,24 @@ static void emit_depthbuffer(struct brw_context *brw)
 
       offset = intel_renderbuffer_tile_offsets(drb, &tile_x, &tile_y);
 
+      /* According to the Sandy Bridge PRM, volume 2 part 1, pp326-327
+       * (3DSTATE_DEPTH_BUFFER dw5), in the documentation for "Depth
+       * Coordinate Offset X/Y":
+       *
+       *   "The 3 LSBs of both offsets must be zero to ensure correct
+       *   alignment"
+       *
+       * We have no guarantee that tile_x and tile_y are correctly aligned,
+       * since they are determined by the mipmap layout, which is only aligned
+       * to multiples of 4.
+       *
+       * So, to avoid hanging the GPU, just smash the low order 3 bits of
+       * tile_x and tile_y to 0.  This is a temporary workaround until we come
+       * up with a better solution.
+       */
+      tile_x &= ~7;
+      tile_y &= ~7;
+
       assert(region->tiling == I915_TILING_Y);
 
       /* _NEW_DEPTH, _NEW_STENCIL */
diff --git a/src/mesa/drivers/dri/i965/gen7_sf_state.c b/src/mesa/drivers/dri/i965/gen7_sf_state.c
index b215af2..e86829a 100644
--- a/src/mesa/drivers/dri/i965/gen7_sf_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_sf_state.c
@@ -26,6 +26,7 @@
 #include "brw_defines.h"
 #include "brw_util.h"
 #include "main/macros.h"
+#include "main/fbobject.h"
 #include "intel_batchbuffer.h"
 
 static void
@@ -49,7 +50,7 @@ upload_sbe_state(struct brw_context *brw)
    bool userclip_active = (ctx->Transform.ClipPlanesEnabled != 0);
    uint16_t attr_overrides[FRAG_ATTRIB_MAX];
    /* _NEW_BUFFERS */
-   bool render_to_fbo = ctx->DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    uint32_t point_sprite_origin;
 
    brw_compute_vue_map(&vue_map, intel, userclip_active, vs_outputs_written);
@@ -163,7 +164,7 @@ upload_sf_state(struct brw_context *brw)
    uint32_t dw1, dw2, dw3;
    float point_size;
    /* _NEW_BUFFERS */
-   bool render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
+   bool render_to_fbo = _mesa_is_user_fbo(brw->intel.ctx.DrawBuffer);
 
    dw1 = GEN6_SF_STATISTICS_ENABLE |
          GEN6_SF_VIEWPORT_TRANSFORM_ENABLE;
diff --git a/src/mesa/drivers/dri/i965/gen7_viewport_state.c b/src/mesa/drivers/dri/i965/gen7_viewport_state.c
index d0b89d5..2bcf338 100644
--- a/src/mesa/drivers/dri/i965/gen7_viewport_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_viewport_state.c
@@ -25,6 +25,7 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 #include "intel_batchbuffer.h"
+#include "main/fbobject.h"
 
 static void
 gen7_upload_sf_clip_viewport(struct brw_context *brw)
@@ -33,7 +34,7 @@ gen7_upload_sf_clip_viewport(struct brw_context *brw)
    struct gl_context *ctx = &intel->ctx;
    const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
    GLfloat y_scale, y_bias;
-   const bool render_to_fbo = (ctx->DrawBuffer->Name != 0);
+   const bool render_to_fbo = _mesa_is_user_fbo(ctx->DrawBuffer);
    const GLfloat *v = ctx->Viewport._WindowMap.m;
    struct gen7_sf_clip_viewport *vp;
 
diff --git a/src/mesa/drivers/dri/intel/intel_buffers.c b/src/mesa/drivers/dri/intel/intel_buffers.c
index 9809f79..2b02763 100644
--- a/src/mesa/drivers/dri/intel/intel_buffers.c
+++ b/src/mesa/drivers/dri/intel/intel_buffers.c
@@ -30,6 +30,7 @@
 #include "intel_fbo.h"
 #include "intel_mipmap_tree.h"
 
+#include "main/fbobject.h"
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
 
@@ -82,7 +83,7 @@ intel_check_front_buffer_rendering(struct intel_context *intel)
 static void
 intelDrawBuffer(struct gl_context * ctx, GLenum mode)
 {
-   if ((ctx->DrawBuffer != NULL) && (ctx->DrawBuffer->Name == 0)) {
+   if (ctx->DrawBuffer && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       struct intel_context *const intel = intel_context(ctx);
       const bool was_front_buffer_rendering =
 	intel->is_front_buffer_rendering;
@@ -105,7 +106,7 @@ intelDrawBuffer(struct gl_context * ctx, GLenum mode)
 static void
 intelReadBuffer(struct gl_context * ctx, GLenum mode)
 {
-   if ((ctx->DrawBuffer != NULL) && (ctx->DrawBuffer->Name == 0)) {
+   if (ctx->DrawBuffer && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       struct intel_context *const intel = intel_context(ctx);
       const bool was_front_buffer_reading =
 	intel->is_front_buffer_reading;
diff --git a/src/mesa/drivers/dri/intel/intel_context.c b/src/mesa/drivers/dri/intel/intel_context.c
index faf81ee..a9e663c 100644
--- a/src/mesa/drivers/dri/intel/intel_context.c
+++ b/src/mesa/drivers/dri/intel/intel_context.c
@@ -206,7 +206,7 @@ intel_flush_front(struct gl_context *ctx)
     __DRIcontext *driContext = intel->driContext;
     __DRIscreen *const screen = intel->intelScreen->driScrnPriv;
 
-   if ((ctx->DrawBuffer->Name == 0) && intel->front_buffer_dirty) {
+    if (_mesa_is_winsys_fbo(ctx->DrawBuffer) && intel->front_buffer_dirty) {
       if (screen->dri2.loader &&
           (screen->dri2.loader->base.version >= 2)
 	  && (screen->dri2.loader->flushFrontBuffer != NULL) &&
@@ -445,7 +445,7 @@ intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
     if (intel->saved_viewport)
 	intel->saved_viewport(ctx, x, y, w, h);
 
-    if (ctx->DrawBuffer->Name == 0) {
+    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
        dri2InvalidateDrawable(driContext->driDrawablePriv);
        dri2InvalidateDrawable(driContext->driReadablePriv);
     }
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_read.c b/src/mesa/drivers/dri/intel/intel_pixel_read.c
index 34fed3d..ab4e581 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_read.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_read.c
@@ -29,6 +29,7 @@
 #include "main/enums.h"
 #include "main/mtypes.h"
 #include "main/macros.h"
+#include "main/fbobject.h"
 #include "main/image.h"
 #include "main/bufferobj.h"
 #include "main/readpix.h"
@@ -116,7 +117,7 @@ do_blit_readpixels(struct gl_context * ctx,
       return false;
    }
    else {
-      if (ctx->ReadBuffer->Name == 0)
+      if (_mesa_is_winsys_fbo(ctx->ReadBuffer))
 	 rowLength = -rowLength;
    }
 
@@ -145,7 +146,7 @@ do_blit_readpixels(struct gl_context * ctx,
 				       all ? INTEL_WRITE_FULL :
 				       INTEL_WRITE_PART);
 
-   if (ctx->ReadBuffer->Name == 0)
+   if (_mesa_is_winsys_fbo(ctx->ReadBuffer))
       y = ctx->ReadBuffer->Height - (y + height);
 
    if (!intelEmitCopyBlit(intel,
diff --git a/src/mesa/main/buffers.c b/src/mesa/main/buffers.c
index adea0f5..a6b5309 100644
--- a/src/mesa/main/buffers.c
+++ b/src/mesa/main/buffers.c
@@ -35,6 +35,7 @@
 #include "colormac.h"
 #include "context.h"
 #include "enums.h"
+#include "fbobject.h"
 #include "mtypes.h"
 
 
@@ -55,7 +56,7 @@ supported_buffer_bitmask(const struct gl_context *ctx, const struct gl_framebuff
 {
    GLbitfield mask = 0x0;
 
-   if (fb->Name > 0) {
+   if (_mesa_is_user_fbo(fb)) {
       /* A user-created renderbuffer */
       GLuint i;
       ASSERT(ctx->Extensions.EXT_framebuffer_object);
@@ -354,7 +355,7 @@ updated_drawbuffers(struct gl_context *ctx)
       struct gl_framebuffer *fb = ctx->DrawBuffer;
 
       /* Flag the FBO as requiring validation. */
-      if (fb->Name != 0) {
+      if (_mesa_is_user_fbo(fb)) {
 	 fb->_Status = 0;
       }
    }
@@ -448,7 +449,7 @@ _mesa_drawbuffers(struct gl_context *ctx, GLuint n, const GLenum *buffers,
       fb->ColorDrawBuffer[buf] = GL_NONE;
    }
 
-   if (fb->Name == 0) {
+   if (_mesa_is_winsys_fbo(fb)) {
       /* also set context drawbuffer state */
       for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
          if (ctx->Color.DrawBuffer[buf] != fb->ColorDrawBuffer[buf]) {
@@ -472,7 +473,7 @@ _mesa_update_draw_buffers(struct gl_context *ctx)
    GLuint i;
 
    /* should be a window system FBO */
-   assert(ctx->DrawBuffer->Name == 0);
+   assert(_mesa_is_winsys_fbo(ctx->DrawBuffer));
 
    for (i = 0; i < ctx->Const.MaxDrawBuffers; i++)
       buffers[i] = ctx->Color.DrawBuffer[i];
@@ -493,7 +494,7 @@ _mesa_readbuffer(struct gl_context *ctx, GLenum buffer, GLint bufferIndex)
 {
    struct gl_framebuffer *fb = ctx->ReadBuffer;
 
-   if (fb->Name == 0) {
+   if (_mesa_is_winsys_fbo(fb)) {
       /* Only update the per-context READ_BUFFER state if we're bound to
        * a window-system framebuffer.
        */
@@ -529,7 +530,7 @@ _mesa_ReadBuffer(GLenum buffer)
    if (MESA_VERBOSE & VERBOSE_API)
       _mesa_debug(ctx, "glReadBuffer %s\n", _mesa_lookup_enum_by_nr(buffer));
 
-   if (fb->Name > 0 && buffer == GL_NONE) {
+   if (_mesa_is_user_fbo(fb) && buffer == GL_NONE) {
       /* This is legal for user-created framebuffer objects */
       srcBuffer = -1;
    }
diff --git a/src/mesa/main/extensions.c b/src/mesa/main/extensions.c
index b7b1e44..f9d4435 100644
--- a/src/mesa/main/extensions.c
+++ b/src/mesa/main/extensions.c
@@ -916,7 +916,7 @@ _mesa_get_extension_count(struct gl_context *ctx)
 
    base = (GLboolean *) &ctx->Extensions;
    for (i = extension_table; i->name != 0; ++i) {
-      if (base[i->offset]) {
+      if (base[i->offset] && (i->api_set & (1 << ctx->API))) {
 	 ctx->Extensions.Count++;
       }
    }
@@ -939,10 +939,11 @@ _mesa_get_enabled_extension(struct gl_context *ctx, GLuint index)
    base = (GLboolean*) &ctx->Extensions;
    n = 0;
    for (i = extension_table; i->name != 0; ++i) {
-      if (n == index && base[i->offset]) {
-	 return (GLubyte*) i->name;
-      } else if (base[i->offset]) {
-	 ++n;
+      if (base[i->offset] & (i->api_set & (1 << ctx->API))) {
+         if (n == index)
+            return (const GLubyte*) i->name;
+         else
+            ++n;
       }
    }
 
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 64f592a..68da579 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -79,26 +79,6 @@ static struct gl_renderbuffer DummyRenderbuffer;
 static struct gl_framebuffer IncompleteFramebuffer;
 
 
-/**
- * Is the given FBO a user-created FBO?
- */
-static inline GLboolean
-is_user_fbo(const struct gl_framebuffer *fb)
-{
-   return fb->Name != 0;
-}
-
-
-/**
- * Is the given FBO a window system FBO (like an X window)?
- */
-static inline GLboolean
-is_winsys_fbo(const struct gl_framebuffer *fb)
-{
-   return fb->Name == 0;
-}
-
-
 static void
 delete_dummy_renderbuffer(struct gl_renderbuffer *rb)
 {
@@ -214,7 +194,7 @@ _mesa_get_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
 {
    GLuint i;
 
-   assert(is_user_fbo(fb));
+   assert(_mesa_is_user_fbo(fb));
 
    switch (attachment) {
    case GL_COLOR_ATTACHMENT0_EXT:
@@ -265,7 +245,7 @@ static struct gl_renderbuffer_attachment *
 _mesa_get_fb0_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
                          GLenum attachment)
 {
-   assert(is_winsys_fbo(fb));
+   assert(_mesa_is_winsys_fbo(fb));
 
    switch (attachment) {
    case GL_FRONT_LEFT:
@@ -711,7 +691,7 @@ _mesa_test_framebuffer_completeness(struct gl_context *ctx,
    GLint i;
    GLuint j;
 
-   assert(is_user_fbo(fb));
+   assert(_mesa_is_user_fbo(fb));
 
    numImages = 0;
    fb->Width = 0;
@@ -1009,10 +989,10 @@ _mesa_DeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
                _mesa_BindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
             }
 
-            if (is_user_fbo(ctx->DrawBuffer)) {
+            if (_mesa_is_user_fbo(ctx->DrawBuffer)) {
                detach_renderbuffer(ctx, ctx->DrawBuffer, rb);
             }
-            if (is_user_fbo(ctx->ReadBuffer)
+            if (_mesa_is_user_fbo(ctx->ReadBuffer)
                 && ctx->ReadBuffer != ctx->DrawBuffer) {
                detach_renderbuffer(ctx, ctx->ReadBuffer, rb);
             }
@@ -1322,7 +1302,7 @@ invalidate_rb(GLuint key, void *data, void *userData)
    struct gl_renderbuffer *rb = (struct gl_renderbuffer *) userData;
 
    /* If this is a user-created FBO */
-   if (is_user_fbo(fb)) {
+   if (_mesa_is_user_fbo(fb)) {
       GLuint i;
       for (i = 0; i < BUFFER_COUNT; i++) {
          struct gl_renderbuffer_attachment *att = fb->Attachment + i;
@@ -1614,7 +1594,7 @@ check_begin_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
    GLuint i;
    ASSERT(ctx->Driver.RenderTexture);
 
-   if (is_winsys_fbo(fb))
+   if (_mesa_is_winsys_fbo(fb))
       return; /* can't render to texture with winsys framebuffers */
 
    for (i = 0; i < BUFFER_COUNT; i++) {
@@ -1634,7 +1614,7 @@ check_begin_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
 static void
 check_end_texture_render(struct gl_context *ctx, struct gl_framebuffer *fb)
 {
-   if (is_winsys_fbo(fb))
+   if (_mesa_is_winsys_fbo(fb))
       return; /* can't render to texture with winsys framebuffers */
 
    if (ctx->Driver.FinishRenderTexture) {
@@ -1887,7 +1867,7 @@ _mesa_CheckFramebufferStatusEXT(GLenum target)
       return 0;
    }
 
-   if (is_winsys_fbo(buffer)) {
+   if (_mesa_is_winsys_fbo(buffer)) {
       /* The window system / default framebuffer is always complete */
       return GL_FRAMEBUFFER_COMPLETE_EXT;
    }
@@ -1950,7 +1930,7 @@ framebuffer_texture(struct gl_context *ctx, const char *caller, GLenum target,
    }
 
    /* check framebuffer binding */
-   if (is_winsys_fbo(fb)) {
+   if (_mesa_is_winsys_fbo(fb)) {
       _mesa_error(ctx, GL_INVALID_OPERATION,
                   "glFramebufferTexture%sEXT", caller);
       return;
@@ -2211,7 +2191,7 @@ _mesa_FramebufferRenderbufferEXT(GLenum target, GLenum attachment,
       return;
    }
 
-   if (is_winsys_fbo(fb)) {
+   if (_mesa_is_winsys_fbo(fb)) {
       /* Can't attach new renderbuffers to a window system framebuffer */
       _mesa_error(ctx, GL_INVALID_OPERATION, "glFramebufferRenderbufferEXT");
       return;
@@ -2292,7 +2272,7 @@ _mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
       return;
    }
 
-   if (is_winsys_fbo(buffer)) {
+   if (_mesa_is_winsys_fbo(buffer)) {
       /* Page 126 (page 136 of the PDF) of the OpenGL ES 2.0.25 spec
        * says:
        *
@@ -2339,7 +2319,8 @@ _mesa_GetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment,
 
    switch (pname) {
    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT:
-      *params = is_winsys_fbo(buffer) ? GL_FRAMEBUFFER_DEFAULT : att->Type;
+      *params = _mesa_is_winsys_fbo(buffer)
+         ? GL_FRAMEBUFFER_DEFAULT : att->Type;
       return;
    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT:
       if (att->Type == GL_RENDERBUFFER_EXT) {
diff --git a/src/mesa/main/fbobject.h b/src/mesa/main/fbobject.h
index 0a70a43..3aee842 100644
--- a/src/mesa/main/fbobject.h
+++ b/src/mesa/main/fbobject.h
@@ -32,6 +32,28 @@
 struct gl_context;
 struct gl_texture_object;
 
+
+/**
+ * Is the given FBO a user-created FBO?
+ */
+static inline GLboolean
+_mesa_is_user_fbo(const struct gl_framebuffer *fb)
+{
+   return fb->Name != 0;
+}
+
+
+/**
+ * Is the given FBO a window system FBO (like an X window)?
+ */
+static inline GLboolean
+_mesa_is_winsys_fbo(const struct gl_framebuffer *fb)
+{
+   return fb->Name == 0;
+}
+
+
+
 extern void
 _mesa_init_fbobjects(struct gl_context *ctx);
 
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index d11b167..d566249 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -1860,8 +1860,7 @@ _mesa_format_image_size(gl_format format, GLsizei width,
       const GLuint wblocks = (width + bw - 1) / bw;
       const GLuint hblocks = (height + bh - 1) / bh;
       const GLuint sz = wblocks * hblocks * info->BytesPerBlock;
-      assert(depth == 1);
-      return sz;
+      return sz * depth;
    }
    else {
       /* non-compressed */
@@ -1887,8 +1886,7 @@ _mesa_format_image_size64(gl_format format, GLsizei width,
       const uint64_t wblocks = (width + bw - 1) / bw;
       const uint64_t hblocks = (height + bh - 1) / bh;
       const uint64_t sz = wblocks * hblocks * info->BytesPerBlock;
-      assert(depth == 1);
-      return sz;
+      return sz * depth;
    }
    else {
       /* non-compressed */
diff --git a/src/mesa/main/framebuffer.c b/src/mesa/main/framebuffer.c
index 730de62..10cfaf5 100644
--- a/src/mesa/main/framebuffer.c
+++ b/src/mesa/main/framebuffer.c
@@ -281,8 +281,8 @@ _mesa_resize_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
     * and return early.
     */
 
-   /* For window system framebuffers, Name is zero */
-   assert(fb->Name == 0);
+   /* Can only resize win-sys framebuffer objects */
+   assert(_mesa_is_winsys_fbo(fb));
 
    for (i = 0; i < BUFFER_COUNT; i++) {
       struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
@@ -408,7 +408,7 @@ update_framebuffer_size(struct gl_context *ctx, struct gl_framebuffer *fb)
    GLuint i;
 
    /* user-created framebuffers only */
-   assert(fb->Name);
+   assert(_mesa_is_user_fbo(fb));
 
    for (i = 0; i < BUFFER_COUNT; i++) {
       struct gl_renderbuffer_attachment *att = &fb->Attachment[i];
@@ -687,7 +687,7 @@ update_color_read_buffer(struct gl_context *ctx, struct gl_framebuffer *fb)
 static void
 update_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
 {
-   if (fb->Name == 0) {
+   if (_mesa_is_winsys_fbo(fb)) {
       /* This is a window-system framebuffer */
       /* Need to update the FB's GL_DRAW_BUFFER state to match the
        * context state (GL_READ_BUFFER too).
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index b86aeb6..cc6e9bd 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1974,6 +1974,7 @@ struct gl_fragment_program
 {
    struct gl_program Base;   /**< base class */
    GLboolean UsesKill;          /**< shader uses KIL instruction */
+   GLboolean UsesDFdy;          /**< shader uses DDY instruction */
    GLboolean OriginUpperLeft;
    GLboolean PixelCenterInteger;
    enum gl_frag_depth_layout FragDepthLayout;
diff --git a/src/mesa/main/pack.c b/src/mesa/main/pack.c
index 4b0ee79..f3f9283 100644
--- a/src/mesa/main/pack.c
+++ b/src/mesa/main/pack.c
@@ -4900,7 +4900,7 @@ _mesa_unpack_depth_span( struct gl_context *ctx, GLuint n,
       else {
          /* need to use double precision to prevent overflow problems */
          for (i = 0; i < n; i++) {
-            GLdouble z = depthValues[i] * (GLfloat) depthMax;
+            GLdouble z = depthValues[i] * (GLdouble) depthMax;
             if (z >= (GLdouble) 0xffffffff)
                zValues[i] = 0xffffffff;
             else
diff --git a/src/mesa/main/renderbuffer.c b/src/mesa/main/renderbuffer.c
index d139386..1bb09bf 100644
--- a/src/mesa/main/renderbuffer.c
+++ b/src/mesa/main/renderbuffer.c
@@ -104,7 +104,7 @@ _mesa_add_renderbuffer(struct gl_framebuffer *fb,
           fb->Attachment[bufferName].Renderbuffer == NULL);
 
    /* winsys vs. user-created buffer cross check */
-   if (fb->Name) {
+   if (_mesa_is_user_fbo(fb)) {
       assert(rb->Name);
    }
    else {
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 077c196..4c1acac 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -1984,7 +1984,7 @@ copytexture_error_check( struct gl_context *ctx, GLuint dimensions,
    }
 
    /* Check that the source buffer is complete */
-   if (ctx->ReadBuffer->Name) {
+   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
       if (ctx->ReadBuffer->_Status == 0) {
          _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
       }
@@ -2109,7 +2109,7 @@ copytexsubimage_error_check1( struct gl_context *ctx, GLuint dimensions,
                               GLenum target, GLint level)
 {
    /* Check that the source buffer is complete */
-   if (ctx->ReadBuffer->Name) {
+   if (_mesa_is_user_fbo(ctx->ReadBuffer)) {
       if (ctx->ReadBuffer->_Status == 0) {
          _mesa_test_framebuffer_completeness(ctx, ctx->ReadBuffer);
       }
@@ -2301,7 +2301,7 @@ check_rtt_cb(GLuint key, void *data, void *userData)
    const GLuint level = info->level, face = info->face;
 
    /* If this is a user-created FBO */
-   if (fb->Name) {
+   if (_mesa_is_user_fbo(fb)) {
       GLuint i;
       /* check if any of the FBO's attachments point to 'texObj' */
       for (i = 0; i < BUFFER_COUNT; i++) {
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index dc6e309..1b61d3a 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -893,7 +893,7 @@ unbind_texobj_from_fbo(struct gl_context *ctx,
 
    for (i = 0; i < n; i++) {
       struct gl_framebuffer *fb = (i == 0) ? ctx->DrawBuffer : ctx->ReadBuffer;
-      if (fb->Name) {
+      if (_mesa_is_user_fbo(fb)) {
          GLuint j;
          for (j = 0; j < BUFFER_COUNT; j++) {
             if (fb->Attachment[j].Type == GL_TEXTURE &&
diff --git a/src/mesa/program/program.c b/src/mesa/program/program.c
index 582cbcc..3ad8377 100644
--- a/src/mesa/program/program.c
+++ b/src/mesa/program/program.c
@@ -551,6 +551,7 @@ _mesa_clone_program(struct gl_context *ctx, const struct gl_program *prog)
             = (const struct gl_fragment_program *) prog;
          struct gl_fragment_program *fpc = (struct gl_fragment_program *) clone;
          fpc->UsesKill = fp->UsesKill;
+         fpc->UsesDFdy = fp->UsesDFdy;
          fpc->OriginUpperLeft = fp->OriginUpperLeft;
          fpc->PixelCenterInteger = fp->PixelCenterInteger;
       }
@@ -772,6 +773,7 @@ _mesa_combine_programs(struct gl_context *ctx,
       newFprog = (struct gl_fragment_program *) newProg;
 
       newFprog->UsesKill = fprogA->UsesKill || fprogB->UsesKill;
+      newFprog->UsesDFdy = fprogA->UsesDFdy || fprogB->UsesDFdy;
 
       /* We'll do a search and replace for instances
        * of progB_colorFile/progB_colorIndex below...
