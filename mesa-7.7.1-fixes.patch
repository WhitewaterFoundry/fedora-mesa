diff --git a/Makefile b/Makefile
index e927cb9..b10d1fe 100644
--- a/Makefile
+++ b/Makefile
@@ -182,7 +182,7 @@ ultrix-gcc:
 
 # Rules for making release tarballs
 
-VERSION=7.7
+VERSION=7.7.1
 DIRECTORY = Mesa-$(VERSION)
 LIB_NAME = MesaLib-$(VERSION)
 DEMO_NAME = MesaDemos-$(VERSION)
diff --git a/configs/darwin b/configs/darwin
index 824f71c..336b54e 100644
--- a/configs/darwin
+++ b/configs/darwin
@@ -49,7 +49,7 @@ GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X
 APP_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXmu -lXt -lXi -lm
 
 # omit glw lib for now:
-SRC_DIRS = glx/x11 mesa glu glut/glx glew
+SRC_DIRS = glx/x11 mesa gallium glu glut/glx glew
 GLU_DIRS = sgi
 DRIVER_DIRS = osmesa
 #DRIVER_DIRS = dri
diff --git a/configs/default b/configs/default
index 9af816c..c9616bb 100644
--- a/configs/default
+++ b/configs/default
@@ -10,7 +10,7 @@ CONFIG_NAME = default
 # Version info
 MESA_MAJOR=7
 MESA_MINOR=7
-MESA_TINY=0
+MESA_TINY=1
 MESA_VERSION = $(MESA_MAJOR).$(MESA_MINOR).$(MESA_TINY)
 
 # external projects.  This should be useless now that we use libdrm.
diff --git a/docs/news.html b/docs/news.html
index 2abec2e..0a0be71 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -10,11 +10,15 @@
 
 <H1>News</H1>
 
-<h2>November XX, 2009</h2>
+<h2>December 21, 2009</h2>
 <p>
 <a href="relnotes-7.6.1.html">Mesa 7.6.1</a> is released.  This is a bug-fix
 release fixing issues found in the 7.6 release.
 </p>
+<p>
+Also, <a href="relnotes-7.7.html">Mesa 7.7</a> is released.  This is a new
+development release.
+</p>
 
 
 <h2>September 28, 2009</h2>
diff --git a/docs/relnotes-7.6.1.html b/docs/relnotes-7.6.1.html
index a41bcee..1d0ecd2 100644
--- a/docs/relnotes-7.6.1.html
+++ b/docs/relnotes-7.6.1.html
@@ -8,7 +8,7 @@
 
 <body bgcolor="#eeeeee">
 
-<H1>Mesa 7.6.1 Release Notes, (date tbd)</H1>
+<H1>Mesa 7.6.1 Release Notes, 21 December 2009</H1>
 
 <p>
 Mesa 7.6.1 is a bug-fix release fixing issues since version 7.6.
@@ -26,7 +26,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+e80fabad2e3eb7990adae773d6aeacba  MesaLib-7.6.1.tar.gz
+7db4617e9e10ad3aca1b64339fd71b7d  MesaLib-7.6.1.tar.bz2
+dd3275dbf9833480d2e92d0c69b22abd  MesaLib-7.6.1.zip
+f7fdcfe3c0f363e571c60f02f74368fb  MesaDemos-7.6.1.tar.gz
+a4226f06732a02556fcf6be290b86dff  MesaDemos-7.6.1.tar.bz2
+849425f356bd940726cebedfa79de176  MesaDemos-7.6.1.zip
+d40cc7c5e337a85b674e27a8e494f52f  MesaGLUT-7.6.1.tar.gz
+ca9aecb91f05b1da9fd7d5eeb19d47d7  MesaGLUT-7.6.1.tar.bz2
+23fad8398004c977a1d8953079b72ca6  MesaGLUT-7.6.1.zip
 </pre>
 
 
diff --git a/docs/relnotes-7.7.1.html b/docs/relnotes-7.7.1.html
new file mode 100644
index 0000000..b20c8a7
--- /dev/null
+++ b/docs/relnotes-7.7.1.html
@@ -0,0 +1,50 @@
+<HTML>
+
+<TITLE>Mesa Release Notes</TITLE>
+
+<head><link rel="stylesheet" type="text/css" href="mesa.css"></head>
+
+<BODY>
+
+<body bgcolor="#eeeeee">
+
+<H1>Mesa 7.7.1 Release Notes / date tbd</H1>
+
+<p>
+Mesa 7.7.1 is a bug-fix release.
+</p>
+<p>
+Mesa 7.7.1 implements the OpenGL 2.1 API, but the version reported by
+glGetString(GL_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 2.1.
+</p>
+<p>
+See the <a href="install.html">Compiling/Installing page</a> for prerequisites
+for DRI hardware acceleration.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+tbd
+</pre>
+
+
+<h2>New features</h2>
+<ul>
+<li>tbd
+</ul>
+
+
+<h2>Bug fixes</h2>
+<ul>
+<li>Assorted fixes to VMware SVGA gallium driver.
+<li>Fixed broken blending to multiple color buffers in swrast driver.
+<li>Allocate constants more tightly in GL_ARB_vertex/fragment parser.
+<li>Fixed mipmap generation bug caused by invalid viewport state.
+<li>Gallium SSE codegen for XPD didn't always work.
+</ul>
+
+
+</body>
+</html>
diff --git a/docs/relnotes-7.7.html b/docs/relnotes-7.7.html
index 8c8f763..c1ed654 100644
--- a/docs/relnotes-7.7.html
+++ b/docs/relnotes-7.7.html
@@ -8,7 +8,7 @@
 
 <body bgcolor="#eeeeee">
 
-<H1>Mesa 7.7 Release Notes / date TBD</H1>
+<H1>Mesa 7.7 Release Notes / 21 December 2009</H1>
 
 <p>
 Mesa 7.7 is a new development release.
@@ -28,7 +28,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+395c9516edf1ad54b0934d8db15557bf  MesaLib-7.7.tar.gz
+e3fa64a1508bc23dd9de9dd2cea7cfb1  MesaLib-7.7.tar.bz2
+e54903eb5e49c3969821fa16b32da245  MesaLib-7.7.zip
+53b5b6f78e55de170d43c98cb6aaab7e  MesaDemos-7.7.tar.gz
+6fd616b27b9826d0faa23e08e05d9435  MesaDemos-7.7.tar.bz2
+240fe06159ad73d5e22c27033b66c80a  MesaDemos-7.7.zip
+9fe11a904b2a9d8cd06cc52bc330b716  MesaGLUT-7.7.tar.gz
+e8dceed05a59a2d3c2619d7d734587e3  MesaGLUT-7.7.tar.bz2
+96af041d435349ee23ead4667ec36363  MesaGLUT-7.7.zip
 </pre>
 
 
diff --git a/docs/relnotes.html b/docs/relnotes.html
index b301ee0..b06548a 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -13,6 +13,7 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <UL>
+<LI><A HREF="relnotes-7.7.1.html">7.7.1 release notes</A>
 <LI><A HREF="relnotes-7.7.html">7.7 release notes</A>
 <LI><A HREF="relnotes-7.6.1.html">7.6.1 release notes</A>
 <LI><A HREF="relnotes-7.6.html">7.6 release notes</A>
diff --git a/include/GL/gl_mangle.h b/include/GL/gl_mangle.h
index 59f6149..b292840 100644
--- a/include/GL/gl_mangle.h
+++ b/include/GL/gl_mangle.h
@@ -30,6 +30,7 @@
 /*REGENERATE_TO_END-----------ALL LINES BELOW HERE GET REPLACED ON REGENERATION */
 
 #define glAccum		MANGLE(Accum)
+#define glActiveProgramEXT		MANGLE(ActiveProgramEXT)
 #define glActiveStencilFaceEXT		MANGLE(ActiveStencilFaceEXT)
 #define glActiveTextureARB		MANGLE(ActiveTextureARB)
 #define glActiveTexture		MANGLE(ActiveTexture)
@@ -60,6 +61,7 @@
 #define glBeginTransformFeedback		MANGLE(BeginTransformFeedback)
 #define glBeginTransformFeedbackNV		MANGLE(BeginTransformFeedbackNV)
 #define glBeginVertexShaderEXT		MANGLE(BeginVertexShaderEXT)
+#define glBeginVideoCaptureNV		MANGLE(BeginVideoCaptureNV)
 #define glBindAttribLocationARB		MANGLE(BindAttribLocationARB)
 #define glBindAttribLocation		MANGLE(BindAttribLocation)
 #define glBindBufferARB		MANGLE(BindBufferARB)
@@ -93,6 +95,8 @@
 #define glBindVertexArrayAPPLE		MANGLE(BindVertexArrayAPPLE)
 #define glBindVertexArray		MANGLE(BindVertexArray)
 #define glBindVertexShaderEXT		MANGLE(BindVertexShaderEXT)
+#define glBindVideoCaptureStreamBufferNV		MANGLE(BindVideoCaptureStreamBufferNV)
+#define glBindVideoCaptureStreamTextureNV		MANGLE(BindVideoCaptureStreamTextureNV)
 #define glBinormal3bEXT		MANGLE(Binormal3bEXT)
 #define glBinormal3bvEXT		MANGLE(Binormal3bvEXT)
 #define glBinormal3dEXT		MANGLE(Binormal3dEXT)
@@ -126,6 +130,7 @@
 #define glBlendFuncSeparate		MANGLE(BlendFuncSeparate)
 #define glBlitFramebufferEXT		MANGLE(BlitFramebufferEXT)
 #define glBlitFramebuffer		MANGLE(BlitFramebuffer)
+#define glBufferAddressRangeNV		MANGLE(BufferAddressRangeNV)
 #define glBufferDataARB		MANGLE(BufferDataARB)
 #define glBufferData		MANGLE(BufferData)
 #define glBufferParameteriAPPLE		MANGLE(BufferParameteriAPPLE)
@@ -202,6 +207,7 @@
 #define glColor4uiv		MANGLE(Color4uiv)
 #define glColor4us		MANGLE(Color4us)
 #define glColor4usv		MANGLE(Color4usv)
+#define glColorFormatNV		MANGLE(ColorFormatNV)
 #define glColorFragmentOp1ATI		MANGLE(ColorFragmentOp1ATI)
 #define glColorFragmentOp2ATI		MANGLE(ColorFragmentOp2ATI)
 #define glColorFragmentOp3ATI		MANGLE(ColorFragmentOp3ATI)
@@ -276,6 +282,7 @@
 #define glCopyConvolutionFilter1D		MANGLE(CopyConvolutionFilter1D)
 #define glCopyConvolutionFilter2DEXT		MANGLE(CopyConvolutionFilter2DEXT)
 #define glCopyConvolutionFilter2D		MANGLE(CopyConvolutionFilter2D)
+#define glCopyImageSubDataNV		MANGLE(CopyImageSubDataNV)
 #define glCopyMultiTexImage1DEXT		MANGLE(CopyMultiTexImage1DEXT)
 #define glCopyMultiTexImage2DEXT		MANGLE(CopyMultiTexImage2DEXT)
 #define glCopyMultiTexSubImage1DEXT		MANGLE(CopyMultiTexSubImage1DEXT)
@@ -302,6 +309,7 @@
 #define glCreateProgramObjectARB		MANGLE(CreateProgramObjectARB)
 #define glCreateShader		MANGLE(CreateShader)
 #define glCreateShaderObjectARB		MANGLE(CreateShaderObjectARB)
+#define glCreateShaderProgramEXT		MANGLE(CreateShaderProgramEXT)
 #define glCullFace		MANGLE(CullFace)
 #define glCullParameterdvEXT		MANGLE(CullParameterdvEXT)
 #define glCullParameterfvEXT		MANGLE(CullParameterfvEXT)
@@ -379,6 +387,7 @@
 #define glDrawRangeElementsEXT		MANGLE(DrawRangeElementsEXT)
 #define glDrawRangeElements		MANGLE(DrawRangeElements)
 #define glDrawTransformFeedbackNV		MANGLE(DrawTransformFeedbackNV)
+#define glEdgeFlagFormatNV		MANGLE(EdgeFlagFormatNV)
 #define glEdgeFlag		MANGLE(EdgeFlag)
 #define glEdgeFlagPointerEXT		MANGLE(EdgeFlagPointerEXT)
 #define glEdgeFlagPointerListIBM		MANGLE(EdgeFlagPointerListIBM)
@@ -408,6 +417,7 @@
 #define glEndTransformFeedback		MANGLE(EndTransformFeedback)
 #define glEndTransformFeedbackNV		MANGLE(EndTransformFeedbackNV)
 #define glEndVertexShaderEXT		MANGLE(EndVertexShaderEXT)
+#define glEndVideoCaptureNV		MANGLE(EndVideoCaptureNV)
 #define glEvalCoord1d		MANGLE(EvalCoord1d)
 #define glEvalCoord1dv		MANGLE(EvalCoord1dv)
 #define glEvalCoord1f		MANGLE(EvalCoord1f)
@@ -445,6 +455,7 @@
 #define glFogCoorddv		MANGLE(FogCoorddv)
 #define glFogCoordfEXT		MANGLE(FogCoordfEXT)
 #define glFogCoordf		MANGLE(FogCoordf)
+#define glFogCoordFormatNV		MANGLE(FogCoordFormatNV)
 #define glFogCoordfvEXT		MANGLE(FogCoordfvEXT)
 #define glFogCoordfv		MANGLE(FogCoordfv)
 #define glFogCoordhNV		MANGLE(FogCoordhNV)
@@ -544,6 +555,7 @@
 #define glGetBufferParameteri64v		MANGLE(GetBufferParameteri64v)
 #define glGetBufferParameterivARB		MANGLE(GetBufferParameterivARB)
 #define glGetBufferParameteriv		MANGLE(GetBufferParameteriv)
+#define glGetBufferParameterui64vNV		MANGLE(GetBufferParameterui64vNV)
 #define glGetBufferPointervARB		MANGLE(GetBufferPointervARB)
 #define glGetBufferPointerv		MANGLE(GetBufferPointerv)
 #define glGetBufferSubDataARB		MANGLE(GetBufferSubDataARB)
@@ -609,6 +621,8 @@
 #define glGetInteger64v		MANGLE(GetInteger64v)
 #define glGetIntegerIndexedvEXT		MANGLE(GetIntegerIndexedvEXT)
 #define glGetIntegeri_v		MANGLE(GetIntegeri_v)
+#define glGetIntegerui64i_vNV		MANGLE(GetIntegerui64i_vNV)
+#define glGetIntegerui64vNV		MANGLE(GetIntegerui64vNV)
 #define glGetIntegerv		MANGLE(GetIntegerv)
 #define glGetInvariantBooleanvEXT		MANGLE(GetInvariantBooleanvEXT)
 #define glGetInvariantFloatvEXT		MANGLE(GetInvariantFloatvEXT)
@@ -651,6 +665,7 @@
 #define glGetMultiTexParameterIuivEXT		MANGLE(GetMultiTexParameterIuivEXT)
 #define glGetMultiTexParameterivEXT		MANGLE(GetMultiTexParameterivEXT)
 #define glGetNamedBufferParameterivEXT		MANGLE(GetNamedBufferParameterivEXT)
+#define glGetNamedBufferParameterui64vNV		MANGLE(GetNamedBufferParameterui64vNV)
 #define glGetNamedBufferPointervEXT		MANGLE(GetNamedBufferPointervEXT)
 #define glGetNamedBufferSubDataEXT		MANGLE(GetNamedBufferSubDataEXT)
 #define glGetNamedFramebufferAttachmentParameterivEXT		MANGLE(GetNamedFramebufferAttachmentParameterivEXT)
@@ -761,6 +776,7 @@
 #define glGetUniformLocationARB		MANGLE(GetUniformLocationARB)
 #define glGetUniformLocation		MANGLE(GetUniformLocation)
 #define glGetUniformOffsetEXT		MANGLE(GetUniformOffsetEXT)
+#define glGetUniformui64vNV		MANGLE(GetUniformui64vNV)
 #define glGetUniformuivEXT		MANGLE(GetUniformuivEXT)
 #define glGetUniformuiv		MANGLE(GetUniformuiv)
 #define glGetVariantArrayObjectfvATI		MANGLE(GetVariantArrayObjectfvATI)
@@ -788,6 +804,10 @@
 #define glGetVertexAttribPointervARB		MANGLE(GetVertexAttribPointervARB)
 #define glGetVertexAttribPointerv		MANGLE(GetVertexAttribPointerv)
 #define glGetVertexAttribPointervNV		MANGLE(GetVertexAttribPointervNV)
+#define glGetVideoCaptureivNV		MANGLE(GetVideoCaptureivNV)
+#define glGetVideoCaptureStreamdvNV		MANGLE(GetVideoCaptureStreamdvNV)
+#define glGetVideoCaptureStreamfvNV		MANGLE(GetVideoCaptureStreamfvNV)
+#define glGetVideoCaptureStreamivNV		MANGLE(GetVideoCaptureStreamivNV)
 #define glGetVideoi64vNV		MANGLE(GetVideoi64vNV)
 #define glGetVideoivNV		MANGLE(GetVideoivNV)
 #define glGetVideoui64vNV		MANGLE(GetVideoui64vNV)
@@ -812,6 +832,7 @@
 #define glIndexd		MANGLE(Indexd)
 #define glIndexdv		MANGLE(Indexdv)
 #define glIndexf		MANGLE(Indexf)
+#define glIndexFormatNV		MANGLE(IndexFormatNV)
 #define glIndexFuncEXT		MANGLE(IndexFuncEXT)
 #define glIndexfv		MANGLE(Indexfv)
 #define glIndexi		MANGLE(Indexi)
@@ -832,6 +853,7 @@
 #define glIsAsyncMarkerSGIX		MANGLE(IsAsyncMarkerSGIX)
 #define glIsBufferARB		MANGLE(IsBufferARB)
 #define glIsBuffer		MANGLE(IsBuffer)
+#define glIsBufferResidentNV		MANGLE(IsBufferResidentNV)
 #define glIsEnabledi		MANGLE(IsEnabledi)
 #define glIsEnabledIndexedEXT		MANGLE(IsEnabledIndexedEXT)
 #define glIsEnabled		MANGLE(IsEnabled)
@@ -840,6 +862,7 @@
 #define glIsFramebufferEXT		MANGLE(IsFramebufferEXT)
 #define glIsFramebuffer		MANGLE(IsFramebuffer)
 #define glIsList		MANGLE(IsList)
+#define glIsNamedBufferResidentNV		MANGLE(IsNamedBufferResidentNV)
 #define glIsObjectBufferATI		MANGLE(IsObjectBufferATI)
 #define glIsOcclusionQueryNV		MANGLE(IsOcclusionQueryNV)
 #define glIsProgramARB		MANGLE(IsProgramARB)
@@ -888,6 +911,8 @@
 #define glLoadTransposeMatrixf		MANGLE(LoadTransposeMatrixf)
 #define glLockArraysEXT		MANGLE(LockArraysEXT)
 #define glLogicOp		MANGLE(LogicOp)
+#define glMakeBufferNonResidentNV		MANGLE(MakeBufferNonResidentNV)
+#define glMakeBufferResidentNV		MANGLE(MakeBufferResidentNV)
 #define glMap1d		MANGLE(Map1d)
 #define glMap1f		MANGLE(Map1f)
 #define glMap2d		MANGLE(Map2d)
@@ -1060,6 +1085,8 @@
 #define glNamedFramebufferTextureEXT		MANGLE(NamedFramebufferTextureEXT)
 #define glNamedFramebufferTextureFaceEXT		MANGLE(NamedFramebufferTextureFaceEXT)
 #define glNamedFramebufferTextureLayerEXT		MANGLE(NamedFramebufferTextureLayerEXT)
+#define glNamedMakeBufferNonResidentNV		MANGLE(NamedMakeBufferNonResidentNV)
+#define glNamedMakeBufferResidentNV		MANGLE(NamedMakeBufferResidentNV)
 #define glNamedProgramLocalParameter4dEXT		MANGLE(NamedProgramLocalParameter4dEXT)
 #define glNamedProgramLocalParameter4dvEXT		MANGLE(NamedProgramLocalParameter4dvEXT)
 #define glNamedProgramLocalParameter4fEXT		MANGLE(NamedProgramLocalParameter4fEXT)
@@ -1091,6 +1118,7 @@
 #define glNormal3iv		MANGLE(Normal3iv)
 #define glNormal3s		MANGLE(Normal3s)
 #define glNormal3sv		MANGLE(Normal3sv)
+#define glNormalFormatNV		MANGLE(NormalFormatNV)
 #define glNormalPointerEXT		MANGLE(NormalPointerEXT)
 #define glNormalPointerListIBM		MANGLE(NormalPointerListIBM)
 #define glNormalPointer		MANGLE(NormalPointer)
@@ -1234,6 +1262,8 @@
 #define glProgramUniformMatrix4fvEXT		MANGLE(ProgramUniformMatrix4fvEXT)
 #define glProgramUniformMatrix4x2fvEXT		MANGLE(ProgramUniformMatrix4x2fvEXT)
 #define glProgramUniformMatrix4x3fvEXT		MANGLE(ProgramUniformMatrix4x3fvEXT)
+#define glProgramUniformui64NV		MANGLE(ProgramUniformui64NV)
+#define glProgramUniformui64vNV		MANGLE(ProgramUniformui64vNV)
 #define glProgramVertexLimitNV		MANGLE(ProgramVertexLimitNV)
 #define glProvokingVertexEXT		MANGLE(ProvokingVertexEXT)
 #define glProvokingVertex		MANGLE(ProvokingVertex)
@@ -1362,6 +1392,7 @@
 #define glSecondaryColor3us		MANGLE(SecondaryColor3us)
 #define glSecondaryColor3usvEXT		MANGLE(SecondaryColor3usvEXT)
 #define glSecondaryColor3usv		MANGLE(SecondaryColor3usv)
+#define glSecondaryColorFormatNV		MANGLE(SecondaryColorFormatNV)
 #define glSecondaryColorPointerEXT		MANGLE(SecondaryColorPointerEXT)
 #define glSecondaryColorPointerListIBM		MANGLE(SecondaryColorPointerListIBM)
 #define glSecondaryColorPointer		MANGLE(SecondaryColorPointer)
@@ -1475,6 +1506,7 @@
 #define glTexCoord4iv		MANGLE(TexCoord4iv)
 #define glTexCoord4s		MANGLE(TexCoord4s)
 #define glTexCoord4sv		MANGLE(TexCoord4sv)
+#define glTexCoordFormatNV		MANGLE(TexCoordFormatNV)
 #define glTexCoordPointerEXT		MANGLE(TexCoordPointerEXT)
 #define glTexCoordPointerListIBM		MANGLE(TexCoordPointerListIBM)
 #define glTexCoordPointer		MANGLE(TexCoordPointer)
@@ -1513,6 +1545,7 @@
 #define glTexSubImage3DEXT		MANGLE(TexSubImage3DEXT)
 #define glTexSubImage3D		MANGLE(TexSubImage3D)
 #define glTexSubImage4DSGIS		MANGLE(TexSubImage4DSGIS)
+#define glTextureBarrierNV		MANGLE(TextureBarrierNV)
 #define glTextureBufferEXT		MANGLE(TextureBufferEXT)
 #define glTextureColorMaskSGIS		MANGLE(TextureColorMaskSGIS)
 #define glTextureImage1DEXT		MANGLE(TextureImage1DEXT)
@@ -1601,6 +1634,8 @@
 #define glUniformMatrix4fv		MANGLE(UniformMatrix4fv)
 #define glUniformMatrix4x2fv		MANGLE(UniformMatrix4x2fv)
 #define glUniformMatrix4x3fv		MANGLE(UniformMatrix4x3fv)
+#define glUniformui64NV		MANGLE(Uniformui64NV)
+#define glUniformui64vNV		MANGLE(Uniformui64vNV)
 #define glUnlockArraysEXT		MANGLE(UnlockArraysEXT)
 #define glUnmapBufferARB		MANGLE(UnmapBufferARB)
 #define glUnmapBuffer		MANGLE(UnmapBuffer)
@@ -1609,6 +1644,7 @@
 #define glUpdateObjectBufferATI		MANGLE(UpdateObjectBufferATI)
 #define glUseProgram		MANGLE(UseProgram)
 #define glUseProgramObjectARB		MANGLE(UseProgramObjectARB)
+#define glUseShaderProgramEXT		MANGLE(UseShaderProgramEXT)
 #define glValidateProgramARB		MANGLE(ValidateProgramARB)
 #define glValidateProgram		MANGLE(ValidateProgram)
 #define glVariantArrayObjectATI		MANGLE(VariantArrayObjectATI)
@@ -1762,6 +1798,7 @@
 #define glVertexAttrib4usv		MANGLE(VertexAttrib4usv)
 #define glVertexAttribArrayObjectATI		MANGLE(VertexAttribArrayObjectATI)
 #define glVertexAttribDivisorARB		MANGLE(VertexAttribDivisorARB)
+#define glVertexAttribFormatNV		MANGLE(VertexAttribFormatNV)
 #define glVertexAttribI1iEXT		MANGLE(VertexAttribI1iEXT)
 #define glVertexAttribI1i		MANGLE(VertexAttribI1i)
 #define glVertexAttribI1ivEXT		MANGLE(VertexAttribI1ivEXT)
@@ -1802,6 +1839,7 @@
 #define glVertexAttribI4uiv		MANGLE(VertexAttribI4uiv)
 #define glVertexAttribI4usvEXT		MANGLE(VertexAttribI4usvEXT)
 #define glVertexAttribI4usv		MANGLE(VertexAttribI4usv)
+#define glVertexAttribIFormatNV		MANGLE(VertexAttribIFormatNV)
 #define glVertexAttribIPointerEXT		MANGLE(VertexAttribIPointerEXT)
 #define glVertexAttribIPointer		MANGLE(VertexAttribIPointer)
 #define glVertexAttribPointerARB		MANGLE(VertexAttribPointerARB)
@@ -1827,6 +1865,7 @@
 #define glVertexBlendARB		MANGLE(VertexBlendARB)
 #define glVertexBlendEnvfATI		MANGLE(VertexBlendEnvfATI)
 #define glVertexBlendEnviATI		MANGLE(VertexBlendEnviATI)
+#define glVertexFormatNV		MANGLE(VertexFormatNV)
 #define glVertexPointerEXT		MANGLE(VertexPointerEXT)
 #define glVertexPointerListIBM		MANGLE(VertexPointerListIBM)
 #define glVertexPointer		MANGLE(VertexPointer)
@@ -1868,6 +1907,10 @@
 #define glVertexWeighthNV		MANGLE(VertexWeighthNV)
 #define glVertexWeighthvNV		MANGLE(VertexWeighthvNV)
 #define glVertexWeightPointerEXT		MANGLE(VertexWeightPointerEXT)
+#define glVideoCaptureNV		MANGLE(VideoCaptureNV)
+#define glVideoCaptureStreamParameterdvNV		MANGLE(VideoCaptureStreamParameterdvNV)
+#define glVideoCaptureStreamParameterfvNV		MANGLE(VideoCaptureStreamParameterfvNV)
+#define glVideoCaptureStreamParameterivNV		MANGLE(VideoCaptureStreamParameterivNV)
 #define glViewport		MANGLE(Viewport)
 #define glWaitSync		MANGLE(WaitSync)
 #define glWeightbvARB		MANGLE(WeightbvARB)
diff --git a/progs/demos/engine.c b/progs/demos/engine.c
index 3cf311e..838d28c 100644
--- a/progs/demos/engine.c
+++ b/progs/demos/engine.c
@@ -120,7 +120,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    },
    {
       "Inline-4",
@@ -136,7 +140,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    },
    {
       "Boxer-6",
@@ -152,7 +160,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    }
 };
 
diff --git a/progs/demos/fire.c b/progs/demos/fire.c
index dd70f61..475582c 100644
--- a/progs/demos/fire.c
+++ b/progs/demos/fire.c
@@ -6,6 +6,7 @@
  *            Humanware s.r.l.
  */
 
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
@@ -725,8 +726,13 @@ main(int ac, char **av)
 
    maxage = 1.0 / dt;
 
-   if (ac == 2)
+   if (ac == 2) {
       np = atoi(av[1]);
+      if (np <= 0 || np > 1000000) {
+         fprintf(stderr, "Invalid input.\n");
+         exit(-1);
+      }
+   }
 
    if (ac == 4) {
       WIDTH = atoi(av[2]);
@@ -759,7 +765,9 @@ main(int ac, char **av)
    glFogfv(GL_FOG_COLOR, fogcolor);
    glFogf(GL_FOG_DENSITY, 0.1);
 
+   assert(np > 0);
    p = (part *) malloc(sizeof(part) * np);
+   assert(p);
 
    for (i = 0; i < np; i++)
       setnewpart(&p[i]);
diff --git a/progs/demos/geartrain.c b/progs/demos/geartrain.c
index 8fe405e..e6567dd 100644
--- a/progs/demos/geartrain.c
+++ b/progs/demos/geartrain.c
@@ -25,6 +25,7 @@
  */
 
 
+#include <assert.h>
 #include <math.h>
 #include <stdlib.h>
 #include <GL/glut.h>
@@ -129,8 +130,10 @@ Clear_Buffers ()
 static void
 LoadTriplet (TDA A)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s %s %s", Buf1, Buf2, Buf3, Buf4);
+    result = fscanf (mainfile, "%s %s %s %s", Buf1, Buf2, Buf3, Buf4);
+    assert(result != EOF);
     A[0] = atof (Buf2);
     A[1] = atof (Buf3);
     A[2] = atof (Buf4);
@@ -140,8 +143,10 @@ LoadTriplet (TDA A)
 static void
 LoadReal (float *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     *a = atof (Buf2);
 }
 
@@ -149,8 +154,10 @@ LoadReal (float *a)
 static void
 LoadInteger (int *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     *a = atoi (Buf2);
 }
 
@@ -158,8 +165,10 @@ LoadInteger (int *a)
 static void
 LoadText (char *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     strcpy (a, Buf2);
 }
 
@@ -177,8 +186,10 @@ getdata (char filename[])
 
     do
     {
+	int result;
 	Clear_Buffers ();
-	fscanf (mainfile, "%s", Buf1);
+	result = fscanf (mainfile, "%s", Buf1);
+	(void) result;
 	if (ferror (mainfile))
 	{
 	    printf ("\nError opening file !\n");
diff --git a/progs/demos/isosurf.c b/progs/demos/isosurf.c
index 2e9dff1..dd56965 100644
--- a/progs/demos/isosurf.c
+++ b/progs/demos/isosurf.c
@@ -132,9 +132,11 @@ static void read_surface( char *filename )
 
    numverts = 0;
    while (!feof(f) && numverts<maxverts) {
-      fscanf( f, "%f %f %f  %f %f %f",
-	      &data[numverts][0], &data[numverts][1], &data[numverts][2],
-	      &data[numverts][3], &data[numverts][4], &data[numverts][5] );
+      int result;
+      result = fscanf( f, "%f %f %f  %f %f %f",
+	               &data[numverts][0], &data[numverts][1], &data[numverts][2],
+	               &data[numverts][3], &data[numverts][4], &data[numverts][5] );
+      (void) result;
       numverts++;
    }
    numverts--;
diff --git a/progs/demos/terrain.c b/progs/demos/terrain.c
index be78ea4..9ba7b61 100644
--- a/progs/demos/terrain.c
+++ b/progs/demos/terrain.c
@@ -8,6 +8,7 @@
  * based on a Mikael SkiZoWalker's (MoDEL) / France (Skizo@Hol.Fr) demo
  */
 
+#include <assert.h>
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
@@ -559,12 +560,14 @@ loadpic(void)
    FILE *FilePic;
    int i, tmp;
    GLenum gluerr;
+   size_t result;
 
    if ((FilePic = fopen("terrain.dat", "r")) == NULL) {
       fprintf(stderr, "Error loading terrain.dat\n");
       exit(-1);
    }
-   fread(bufferter, 256 * 256, 1, FilePic);
+   result = fread(bufferter, 256 * 256, 1, FilePic);
+   assert(result == 1);
    fclose(FilePic);
 
    for (i = 0; i < (256 * 256); i++) {
-      exit(1);
-   }
-   printf("GL_RENDERER = %s\n", (char *) glGetString(GL_RENDERER));
-
-   /* Setup the fragment program */
-   glGenProgramsARB(1, &modulateProg);
-   glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, modulateProg);
-   glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
-                        strlen(modulate2D), (const GLubyte *)modulate2D);
-
-   printf("glGetError = 0x%x\n", (int) glGetError());
-   printf("glError(GL_PROGRAM_ERROR_STRING_ARB) = %s\n",
-          (char *) glGetString(GL_PROGRAM_ERROR_STRING_ARB));
-
-   glEnable(GL_FRAGMENT_PROGRAM_ARB);
-
-   glClearColor(.3, .3, .3, 0);
-}
-
-static void Reshape(int width, int height)
-{
-
-    glViewport(0, 0, (GLint)width, (GLint)height);
-
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glOrtho(-1.0, 1.0, -1.0, 1.0, -0.5, 1000.0);
-    glMatrixMode(GL_MODELVIEW);
-}
-
-static void Key(unsigned char key, int x, int y)
-{
-
-    switch (key) {
-      case 27:
-	exit(1);
-      default:
-	break;
-    }
-
-    glutPostRedisplay();
-}
-
-static void Draw(void)
-{
-   glClear(GL_COLOR_BUFFER_BIT); 
-
-   glBegin(GL_TRIANGLES);
-   glColor3f(0,0,1); 
-   glVertex3f( 0.9, -0.9, -30.0);
-   glColor3f(1,0,0); 
-   glVertex3f( 0.9,  0.9, -30.0);
-   glColor3f(0,1,0); 
-   glVertex3f(-0.9,  0.0, -30.0);
-   glEnd();
-
-   glFlush();
-
-
-}
-
-
-int main(int argc, char **argv)
-{
-    GLenum type;
-
-    glutInit(&argc, argv);
-
-
-
-    glutInitWindowPosition(0, 0); glutInitWindowSize( 250, 250);
-
-    type = GLUT_RGB;
-    type |= GLUT_SINGLE;
-    glutInitDisplayMode(type);
-
-    if (glutCreateWindow("First Tri") == GL_FALSE) {
-	exit(1);
-    }
-
-    glewInit();
-
-    Init();
-
-    glutReshapeFunc(Reshape);
-    glutKeyboardFunc(Key);
-    glutDisplayFunc(Draw);
-    glutMainLoop();
-	return 0;
-}
diff --git a/progs/glsl/convolutions.c b/progs/glsl/convolutions.c
index 350e61b..fdfaf56 100644
--- a/progs/glsl/convolutions.c
+++ b/progs/glsl/convolutions.c
@@ -182,7 +182,7 @@ static void fillConvolution(GLint *k,
 static void setupConvolution()
 {
    GLint *kernel = (GLint*)malloc(sizeof(GLint) * 9);
-   GLfloat scale;
+   GLfloat scale = 0.0;
    GLfloat *vecKer = (GLfloat*)malloc(sizeof(GLfloat) * 9 * 4);
    GLuint loc;
    GLuint i;
diff --git a/progs/glsl/shtest.c b/progs/glsl/shtest.c
index 88315d7..7b1917b 100644
--- a/progs/glsl/shtest.c
+++ b/progs/glsl/shtest.c
@@ -492,9 +492,8 @@ ReadConfigFile(const char *filename, struct config_file *conf)
    conf->num_uniforms = 0;
 
    /* ugly but functional parser */
-   while (!feof(f)) {
-      fgets(line, sizeof(line), f);
-      if (!feof(f) && line[0]) {
+   while (fgets(line, sizeof(line), f) != NULL) {
+      if (line[0]) {
          if (strncmp(line, "vs ", 3) == 0) {
             VertShaderFile = strdup(line + 3);
             VertShaderFile[strlen(VertShaderFile) - 1] = 0;
@@ -550,6 +549,10 @@ ReadConfigFile(const char *filename, struct config_file *conf)
 
             type = TypeFromName(typeName);
 
+            if (strlen(name) + 1 > sizeof(conf->uniforms[conf->num_uniforms].name)) {
+               fprintf(stderr, "string overflow\n");
+               exit(1);
+            }
             strcpy(conf->uniforms[conf->num_uniforms].name, name);
             conf->uniforms[conf->num_uniforms].value[0] = v1;
             conf->uniforms[conf->num_uniforms].value[1] = v2;
diff --git a/progs/glsl/vert-tex.c b/progs/glsl/vert-tex.c
index 4c8bfa5..2b93c78 100644
--- a/progs/glsl/vert-tex.c
+++ b/progs/glsl/vert-tex.c
@@ -40,15 +40,6 @@ static GLboolean Anim = GL_TRUE;
 static GLboolean WireFrame = GL_TRUE;
 static GLfloat xRot = -70.0f, yRot = 0.0f, zRot = 0.0f;
 
-
-/* value[0] = tex unit */
-static struct uniform_info Uniforms[] = {
-   { "tex1",  1, GL_SAMPLER_2D, { 0, 0, 0, 0 }, -1 },
-   END_OF_UNIFORMS
-};
-
-
-
 static void
 Idle(void)
 {
diff --git a/progs/samples/olympic.c b/progs/samples/olympic.c
index 5385e48..209a8c1 100644
--- a/progs/samples/olympic.c
+++ b/progs/samples/olympic.c
@@ -74,7 +74,7 @@ int iters[RINGS];
 GLuint theTorus;
 
 
-void FillTorus(float rc, int numc, float rt, int numt)
+static void FillTorus(float rc, int numc, float rt, int numt)
 {
     int i, j, k;
     double s, t;
@@ -106,7 +106,7 @@ void FillTorus(float rc, int numc, float rt, int numt)
     }
 }
 
-float Clamp(int iters_left, float t)
+static float Clamp(int iters_left, float t)
 {
     if (iters_left < 3) {
 	return 0.0;
@@ -114,7 +114,7 @@ float Clamp(int iters_left, float t)
     return (iters_left-2)*t/iters_left;
 }
 
-void DrawScene(void)
+static void DrawScene(void)
 {
     int i, j;
     GLboolean goIdle;
@@ -172,7 +172,7 @@ void DrawScene(void)
     }
 }
 
-float MyRand(void)
+static float MyRand(void)
 {
    return 10.0 * ( (float) rand() / (float) RAND_MAX - 0.5 );
 }
@@ -181,12 +181,12 @@ float MyRand(void)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
 
-void ReInit(void)
+static void ReInit(void)
 {
     int i;
     float deviation;
@@ -206,7 +206,7 @@ void ReInit(void)
     glutIdleFunc(glut_post_redisplay_p);
 }
 
-void Init(void)
+static void Init(void)
 {
     float base, height;
     float aspect, x, y;
@@ -312,13 +312,13 @@ void Init(void)
     glMatrixMode(GL_MODELVIEW);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     glViewport(0, 0, width, height);
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -330,7 +330,7 @@ void Key(unsigned char key, int x, int y)
     }
 }
 
-GLenum Args(int argc, char **argv)
+static GLenum Args(int argc, char **argv)
 {
     GLint i;
 
diff --git a/progs/samples/overlay.c b/progs/samples/overlay.c
index 23b5a47..6087cef 100644
--- a/progs/samples/overlay.c
+++ b/progs/samples/overlay.c
@@ -69,19 +69,19 @@ starRec stars[MAXSTARS];
 float sinTable[MAXANGLES];
 
 
-float Sin(float angle)
+static float Sin(float angle)
 {
 
     return (sinTable[(GLint)angle]);
 }
 
-float Cos(float angle)
+static float Cos(float angle)
 {
 
     return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]);
 }
 
-void NewStar(GLint n, GLint d)
+static void NewStar(GLint n, GLint d)
 {
 
     if (rand()%4 == 0) {
@@ -103,7 +103,7 @@ void NewStar(GLint n, GLint d)
     }
 }
 
-void RotatePoint(float *x, float *y, float rotation)
+static void RotatePoint(float *x, float *y, float rotation)
 {
     float tmpX, tmpY;
 
@@ -113,7 +113,7 @@ void RotatePoint(float *x, float *y, float rotation)
     *y = tmpY;
 }
 
-void MoveStars(void)
+static void MoveStars(void)
 {
     float offset;
     GLint n;
@@ -134,7 +134,7 @@ void MoveStars(void)
     }
 }
 
-GLenum StarPoint(GLint n)
+static GLenum StarPoint(GLint n)
 {
     float x0, y0, x1, y1, width;
     GLint i;
@@ -182,7 +182,7 @@ GLenum StarPoint(GLint n)
     }
 }
 
-void ShowStars(void)
+static void ShowStars(void)
 {
     GLint n;
 
@@ -221,7 +221,7 @@ static void Init(void)
     glDisable(GL_DITHER);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     windW = (GLint)width;
@@ -262,7 +262,7 @@ static void Key(unsigned char key, int x, int y)
     }
 }
 
-void Idle(void)
+static void Idle(void)
 {
 
     if (overlayInit == GL_FALSE) {
diff --git a/progs/samples/rgbtoppm.c b/progs/samples/rgbtoppm.c
index dcb7422..403578e 100644
--- a/progs/samples/rgbtoppm.c
+++ b/progs/samples/rgbtoppm.c
@@ -3,6 +3,7 @@
 
 /* texload is a simplistic routine for reading an SGI .rgb image file. */
 
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h> 
 #include <string.h>
@@ -25,7 +26,7 @@ typedef struct _ImageRec {
     int *rowSize;
 } ImageRec;
 
-void
+static void
 rgbtorgb(unsigned char *r,unsigned char *g,unsigned char *b,unsigned char *l,int n) {
     while(n--) {
         l[0] = r[0];
@@ -72,6 +73,7 @@ static ImageRec *ImageOpen(char *fileName)
     ImageRec *image;
     int swapFlag;
     int x;
+    int result;
 
     endianTest.testWord = 1;
     if (endianTest.testByte[0] == 1) {
@@ -90,7 +92,8 @@ static ImageRec *ImageOpen(char *fileName)
         return NULL;
     }
 
-    fread(image, 1, 12, image->file);
+    result = fread(image, 1, 12, image->file);
+    assert(result == 12);
 
     if (swapFlag) {
         ConvertShort(&image->imagic, 1);
@@ -117,8 +120,10 @@ static ImageRec *ImageOpen(char *fileName)
         }
         image->rleEnd = 512 + (2 * x);
         fseek(image->file, 512, SEEK_SET);
-        fread(image->rowStart, 1, x, image->file);
-        fread(image->rowSize, 1, x, image->file);
+        result = fread(image->rowStart, 1, x, image->file);
+        assert(result == x);
+        result = fread(image->rowSize, 1, x, image->file);
+        assert(result == x);
         if (swapFlag) {
             ConvertUint(image->rowStart, x/(int) sizeof(unsigned));
             ConvertUint((unsigned *)image->rowSize, x/(int) sizeof(int));
@@ -138,11 +143,13 @@ static void
 ImageGetRow(ImageRec *image, unsigned char *buf, int y, int z) {
     unsigned char *iPtr, *oPtr, pixel;
     int count;
+    int result;
 
     if ((image->type & 0xFF00) == 0x0100) {
         fseek(image->file, (long) image->rowStart[y+z*image->ysize], SEEK_SET);
-        fread(image->tmp, 1, (unsigned int)image->rowSize[y+z*image->ysize],
-              image->file);
+        result = fread(image->tmp, 1, (unsigned int)image->rowSize[y+z*image->ysize],
+                       image->file);
+        assert(result == (unsigned int)image->rowSize[y+z*image->ysize]);
 
         iPtr = image->tmp;
         oPtr = buf;
@@ -166,11 +173,13 @@ ImageGetRow(ImageRec *image, unsigned char *buf, int y, int z) {
     } else {
         fseek(image->file, 512+(y*image->xsize)+(z*image->xsize*image->ysize),
               SEEK_SET);
-        fread(buf, 1, image->xsize, image->file);
+        result = fread(buf, 1, image->xsize, image->file);
+        assert(result == image->xsize);
     }
 }
 
-GLubyte *
+#if 0
+static GLubyte *
 read_alpha_texture(char *name, int *width, int *height)
 {
     unsigned char *base, *lptr;
@@ -199,8 +208,9 @@ read_alpha_texture(char *name, int *width, int *height)
 
     return (unsigned char *) base;
 }
+#endif
 
-GLubyte *
+static GLubyte *
 read_rgb_texture(char *name, int *width, int *height)
 {
     unsigned char *base, *ptr;
@@ -261,7 +271,8 @@ read_rgb_texture(char *name, int *width, int *height)
 
 int main(int argc, char **argv)
 {
-	int width, height;
+	int width = 0;
+	int height = 0;
 	GLubyte *data;
         char buff[32];
         int n;
diff --git a/progs/samples/sphere.c b/progs/samples/sphere.c
index 7d0508d..23d4fe3 100644
--- a/progs/samples/sphere.c
+++ b/progs/samples/sphere.c
@@ -445,7 +445,7 @@ GLfloat identity[16] = {
 };
 
 
-void BuildCylinder(int numEdges)
+static void BuildCylinder(int numEdges)
 {
     int i, top = 1.0, bottom = -1.0;
     float x[100], y[100], angle;
@@ -481,7 +481,7 @@ void BuildCylinder(int numEdges)
     glEndList();
 }
 
-void BuildTorus(float rc, int numc, float rt, int numt)
+static void BuildTorus(float rc, int numc, float rt, int numt)
 {
     int i, j, k;
     double s, t;
@@ -515,7 +515,7 @@ void BuildTorus(float rc, int numc, float rt, int numt)
     glEndList();
 }
 
-void BuildCage(void)
+static void BuildCage(void)
 {
     int i;
     float inc;
@@ -609,7 +609,7 @@ void BuildCage(void)
     glEndList();
 }
 
-void BuildCube(void)
+static void BuildCube(void)
 {
     int i, j;
 
@@ -628,7 +628,7 @@ void BuildCube(void)
     glEndList();
 }
 
-void BuildLists(void)
+static void BuildLists(void)
 {
 
     cube = glGenLists(1);
@@ -646,7 +646,7 @@ void BuildLists(void)
     genericObject = torus;
 }
 
-void SetDefaultSettings(void)
+static void SetDefaultSettings(void)
 {
 
     magFilter = nnearest;
@@ -657,7 +657,7 @@ void SetDefaultSettings(void)
     autoRotate = GL_TRUE;
 }
 
-unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
+static unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
 {
     unsigned char *outData, *out_ptr, *in_ptr;
     int i;
@@ -677,7 +677,7 @@ unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
     return outData;
 }
 
-void Init(void)
+static void Init(void)
 {
     float ambient[] = {0.0, 0.0, 0.0, 1.0};
     float diffuse[] = {1.0, 1.0, 1.0, 1.0};
@@ -753,7 +753,7 @@ void Init(void)
     BuildLists();
 }
 
-void ReInit(void)
+static void ReInit(void)
 {
     if (genericObject == torus) {
 	glEnable(GL_DEPTH_TEST);
@@ -773,7 +773,7 @@ void ReInit(void)
     glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, textureEnvironment);
 }
 
-void Draw(void)
+static void Draw(void)
 {
     glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
 
@@ -806,7 +806,7 @@ void Draw(void)
     glutSwapBuffers();
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
     W = width;
     H = height;
@@ -818,7 +818,7 @@ void Reshape(int width, int height)
     glMatrixMode(GL_MODELVIEW);
 }
 
-void Idle(void)
+static void Idle(void)
 {
    static double t0 = -1.;
    double t, dt;
@@ -833,7 +833,7 @@ void Idle(void)
    glutPostRedisplay();
 }
 
-void Key2(int key, int x, int y)
+static void Key2(int key, int x, int y)
 {
 
     switch (key) {
@@ -863,7 +863,7 @@ void Key2(int key, int x, int y)
     glutPostRedisplay();
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -950,7 +950,7 @@ void Key(unsigned char key, int x, int y)
     glutPostRedisplay();
 }
 
-GLenum Args(int argc, char **argv)
+static GLenum Args(int argc, char **argv)
 {
     GLint i;
 
diff --git a/progs/samples/star.c b/progs/samples/star.c
index 2cf470e..2c44ebf 100644
--- a/progs/samples/star.c
+++ b/progs/samples/star.c
@@ -67,19 +67,19 @@ starRec stars[MAXSTARS];
 float sinTable[MAXANGLES];
 
 
-float Sin(float angle)
+static float Sin(float angle)
 {
 
     return (sinTable[(GLint)angle]);
 }
 
-float Cos(float angle)
+static float Cos(float angle)
 {
 
     return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]);
 }
 
-void NewStar(GLint n, GLint d)
+static void NewStar(GLint n, GLint d)
 {
 
     if (rand()%4 == 0) {
@@ -101,7 +101,7 @@ void NewStar(GLint n, GLint d)
     }
 }
 
-void RotatePoint(float *x, float *y, float rotation)
+static void RotatePoint(float *x, float *y, float rotation)
 {
     float tmpX, tmpY;
 
@@ -111,7 +111,7 @@ void RotatePoint(float *x, float *y, float rotation)
     *y = tmpY;
 }
 
-void MoveStars(void)
+static void MoveStars(void)
 {
     float offset;
     GLint n;
@@ -142,7 +142,7 @@ void MoveStars(void)
     }
 }
 
-GLenum StarPoint(GLint n)
+static GLenum StarPoint(GLint n)
 {
     float x0, y0, x1, y1, width;
     GLint i;
@@ -190,7 +190,7 @@ GLenum StarPoint(GLint n)
     }
 }
 
-void ShowStars(void)
+static void ShowStars(void)
 {
     GLint n;
 
@@ -229,7 +229,7 @@ static void Init(void)
     glDisable(GL_DITHER);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     windW = (GLint)width;
@@ -260,7 +260,7 @@ static void Key(unsigned char key, int x, int y)
     }
 }
 
-void Draw(void)
+static void Draw(void)
 {
 
     MoveStars();
@@ -307,7 +307,7 @@ static GLenum Args(int argc, char **argv)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
diff --git a/progs/samples/stretch.c b/progs/samples/stretch.c
index 1fd015d..11201dc 100644
--- a/progs/samples/stretch.c
+++ b/progs/samples/stretch.c
@@ -67,7 +67,7 @@ int cCount, cIndex[2], cStep;
 GLenum op = OP_NOOP;
 
 
-void DrawImage(void)
+static void DrawImage(void)
 {
 
     glRasterPos2i(0, 0);
@@ -84,7 +84,7 @@ void DrawImage(void)
 		 image->data);
 }
 
-void DrawPoint(void)
+static void DrawPoint(void)
 {
     int i;
 
@@ -102,7 +102,7 @@ void DrawPoint(void)
     }
 }
 
-void InitVList(void)
+static void InitVList(void)
 {
 
     vList[0].x = 0.0;
@@ -141,7 +141,7 @@ void InitVList(void)
     vList[4].tY = cList[0].y / (float)imageSizeY;
 }
 
-void ScaleImage(int sizeX, int sizeY)
+static void ScaleImage(int sizeX, int sizeY)
 {
     GLubyte *buf;
 
@@ -154,7 +154,7 @@ void ScaleImage(int sizeX, int sizeY)
     image->sizeY = sizeY;
 }
 
-void SetPoint(int x, int y)
+static void SetPoint(int x, int y)
 {
 
     cList[cCount].x = (float)x;
@@ -162,7 +162,7 @@ void SetPoint(int x, int y)
     cCount++;
 }
 
-void Stretch(void)
+static void Stretch(void)
 {
 
     glBegin(GL_TRIANGLES);
@@ -221,7 +221,7 @@ void Stretch(void)
     }
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -245,7 +245,7 @@ void Key(unsigned char key, int x, int y)
     glutPostRedisplay();
 }
 
-void Mouse(int button, int state, int mouseX, int mouseY)
+static void Mouse(int button, int state, int mouseX, int mouseY)
 {
 
     if (state != GLUT_DOWN)
@@ -263,7 +263,7 @@ void Mouse(int button, int state, int mouseX, int mouseY)
     glutPostRedisplay();
 }
 
-void Animate(void)
+static void Animate(void)
 {
     static double t0 = -1.;
     double t, dt;
@@ -322,7 +322,7 @@ static GLenum Args(int argc, char **argv)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
diff --git a/progs/samples/wave.c b/progs/samples/wave.c
index d3c4687..396a694 100644
--- a/progs/samples/wave.c
+++ b/progs/samples/wave.c
@@ -92,7 +92,7 @@ GLubyte contourTexture2[] = {
 #endif
 
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
     static double t0 = -1.;
     double t, dt;
diff --git a/progs/util/readtex.c b/progs/util/readtex.c
index d1c50a4..f6f5114 100644
--- a/progs/util/readtex.c
+++ b/progs/util/readtex.c
@@ -9,6 +9,7 @@
 
 #include <GL/gl.h>
 #include <GL/glu.h>
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h> 
 #include <string.h>
@@ -89,6 +90,7 @@ static rawImageRec *RawImageOpen(const char *fileName)
    rawImageRec *raw;
    GLenum swapFlag;
    int x;
+   size_t result;
 
    endianTest.testWord = 1;
    if (endianTest.testByte[0] == 1) {
@@ -114,7 +116,8 @@ static rawImageRec *RawImageOpen(const char *fileName)
       }
    }
 
-   fread(raw, 1, 12, raw->file);
+   result = fread(raw, 1, 12, raw->file);
+   assert(result == 12);
 
    if (swapFlag) {
       ConvertShort(&raw->imagic, 1);
@@ -162,8 +165,10 @@ static rawImageRec *RawImageOpen(const char *fileName)
       }
       raw->rleEnd = 512 + (2 * x);
       fseek(raw->file, 512, SEEK_SET);
-      fread(raw->rowStart, 1, x, raw->file);
-      fread(raw->rowSize, 1, x, raw->file);
+      result = fread(raw->rowStart, 1, x, raw->file);
+      assert(result == x);
+      result = fread(raw->rowSize, 1, x, raw->file);
+      assert(result == x);
       if (swapFlag) {
          ConvertLong(raw->rowStart, (long) (x/sizeof(GLuint)));
          ConvertLong((GLuint *)raw->rowSize, (long) (x/sizeof(GLint)));
@@ -193,11 +198,13 @@ static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
 {
    unsigned char *iPtr, *oPtr, pixel;
    int count, done = 0;
+   size_t result;
 
    if ((raw->type & 0xFF00) == 0x0100) {
       fseek(raw->file, (long) raw->rowStart[y+z*raw->sizeY], SEEK_SET);
-      fread(raw->tmp, 1, (unsigned int)raw->rowSize[y+z*raw->sizeY],
-            raw->file);
+      result = fread(raw->tmp, 1, (unsigned int)raw->rowSize[y+z*raw->sizeY],
+                     raw->file);
+      assert(result == (unsigned int)raw->rowSize[y+z*raw->sizeY]);
       
       iPtr = raw->tmp;
       oPtr = buf;
@@ -222,7 +229,8 @@ static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
    } else {
       fseek(raw->file, 512+(y*raw->sizeX)+(z*raw->sizeX*raw->sizeY),
             SEEK_SET);
-      fread(buf, 1, raw->sizeX, raw->file);
+      result = fread(buf, 1, raw->sizeX, raw->file);
+      assert(result == raw->sizeX);
    }
 }
 
diff --git a/progs/xdemos/glsync.c b/progs/xdemos/glsync.c
index da87306..9d4b0f1 100644
--- a/progs/xdemos/glsync.c
+++ b/progs/xdemos/glsync.c
@@ -89,7 +89,7 @@ static char optstr[] = "w:h:s:v";
 enum sync_type {
 	none = 0,
 	sgi_video_sync,
-	buffer_swap,
+	buffer_swap
 };
 
 static void usage(char *name)
diff --git a/progs/xdemos/glxheads.c b/progs/xdemos/glxheads.c
index b1a63d3..edae0a3 100644
--- a/progs/xdemos/glxheads.c
+++ b/progs/xdemos/glxheads.c
@@ -145,14 +145,40 @@ AddHead(const char *displayName)
    /* save the info for this head */
    {
       struct head *h = &Heads[NumHeads];
+      const char * tmp;
+
+      if (strlen(displayName) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "displayName string length overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, displayName);
+
       h->Dpy = dpy;
       h->Win = win;
       h->Context = ctx;
       h->Angle = 0.0;
-      strcpy(h->Version, (char *) glGetString(GL_VERSION));
-      strcpy(h->Vendor, (char *) glGetString(GL_VENDOR));
-      strcpy(h->Renderer, (char *) glGetString(GL_RENDERER));
+
+      tmp = (char *) glGetString(GL_VERSION);
+      if (strlen(tmp) + 1 > sizeof(h->Version)) {
+         Error(displayName, "GL_VERSION string length overflow");
+         return NULL;
+      }
+      strcpy(h->Version, tmp);
+
+      tmp = (char *) glGetString(GL_VENDOR);
+      if (strlen(tmp) + 1 > sizeof(h->Vendor)) {
+         Error(displayName, "GL_VENDOR string length overflow");
+         return NULL;
+      }
+      strcpy(h->Vendor, tmp);
+
+      tmp = (char *) glGetString(GL_RENDERER);
+      if (strlen(tmp) + 1 > sizeof(h->Renderer)) {
+         Error(displayName, "GL_RENDERER string length overflow");
+         return NULL;
+      }
+      strcpy(h->Renderer, tmp);
+
       NumHeads++;
       return &Heads[NumHeads-1];
    }
diff --git a/progs/xdemos/manywin.c b/progs/xdemos/manywin.c
index ee357f3..8ad5c4f 100644
--- a/progs/xdemos/manywin.c
+++ b/progs/xdemos/manywin.c
@@ -177,14 +177,40 @@ AddHead(const char *displayName, const char *name)
    /* save the info for this head */
    {
       struct head *h = &Heads[NumHeads];
+      const char * tmp;
+
+      if (strlen(name) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "name string overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, name);
+
       h->Dpy = dpy;
       h->Win = win;
       h->Context = ctx;
       h->Angle = 0.0;
-      strcpy(h->Version, (char *) glGetString(GL_VERSION));
-      strcpy(h->Vendor, (char *) glGetString(GL_VENDOR));
-      strcpy(h->Renderer, (char *) glGetString(GL_RENDERER));
+
+      tmp = (char *) glGetString(GL_VERSION);
+      if (strlen(tmp) + 1 > sizeof(h->Version)) {
+         Error(displayName, "GL_VERSION string overflow");
+         return NULL;
+      }
+      strcpy(h->Version, tmp);
+
+      tmp = (char *) glGetString(GL_VENDOR);
+      if (strlen(tmp) + 1 > sizeof(h->Vendor)) {
+         Error(displayName, "GL_VENDOR string overflow");
+         return NULL;
+      }
+      strcpy(h->Vendor, tmp);
+
+      tmp = (char *) glGetString(GL_RENDERER);
+      if (strlen(tmp) + 1 > sizeof(h->Renderer)) {
+         Error(displayName, "GL_RENDERER string overflow");
+         return NULL;
+      }
+      strcpy(h->Renderer, tmp);
+
       NumHeads++;
       return &Heads[NumHeads-1];
    }
@@ -374,6 +400,8 @@ main(int argc, char *argv[])
       }
       if (n < 1)
          n = 1;
+      if (n > MAX_HEADS)
+         n = MAX_HEADS;
 
       printf("%d windows\n", n);
       for (i = 0; i < n; i++) {
diff --git a/progs/xdemos/sharedtex_mt.c b/progs/xdemos/sharedtex_mt.c
index f924448..a90903a 100644
--- a/progs/xdemos/sharedtex_mt.c
+++ b/progs/xdemos/sharedtex_mt.c
@@ -174,6 +174,10 @@ AddWindow(Display *dpy, const char *displayName, int xpos, int ypos,
    {
       static int id = 0;
       struct window *h = &Windows[NumWindows];
+      if (strlen(displayName) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "string overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, displayName);
       h->Dpy = dpy;
       h->Win = win;
diff --git a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
index 2ef4293..1ee2bf9 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
+++ b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
@@ -80,11 +80,27 @@ struct fenced_buffer_list
  */
 struct fenced_buffer
 {
+   /*
+    * Immutable members.
+    */
+
    struct pb_buffer base;
-   
    struct pb_buffer *buffer;
+   struct fenced_buffer_list *list;
+
+   /**
+    * Protected by fenced_buffer_list::mutex
+    */
+   struct list_head head;
 
-   /* FIXME: protect access with mutex */
+   /**
+    * Following members are mutable and protected by this mutex.
+    * 
+    * You may lock this mutex alone, or lock it with fenced_buffer_list::mutex
+    * held, but in order to prevent deadlocks you must never lock 
+    * fenced_buffer_list::mutex with this mutex held.
+    */
+   pipe_mutex mutex;
 
    /**
     * A bitmask of PIPE_BUFFER_USAGE_CPU/GPU_READ/WRITE describing the current
@@ -96,9 +112,6 @@ struct fenced_buffer
    struct pb_validate *vl;
    unsigned validation_flags;
    struct pipe_fence_handle *fence;
-
-   struct list_head head;
-   struct fenced_buffer_list *list;
 };
 
 
@@ -110,15 +123,24 @@ fenced_buffer(struct pb_buffer *buf)
 }
 
 
+/**
+ * Add the buffer to the fenced list.
+ * 
+ * fenced_buffer_list::mutex and fenced_buffer::mutex must be held, in this
+ * order, before calling this function.
+ * 
+ * Reference count should be incremented before calling this function.
+ */
 static INLINE void
-_fenced_buffer_add(struct fenced_buffer *fenced_buf)
+fenced_buffer_add_locked(struct fenced_buffer_list *fenced_list, 
+                         struct fenced_buffer *fenced_buf)
 {
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
-
    assert(pipe_is_referenced(&fenced_buf->base.base.reference));
    assert(fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE);
    assert(fenced_buf->fence);
 
+   /* TODO: Move the reference count increment here */
+   
 #ifdef DEBUG
    LIST_DEL(&fenced_buf->head);
    assert(fenced_list->numUnfenced);
@@ -130,32 +152,16 @@ _fenced_buffer_add(struct fenced_buffer *fenced_buf)
 
 
 /**
- * Actually destroy the buffer.
+ * Remove the buffer from the fenced list.
+ * 
+ * fenced_buffer_list::mutex and fenced_buffer::mutex must be held, in this 
+ * order before calling this function.
+ * 
+ * Reference count should be decremented after calling this function.
  */
 static INLINE void
-_fenced_buffer_destroy(struct fenced_buffer *fenced_buf)
-{
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
-   
-   assert(!pipe_is_referenced(&fenced_buf->base.base.reference));
-   assert(!fenced_buf->fence);
-#ifdef DEBUG
-   assert(fenced_buf->head.prev);
-   assert(fenced_buf->head.next);
-   LIST_DEL(&fenced_buf->head);
-   assert(fenced_list->numUnfenced);
-   --fenced_list->numUnfenced;
-#else
-   (void)fenced_list;
-#endif
-   pb_reference(&fenced_buf->buffer, NULL);
-   FREE(fenced_buf);
-}
-
-
-static INLINE void
-_fenced_buffer_remove(struct fenced_buffer_list *fenced_list,
-                      struct fenced_buffer *fenced_buf)
+fenced_buffer_remove_locked(struct fenced_buffer_list *fenced_list,
+                            struct fenced_buffer *fenced_buf)
 {
    struct pb_fence_ops *ops = fenced_list->ops;
 
@@ -177,37 +183,56 @@ _fenced_buffer_remove(struct fenced_buffer_list *fenced_list,
    ++fenced_list->numUnfenced;
 #endif
    
-   /**
-    * FIXME!!!
-    */
-
-   if(!pipe_is_referenced(&fenced_buf->base.base.reference))
-      _fenced_buffer_destroy(fenced_buf);
+   /* TODO: Move the reference count decrement and destruction here */
 }
 
 
+/**
+ * Wait for the fence to expire, and remove it from the fenced list.
+ * 
+ * fenced_buffer::mutex must be held. fenced_buffer_list::mutex must not be 
+ * held -- it will be acquired internally.
+ */
 static INLINE enum pipe_error
-_fenced_buffer_finish(struct fenced_buffer *fenced_buf)
+fenced_buffer_finish_locked(struct fenced_buffer_list *fenced_list,
+                              struct fenced_buffer *fenced_buf)
 {
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
    struct pb_fence_ops *ops = fenced_list->ops;
+   enum pipe_error ret = PIPE_ERROR;
 
 #if 0
    debug_warning("waiting for GPU");
 #endif
 
+   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
    assert(fenced_buf->fence);
+
+   /*
+    * Acquire the global lock. Must release buffer mutex first to preserve
+    * lock order.
+    */
+   pipe_mutex_unlock(fenced_buf->mutex);
+   pipe_mutex_lock(fenced_list->mutex);
+   pipe_mutex_lock(fenced_buf->mutex);
+
    if(fenced_buf->fence) {
-      if(ops->fence_finish(ops, fenced_buf->fence, 0) != 0) {
-	 return PIPE_ERROR;
+      if(ops->fence_finish(ops, fenced_buf->fence, 0) == 0) {
+         /* Remove from the fenced list */
+         /* TODO: remove consequents */
+         fenced_buffer_remove_locked(fenced_list, fenced_buf);
+
+         p_atomic_dec(&fenced_buf->base.base.reference.count);
+         assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+
+         fenced_buf->flags &= ~PIPE_BUFFER_USAGE_GPU_READ_WRITE;
+
+         ret = PIPE_OK;
       }
-      /* Remove from the fenced list */
-      /* TODO: remove consequents */
-      _fenced_buffer_remove(fenced_list, fenced_buf);
    }
 
-   fenced_buf->flags &= ~PIPE_BUFFER_USAGE_GPU_READ_WRITE;
-   return PIPE_OK;
+   pipe_mutex_unlock(fenced_list->mutex);
+
+   return ret;
 }
 
 
@@ -215,8 +240,8 @@ _fenced_buffer_finish(struct fenced_buffer *fenced_buf)
  * Free as many fenced buffers from the list head as possible. 
  */
 static void
-_fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list, 
-                               int wait)
+fenced_buffer_list_check_free_locked(struct fenced_buffer_list *fenced_list, 
+                                     int wait)
 {
    struct pb_fence_ops *ops = fenced_list->ops;
    struct list_head *curr, *next;
@@ -228,21 +253,28 @@ _fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list,
    while(curr != &fenced_list->delayed) {
       fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
 
+      pipe_mutex_lock(fenced_buf->mutex);
+
       if(fenced_buf->fence != prev_fence) {
 	 int signaled;
 	 if (wait)
 	    signaled = ops->fence_finish(ops, fenced_buf->fence, 0);
 	 else
 	    signaled = ops->fence_signalled(ops, fenced_buf->fence, 0);
-	 if (signaled != 0)
+	 if (signaled != 0) {
+            pipe_mutex_unlock(fenced_buf->mutex);
 	    break;
+         }
 	 prev_fence = fenced_buf->fence;
       }
       else {
 	 assert(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0);
       }
 
-      _fenced_buffer_remove(fenced_list, fenced_buf);
+      fenced_buffer_remove_locked(fenced_list, fenced_buf);
+      pipe_mutex_unlock(fenced_buf->mutex);
+
+      pb_reference((struct pb_buffer **)&fenced_buf, NULL);
 
       curr = next; 
       next = curr->next;
@@ -256,30 +288,25 @@ fenced_buffer_destroy(struct pb_buffer *buf)
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);   
    struct fenced_buffer_list *fenced_list = fenced_buf->list;
 
-   pipe_mutex_lock(fenced_list->mutex);
    assert(!pipe_is_referenced(&fenced_buf->base.base.reference));
-   if (fenced_buf->fence) {
-      struct pb_fence_ops *ops = fenced_list->ops;
-      if(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0) {
-	 struct list_head *curr, *prev;
-	 curr = &fenced_buf->head;
-	 prev = curr->prev;
-	 do {
-	    fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
-	    assert(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0);
-	    _fenced_buffer_remove(fenced_list, fenced_buf);
-	    curr = prev;
-	    prev = curr->prev;
-	 } while (curr != &fenced_list->delayed);
-      }	  
-      else {
-	 /* delay destruction */
-      }
-   }
-   else {
-      _fenced_buffer_destroy(fenced_buf);
-   }
+   assert(!fenced_buf->fence);
+
+#ifdef DEBUG
+   pipe_mutex_lock(fenced_list->mutex);
+   assert(fenced_buf->head.prev);
+   assert(fenced_buf->head.next);
+   LIST_DEL(&fenced_buf->head);
+   assert(fenced_list->numUnfenced);
+   --fenced_list->numUnfenced;
    pipe_mutex_unlock(fenced_list->mutex);
+#else
+   (void)fenced_list;
+#endif
+
+   pb_reference(&fenced_buf->buffer, NULL);
+
+   pipe_mutex_destroy(fenced_buf->mutex);
+   FREE(fenced_buf);
 }
 
 
@@ -290,24 +317,23 @@ fenced_buffer_map(struct pb_buffer *buf,
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
    struct fenced_buffer_list *fenced_list = fenced_buf->list;
    struct pb_fence_ops *ops = fenced_list->ops;
-   void *map;
+   void *map = NULL;
+
+   pipe_mutex_lock(fenced_buf->mutex);
 
    assert(!(flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE));
    
    /* Serialize writes */
    if((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_WRITE) ||
       ((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ) && (flags & PIPE_BUFFER_USAGE_CPU_WRITE))) {
-      if(flags & PIPE_BUFFER_USAGE_DONTBLOCK) {
+      if((flags & PIPE_BUFFER_USAGE_DONTBLOCK) &&
+          ops->fence_signalled(ops, fenced_buf->fence, 0) == 0) {
          /* Don't wait for the GPU to finish writing */
-         if(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0)
-            _fenced_buffer_remove(fenced_list, fenced_buf);
-         else
-            return NULL;
-      }
-      else {
-         /* Wait for the GPU to finish writing */
-         _fenced_buffer_finish(fenced_buf);
+         goto done;
       }
+
+      /* Wait for the GPU to finish writing */
+      fenced_buffer_finish_locked(fenced_list, fenced_buf);
    }
 
 #if 0
@@ -324,6 +350,9 @@ fenced_buffer_map(struct pb_buffer *buf,
       fenced_buf->flags |= flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE;
    }
 
+done:
+   pipe_mutex_unlock(fenced_buf->mutex);
+   
    return map;
 }
 
@@ -332,6 +361,9 @@ static void
 fenced_buffer_unmap(struct pb_buffer *buf)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   
+   pipe_mutex_lock(fenced_buf->mutex);
+   
    assert(fenced_buf->mapcount);
    if(fenced_buf->mapcount) {
       pb_unmap(fenced_buf->buffer);
@@ -339,6 +371,8 @@ fenced_buffer_unmap(struct pb_buffer *buf)
       if(!fenced_buf->mapcount)
 	 fenced_buf->flags &= ~PIPE_BUFFER_USAGE_CPU_READ_WRITE;
    }
+   
+   pipe_mutex_unlock(fenced_buf->mutex);
 }
 
 
@@ -350,11 +384,14 @@ fenced_buffer_validate(struct pb_buffer *buf,
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
    enum pipe_error ret;
    
+   pipe_mutex_lock(fenced_buf->mutex);
+
    if(!vl) {
       /* invalidate */
       fenced_buf->vl = NULL;
       fenced_buf->validation_flags = 0;
-      return PIPE_OK;
+      ret = PIPE_OK;
+      goto done;
    }
    
    assert(flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE);
@@ -362,14 +399,17 @@ fenced_buffer_validate(struct pb_buffer *buf,
    flags &= PIPE_BUFFER_USAGE_GPU_READ_WRITE;
 
    /* Buffer cannot be validated in two different lists */ 
-   if(fenced_buf->vl && fenced_buf->vl != vl)
-      return PIPE_ERROR_RETRY;
+   if(fenced_buf->vl && fenced_buf->vl != vl) {
+      ret = PIPE_ERROR_RETRY;
+      goto done;
+   }
    
 #if 0
    /* Do not validate if buffer is still mapped */
    if(fenced_buf->flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE) {
       /* TODO: wait for the thread that mapped the buffer to unmap it */
-      return PIPE_ERROR_RETRY;
+      ret = PIPE_ERROR_RETRY;
+      goto done;
    }
    /* Final sanity checking */
    assert(!(fenced_buf->flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE));
@@ -379,17 +419,21 @@ fenced_buffer_validate(struct pb_buffer *buf,
    if(fenced_buf->vl == vl &&
       (fenced_buf->validation_flags & flags) == flags) {
       /* Nothing to do -- buffer already validated */
-      return PIPE_OK;
+      ret = PIPE_OK;
+      goto done;
    }
    
    ret = pb_validate(fenced_buf->buffer, vl, flags);
    if (ret != PIPE_OK)
-      return ret;
+      goto done;
    
    fenced_buf->vl = vl;
    fenced_buf->validation_flags |= flags;
    
-   return PIPE_OK;
+done:
+   pipe_mutex_unlock(fenced_buf->mutex);
+
+   return ret;
 }
 
 
@@ -404,29 +448,36 @@ fenced_buffer_fence(struct pb_buffer *buf,
    fenced_buf = fenced_buffer(buf);
    fenced_list = fenced_buf->list;
    ops = fenced_list->ops;
-   
-   if(fence == fenced_buf->fence) {
-      /* Nothing to do */
-      return;
-   }
 
-   assert(fenced_buf->vl);
-   assert(fenced_buf->validation_flags);
-   
    pipe_mutex_lock(fenced_list->mutex);
-   if (fenced_buf->fence)
-      _fenced_buffer_remove(fenced_list, fenced_buf);
-   if (fence) {
-      ops->fence_reference(ops, &fenced_buf->fence, fence);
-      fenced_buf->flags |= fenced_buf->validation_flags;
-      _fenced_buffer_add(fenced_buf);
-   }
-   pipe_mutex_unlock(fenced_list->mutex);
+   pipe_mutex_lock(fenced_buf->mutex);
+
+   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+
+   if(fence != fenced_buf->fence) {
+      assert(fenced_buf->vl);
+      assert(fenced_buf->validation_flags);
+      
+      if (fenced_buf->fence) {
+         fenced_buffer_remove_locked(fenced_list, fenced_buf);
+         p_atomic_dec(&fenced_buf->base.base.reference.count);
+         assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+      }
+      if (fence) {
+         ops->fence_reference(ops, &fenced_buf->fence, fence);
+         fenced_buf->flags |= fenced_buf->validation_flags;
+         p_atomic_inc(&fenced_buf->base.base.reference.count);
+         fenced_buffer_add_locked(fenced_list, fenced_buf);
+      }
+
+      pb_fence(fenced_buf->buffer, fence);
    
-   pb_fence(fenced_buf->buffer, fence);
+      fenced_buf->vl = NULL;
+      fenced_buf->validation_flags = 0;
+   }
 
-   fenced_buf->vl = NULL;
-   fenced_buf->validation_flags = 0;
+   pipe_mutex_unlock(fenced_buf->mutex);
+   pipe_mutex_unlock(fenced_list->mutex);
 }
 
 
@@ -436,6 +487,7 @@ fenced_buffer_get_base_buffer(struct pb_buffer *buf,
                               pb_size *offset)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   /* NOTE: accesses immutable members only -- mutex not necessary */
    pb_get_base_buffer(fenced_buf->buffer, base_buf, offset);
 }
 
@@ -475,6 +527,8 @@ fenced_buffer_create(struct fenced_buffer_list *fenced_list,
    buf->buffer = buffer;
    buf->list = fenced_list;
    
+   pipe_mutex_init(buf->mutex);
+
 #ifdef DEBUG
    pipe_mutex_lock(fenced_list->mutex);
    LIST_ADDTAIL(&buf->head, &fenced_list->unfenced);
@@ -516,7 +570,7 @@ fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list,
                               int wait)
 {
    pipe_mutex_lock(fenced_list->mutex);
-   _fenced_buffer_list_check_free(fenced_list, wait);
+   fenced_buffer_list_check_free_locked(fenced_list, wait);
    pipe_mutex_unlock(fenced_list->mutex);
 }
 
@@ -538,11 +592,13 @@ fenced_buffer_list_dump(struct fenced_buffer_list *fenced_list)
    next = curr->next;
    while(curr != &fenced_list->unfenced) {
       fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
+      pipe_mutex_lock(fenced_buf->mutex);
       assert(!fenced_buf->fence);
       debug_printf("%10p %7u %7u\n",
                    (void *) fenced_buf,
                    fenced_buf->base.base.size,
                    p_atomic_read(&fenced_buf->base.base.reference.count));
+      pipe_mutex_unlock(fenced_buf->mutex);
       curr = next; 
       next = curr->next;
    }
@@ -552,6 +608,7 @@ fenced_buffer_list_dump(struct fenced_buffer_list *fenced_list)
    while(curr != &fenced_list->delayed) {
       int signaled;
       fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
+      pipe_mutex_lock(fenced_buf->mutex);
       signaled = ops->fence_signalled(ops, fenced_buf->fence, 0);
       debug_printf("%10p %7u %7u %10p %s\n",
                    (void *) fenced_buf,
@@ -559,6 +616,7 @@ fenced_buffer_list_dump(struct fenced_buffer_list *fenced_list)
                    p_atomic_read(&fenced_buf->base.base.reference.count),
                    (void *) fenced_buf->fence,
                    signaled == 0 ? "y" : "n");
+      pipe_mutex_unlock(fenced_buf->mutex);
       curr = next; 
       next = curr->next;
    }
@@ -579,8 +637,8 @@ fenced_buffer_list_destroy(struct fenced_buffer_list *fenced_list)
 #if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
       sched_yield();
 #endif
-      _fenced_buffer_list_check_free(fenced_list, 1);
       pipe_mutex_lock(fenced_list->mutex);
+      fenced_buffer_list_check_free_locked(fenced_list, 1);
    }
 
 #ifdef DEBUG
@@ -588,6 +646,7 @@ fenced_buffer_list_destroy(struct fenced_buffer_list *fenced_list)
 #endif
       
    pipe_mutex_unlock(fenced_list->mutex);
+   pipe_mutex_destroy(fenced_list->mutex);
    
    fenced_list->ops->destroy(fenced_list->ops);
    
diff --git a/src/gallium/auxiliary/rbug/rbug_context.h b/src/gallium/auxiliary/rbug/rbug_context.h
index da61c23..03126d6 100644
--- a/src/gallium/auxiliary/rbug/rbug_context.h
+++ b/src/gallium/auxiliary/rbug/rbug_context.h
@@ -46,7 +46,7 @@ typedef enum
 	RBUG_BLOCK_BEFORE = 1,
 	RBUG_BLOCK_AFTER = 2,
 	RBUG_BLOCK_RULE = 4,
-	RBUG_BLOCK_MASK = 7,
+	RBUG_BLOCK_MASK = 7
 } rbug_block_t;
 
 struct rbug_proto_context_list
diff --git a/src/gallium/auxiliary/rbug/rbug_proto.h b/src/gallium/auxiliary/rbug/rbug_proto.h
index d273be0..4f3eb75 100644
--- a/src/gallium/auxiliary/rbug/rbug_proto.h
+++ b/src/gallium/auxiliary/rbug/rbug_proto.h
@@ -65,7 +65,7 @@ enum rbug_opcode
 	RBUG_OP_SHADER_DISABLE = 770,
 	RBUG_OP_SHADER_REPLACE = 771,
 	RBUG_OP_SHADER_LIST_REPLY = -768,
-	RBUG_OP_SHADER_INFO_REPLY = -769,
+	RBUG_OP_SHADER_INFO_REPLY = -769
 };
 
 /**
diff --git a/src/gallium/auxiliary/rtasm/rtasm_execmem.c b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
index 01811d5..ffed768 100644
--- a/src/gallium/auxiliary/rtasm/rtasm_execmem.c
+++ b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
@@ -41,6 +41,12 @@
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
+#if defined(PIPE_OS_WINDOWS)
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN 1
+#endif
+#include <windows.h>
+#endif
 
 #if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
 
@@ -118,7 +124,29 @@ rtasm_exec_free(void *addr)
 }
 
 
-#else /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#elif defined(PIPE_OS_WINDOWS)
+
+
+/*
+ * Avoid Data Execution Prevention.
+ */
+
+void *
+rtasm_exec_malloc(size_t size)
+{
+   return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+}
+
+
+void
+rtasm_exec_free(void *addr)
+{
+   VirtualFree(addr, 0, MEM_RELEASE);
+}
+
+
+#else
+
 
 /*
  * Just use regular memory.
@@ -138,4 +166,4 @@ rtasm_exec_free(void *addr)
 }
 
 
-#endif /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#endif
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index b7569e7..146000a 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -1209,11 +1209,19 @@ fetch_src_file_channel(
 
       default:
          assert( 0 );
+         chan->u[0] = 0;
+         chan->u[1] = 0;
+         chan->u[2] = 0;
+         chan->u[3] = 0;
       }
       break;
 
    default:
       assert( 0 );
+      chan->u[0] = 0;
+      chan->u[1] = 0;
+      chan->u[2] = 0;
+      chan->u[3] = 0;
    }
 }
 
diff --git a/src/gallium/auxiliary/tgsi/tgsi_sse2.c b/src/gallium/auxiliary/tgsi/tgsi_sse2.c
index a96fc94..2c39def 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_sse2.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_sse2.c
@@ -2142,40 +2142,50 @@ emit_instruction(
       break;
 
    case TGSI_OPCODE_XPD:
+      /* Note: we do all stores after all operands have been fetched
+       * to avoid src/dst register aliasing issues for an instruction
+       * such as:  XPD TEMP[2].xyz, TEMP[0], TEMP[2];
+       */
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) ) {
-         FETCH( func, *inst, 1, 1, CHAN_Z );
-         FETCH( func, *inst, 3, 0, CHAN_Z );
+         FETCH( func, *inst, 1, 1, CHAN_Z ); /* xmm[1] = src[1].z */
+         FETCH( func, *inst, 3, 0, CHAN_Z ); /* xmm[3] = src[0].z */
       }
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) ) {
-         FETCH( func, *inst, 0, 0, CHAN_Y );
-         FETCH( func, *inst, 4, 1, CHAN_Y );
+         FETCH( func, *inst, 0, 0, CHAN_Y ); /* xmm[0] = src[0].y */
+         FETCH( func, *inst, 4, 1, CHAN_Y ); /* xmm[4] = src[1].y */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) {
-         emit_MOV( func, 2, 0 );
-         emit_mul( func, 2, 1 );
-         emit_MOV( func, 5, 3 );
-         emit_mul( func, 5, 4 );
-         emit_sub( func, 2, 5 );
-         STORE( func, *inst, 2, 0, CHAN_X );
+         emit_MOV( func, 7, 0 );  /* xmm[7] = xmm[0] */
+         emit_mul( func, 7, 1 );  /* xmm[7] = xmm[2] * xmm[1] */
+         emit_MOV( func, 5, 3 );  /* xmm[5] = xmm[3] */
+         emit_mul( func, 5, 4 );  /* xmm[5] = xmm[5] * xmm[4] */
+         emit_sub( func, 7, 5 );  /* xmm[7] = xmm[2] - xmm[5] */
+         /* store xmm[7] in dst.x below */
       }
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) ) {
-         FETCH( func, *inst, 2, 1, CHAN_X );
-         FETCH( func, *inst, 5, 0, CHAN_X );
+         FETCH( func, *inst, 2, 1, CHAN_X ); /* xmm[2] = src[1].x */
+         FETCH( func, *inst, 5, 0, CHAN_X ); /* xmm[5] = src[0].x */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) {
-         emit_mul( func, 3, 2 );
-         emit_mul( func, 1, 5 );
-         emit_sub( func, 3, 1 );
-         STORE( func, *inst, 3, 0, CHAN_Y );
+         emit_mul( func, 3, 2 );  /* xmm[3] = xmm[3] * xmm[2] */
+         emit_mul( func, 1, 5 );  /* xmm[1] = xmm[1] * xmm[5] */
+         emit_sub( func, 3, 1 );  /* xmm[3] = xmm[3] - xmm[1] */
+         /* store xmm[3] in dst.y below */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) {
-         emit_mul( func, 5, 4 );
-         emit_mul( func, 0, 2 );
-         emit_sub( func, 5, 0 );
-         STORE( func, *inst, 5, 0, CHAN_Z );
+         emit_mul( func, 5, 4 );  /* xmm[5] = xmm[5] * xmm[4] */
+         emit_mul( func, 0, 2 );  /* xmm[0] = xmm[0] * xmm[2] */
+         emit_sub( func, 5, 0 );  /* xmm[5] = xmm[5] - xmm[0] */
+         STORE( func, *inst, 5, 0, CHAN_Z ); /* dst.z = xmm[5] */
+      }
+      IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) {
+         STORE( func, *inst, 7, 0, CHAN_X ); /* dst.x = xmm[7] */
+      }
+      IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) {
+         STORE( func, *inst, 3, 0, CHAN_Y ); /* dst.y = xmm[3] */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_W ) {
 	 emit_tempf(
diff --git a/src/gallium/auxiliary/tgsi/tgsi_ureg.c b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
index 3f752e9..bf39cf5 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_ureg.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
@@ -780,8 +780,8 @@ ureg_insn(struct ureg_program *ureg,
    unsigned i;
    boolean saturate;
    boolean predicate;
-   boolean negate;
-   unsigned swizzle[4];
+   boolean negate = FALSE;
+   unsigned swizzle[4] = { 0 };
 
    saturate = nr_dst ? dst[0].Saturate : FALSE;
    predicate = nr_dst ? dst[0].Predicate : FALSE;
@@ -827,8 +827,8 @@ ureg_tex_insn(struct ureg_program *ureg,
    unsigned i;
    boolean saturate;
    boolean predicate;
-   boolean negate;
-   unsigned swizzle[4];
+   boolean negate = FALSE;
+   unsigned swizzle[4] = { 0 };
 
    saturate = nr_dst ? dst[0].Saturate : FALSE;
    predicate = nr_dst ? dst[0].Predicate : FALSE;
diff --git a/src/gallium/auxiliary/util/Makefile b/src/gallium/auxiliary/util/Makefile
index 1d8bb55..7e47ec6 100644
--- a/src/gallium/auxiliary/util/Makefile
+++ b/src/gallium/auxiliary/util/Makefile
@@ -9,6 +9,7 @@ C_SOURCES = \
 	u_debug_symbol.c \
 	u_debug_stack.c \
 	u_blit.c \
+	u_bitmask.c \
 	u_cache.c \
 	u_cpu_detect.c \
 	u_draw_quad.c \
diff --git a/src/gallium/auxiliary/util/u_bitmask.c b/src/gallium/auxiliary/util/u_bitmask.c
index 77587c0..23c93a3 100644
--- a/src/gallium/auxiliary/util/u_bitmask.c
+++ b/src/gallium/auxiliary/util/u_bitmask.c
@@ -97,12 +97,12 @@ util_bitmask_resize(struct util_bitmask *bm,
    if(!minimum_size)
       return FALSE;
       
-   if(bm->size > minimum_size)
+   if(bm->size >= minimum_size)
       return TRUE;
 
    assert(bm->size % UTIL_BITMASK_BITS_PER_WORD == 0);
    new_size = bm->size;
-   while(!(new_size > minimum_size)) {
+   while(new_size < minimum_size) {
       new_size *= 2;
       /* Check integer overflow */
       if(new_size < bm->size)
@@ -136,7 +136,7 @@ util_bitmask_filled_set(struct util_bitmask *bm,
                         unsigned index)
 {
    assert(bm->filled <= bm->size);
-   assert(index <= bm->size);
+   assert(index < bm->size);
    
    if(index == bm->filled) {
       ++bm->filled;
@@ -149,7 +149,7 @@ util_bitmask_filled_unset(struct util_bitmask *bm,
                           unsigned index)
 {
    assert(bm->filled <= bm->size);
-   assert(index <= bm->size);
+   assert(index < bm->size);
    
    if(index < bm->filled)
       bm->filled = index;
@@ -182,7 +182,7 @@ util_bitmask_add(struct util_bitmask *bm)
       mask = 1;
    }
 found:
-   
+
    /* grow the bitmask if necessary */
    if(!util_bitmask_resize(bm, bm->filled))
       return UTIL_BITMASK_INVALID_INDEX;
@@ -198,9 +198,9 @@ unsigned
 util_bitmask_set(struct util_bitmask *bm, 
                  unsigned index)
 {
-   unsigned word = index / UTIL_BITMASK_BITS_PER_WORD;
-   unsigned bit  = index % UTIL_BITMASK_BITS_PER_WORD;
-   util_bitmask_word mask = 1 << bit;
+   unsigned word;
+   unsigned bit;
+   util_bitmask_word mask;
    
    assert(bm);
    
@@ -208,6 +208,10 @@ util_bitmask_set(struct util_bitmask *bm,
    if(!util_bitmask_resize(bm, index))
       return UTIL_BITMASK_INVALID_INDEX;
 
+   word = index / UTIL_BITMASK_BITS_PER_WORD;
+   bit  = index % UTIL_BITMASK_BITS_PER_WORD;
+   mask = 1 << bit;
+
    bm->words[word] |= mask;
 
    util_bitmask_filled_set(bm, index);
@@ -220,15 +224,19 @@ void
 util_bitmask_clear(struct util_bitmask *bm, 
                    unsigned index)
 {
-   unsigned word = index / UTIL_BITMASK_BITS_PER_WORD;
-   unsigned bit  = index % UTIL_BITMASK_BITS_PER_WORD;
-   util_bitmask_word mask = 1 << bit;
+   unsigned word;
+   unsigned bit;
+   util_bitmask_word mask;
    
    assert(bm);
    
    if(index >= bm->size)
       return;
 
+   word = index / UTIL_BITMASK_BITS_PER_WORD;
+   bit  = index % UTIL_BITMASK_BITS_PER_WORD;
+   mask = 1 << bit;
+
    bm->words[word] &= ~mask;
    
    util_bitmask_filled_unset(bm, index);
@@ -250,7 +258,7 @@ util_bitmask_get(struct util_bitmask *bm,
       return TRUE;
    }
 
-   if(index > bm->size)
+   if(index >= bm->size)
       return FALSE;
 
    if(bm->words[word] & mask) {
diff --git a/src/gallium/auxiliary/util/u_clear.h b/src/gallium/auxiliary/util/u_clear.h
index 1e65a03..6be5ca2 100644
--- a/src/gallium/auxiliary/util/u_clear.h
+++ b/src/gallium/auxiliary/util/u_clear.h
@@ -46,7 +46,7 @@ util_clear(struct pipe_context *pipe,
 {
    if (buffers & PIPE_CLEAR_COLOR) {
       struct pipe_surface *ps = framebuffer->cbufs[0];
-      unsigned color;
+      unsigned color = 0;
 
       util_pack_color(rgba, ps->format, &color);
       if (pipe->surface_fill) {
diff --git a/src/gallium/auxiliary/util/u_debug.c b/src/gallium/auxiliary/util/u_debug.c
index 96d400c..be5eb87 100644
--- a/src/gallium/auxiliary/util/u_debug.c
+++ b/src/gallium/auxiliary/util/u_debug.c
@@ -452,7 +452,8 @@ debug_dump_flags(const struct debug_named_value *names,
 	    util_strncat(output, "|", sizeof(output));
 	 else
 	    first = 0;
-	 util_strncat(output, names->name, sizeof(output));
+	 util_strncat(output, names->name, sizeof(output) - 1);
+	 output[sizeof(output) - 1] = '\0';
 	 value &= ~names->value;
       }
       ++names;
@@ -465,7 +466,8 @@ debug_dump_flags(const struct debug_named_value *names,
 	 first = 0;
       
       util_snprintf(rest, sizeof(rest), "0x%08lx", value);
-      util_strncat(output, rest, sizeof(output));
+      util_strncat(output, rest, sizeof(output) - 1);
+      output[sizeof(output) - 1] = '\0';
    }
    
    if(first)
diff --git a/src/gallium/auxiliary/util/u_debug.h b/src/gallium/auxiliary/util/u_debug.h
index abd834c..facc30a 100644
--- a/src/gallium/auxiliary/util/u_debug.h
+++ b/src/gallium/auxiliary/util/u_debug.h
@@ -188,7 +188,7 @@ void _debug_assert_fail(const char *expr,
 #ifdef DEBUG
 #define debug_assert(expr) ((expr) ? (void)0 : _debug_assert_fail(#expr, __FILE__, __LINE__, __FUNCTION__))
 #else
-#define debug_assert(expr) ((void)0)
+#define debug_assert(expr) do { } while (0 && (expr))
 #endif
 
 
diff --git a/src/gallium/auxiliary/util/u_debug_memory.c b/src/gallium/auxiliary/util/u_debug_memory.c
index 7623cb9..d6484f4 100644
--- a/src/gallium/auxiliary/util/u_debug_memory.c
+++ b/src/gallium/auxiliary/util/u_debug_memory.c
@@ -297,9 +297,9 @@ debug_memory_end(unsigned long start_no)
 
       if((start_no <= hdr->no && hdr->no < last_no) ||
 	 (last_no < start_no && (hdr->no < last_no || start_no <= hdr->no))) {
-	 debug_printf("%s:%u:%s: %u bytes at %p not freed\n",
+	 debug_printf("%s:%u:%s: %lu bytes at %p not freed\n",
 		      hdr->file, hdr->line, hdr->function,
-		      hdr->size, ptr);
+		      (unsigned long) hdr->size, ptr);
 #if DEBUG_MEMORY_STACK
 	 debug_backtrace_dump(hdr->backtrace, DEBUG_MEMORY_STACK);
 #endif
@@ -315,8 +315,8 @@ debug_memory_end(unsigned long start_no)
    }
 
    if(total_size) {
-      debug_printf("Total of %u KB of system memory apparently leaked\n",
-		   (total_size + 1023)/1024);
+      debug_printf("Total of %lu KB of system memory apparently leaked\n",
+		   (unsigned long) (total_size + 1023)/1024);
    }
    else {
       debug_printf("No memory leaks detected.\n");
diff --git a/src/gallium/auxiliary/util/u_format.h b/src/gallium/auxiliary/util/u_format.h
index 7b5b7fc..bd27f34 100644
--- a/src/gallium/auxiliary/util/u_format.h
+++ b/src/gallium/auxiliary/util/u_format.h
@@ -79,7 +79,7 @@ enum util_format_colorspace {
    UTIL_FORMAT_COLORSPACE_RGB = 0,
    UTIL_FORMAT_COLORSPACE_SRGB = 1,
    UTIL_FORMAT_COLORSPACE_YUV = 2,
-   UTIL_FORMAT_COLORSPACE_ZS = 3,
+   UTIL_FORMAT_COLORSPACE_ZS = 3
 };
 
 
diff --git a/src/gallium/auxiliary/util/u_network.c b/src/gallium/auxiliary/util/u_network.c
index 6269c72..87ee0e4 100644
--- a/src/gallium/auxiliary/util/u_network.c
+++ b/src/gallium/auxiliary/util/u_network.c
@@ -6,7 +6,7 @@
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  include <winsock2.h>
 #  include <windows.h>
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 #  include <sys/socket.h>
 #  include <netinet/in.h>
 #  include <unistd.h>
@@ -54,7 +54,7 @@ u_socket_close(int s)
    if (s < 0)
       return;
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
    shutdown(s, SHUT_RDWR);
    close(s);
 #elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
@@ -117,7 +117,7 @@ u_socket_connect(const char *hostname, uint16_t port)
    if (!host)
       return -1;
 
-   memcpy((char *)&sa.sin_addr,host->h_addr,host->h_length);
+   memcpy((char *)&sa.sin_addr,host->h_addr_list[0],host->h_length);
    sa.sin_family= host->h_addrtype;
    sa.sin_port = htons(port);
 
@@ -169,7 +169,7 @@ u_socket_listen_on_port(uint16_t portnum)
 void
 u_socket_block(int s, boolean block)
 {
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
    int old = fcntl(s, F_GETFL, 0);
    if (old == -1)
       return;
diff --git a/src/gallium/auxiliary/util/u_network.h b/src/gallium/auxiliary/util/u_network.h
index 0aa898b..187dcab 100644
--- a/src/gallium/auxiliary/util/u_network.h
+++ b/src/gallium/auxiliary/util/u_network.h
@@ -6,7 +6,7 @@
 
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  define PIPE_HAVE_SOCKETS
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 #  define PIPE_HAVE_SOCKETS
 #endif
 
diff --git a/src/gallium/auxiliary/util/u_stream_stdc.c b/src/gallium/auxiliary/util/u_stream_stdc.c
index 5cd05b2..4d976d6 100644
--- a/src/gallium/auxiliary/util/u_stream_stdc.c
+++ b/src/gallium/auxiliary/util/u_stream_stdc.c
@@ -32,7 +32,7 @@
 
 #include "pipe/p_config.h"
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_SUBSYSTEM_WINDOWS_USER) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_SUBSYSTEM_WINDOWS_USER) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 
 #include <stdio.h>
 
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c b/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
index c4ba698..bbe0d5f 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
@@ -336,11 +336,13 @@ create_frame_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
@@ -445,11 +447,13 @@ create_frame_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
@@ -536,11 +540,13 @@ create_frame_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
@@ -663,11 +669,13 @@ create_frame_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 xfer_buffers_map(struct vl_mpeg12_mc_renderer *r)
@@ -1087,6 +1095,9 @@ gen_macroblock_verts(struct vl_mpeg12_mc_renderer *r,
    assert(ycbcr_vb);
    assert(pos < r->macroblocks_per_batch);
 
+   mo_vec[1].x = 0;
+   mo_vec[1].y = 0;
+
    switch (mb->mb_type) {
       case PIPE_MPEG12_MACROBLOCK_TYPE_BI:
       {
diff --git a/src/gallium/drivers/i915/i915_buffer.c b/src/gallium/drivers/i915/i915_buffer.c
index effeba1..6699647 100644
--- a/src/gallium/drivers/i915/i915_buffer.c
+++ b/src/gallium/drivers/i915/i915_buffer.c
@@ -111,6 +111,7 @@ i915_buffer_unmap(struct pipe_screen *screen,
 {
    struct i915_buffer *buf = i915_buffer(buffer);
    assert(!buf->ibuf);
+   (void) buf;
 }
 
 static void
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 71f00bc..a04668d 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -58,10 +58,10 @@ translate_wrap_mode(unsigned wrap)
       return TEXCOORDMODE_CLAMP_EDGE;
    case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
       return TEXCOORDMODE_CLAMP_BORDER;
-/*
+   /*         
    case PIPE_TEX_WRAP_MIRRORED_REPEAT:
       return TEXCOORDMODE_MIRROR;
-*/
+    */
    default:
       return TEXCOORDMODE_WRAP;
    }
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c b/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
index d14f468..ced7b9c 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
@@ -142,7 +142,7 @@ lp_build_blend_factor_unswizzled(struct lp_build_blend_aos_context *bld,
 
 enum lp_build_blend_swizzle {
    LP_BUILD_BLEND_SWIZZLE_RGBA = 0,
-   LP_BUILD_BLEND_SWIZZLE_AAAA = 1,
+   LP_BUILD_BLEND_SWIZZLE_AAAA = 1
 };
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_depth.c b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
index 98ec1cb..d438c0e 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_depth.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
@@ -90,7 +90,7 @@ lp_depth_type(const struct util_format_description *format_desc,
 
    if(format_desc->channel[swizzle].type == UTIL_FORMAT_TYPE_FLOAT) {
       type.floating = TRUE;
-      assert(swizzle = 0);
+      assert(swizzle == 0);
       assert(format_desc->channel[swizzle].size == format_desc->block.bits);
    }
    else if(format_desc->channel[swizzle].type == UTIL_FORMAT_TYPE_UNSIGNED) {
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_flow.c b/src/gallium/drivers/llvmpipe/lp_bld_flow.c
index dcc25fb..25c10af 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_flow.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_flow.c
@@ -47,7 +47,7 @@
  */
 enum lp_build_flow_construct_kind {
    lP_BUILD_FLOW_SCOPE,
-   LP_BUILD_FLOW_SKIP,
+   LP_BUILD_FLOW_SKIP
 };
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c b/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
index 5836e01..10e82f1 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
@@ -130,7 +130,7 @@ lp_build_unpack_rgba_aos(LLVMBuilderRef builder,
 
    shifted = LLVMBuildLShr(builder, packed, LLVMConstVector(shifts, 4), "");
    masked = LLVMBuildAnd(builder, shifted, LLVMConstVector(masks, 4), "");
-   // UIToFP can't be expressed in SSE2
+   /* UIToFP can't be expressed in SSE2 */
    casted = LLVMBuildSIToFP(builder, masked, LLVMVectorType(LLVMFloatType(), 4), "");
 
    if (normalized)
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c b/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
index 94ce4ae..0dea2cd 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
@@ -321,7 +321,7 @@ emit_tex( struct lp_build_tgsi_soa_context *bld,
 {
    const uint unit = inst->FullSrcRegisters[1].SrcRegister.Index;
    LLVMValueRef lodbias;
-   LLVMValueRef oow;
+   LLVMValueRef oow = NULL;
    LLVMValueRef coords[3];
    unsigned num_coords;
    unsigned i;
@@ -446,7 +446,12 @@ emit_instruction(
 {
    unsigned chan_index;
    LLVMValueRef src0, src1, src2;
-   LLVMValueRef tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+   LLVMValueRef tmp0, tmp1, tmp2;
+   LLVMValueRef tmp3 = NULL;
+   LLVMValueRef tmp4 = NULL;
+   LLVMValueRef tmp5 = NULL;
+   LLVMValueRef tmp6 = NULL;
+   LLVMValueRef tmp7 = NULL;
    LLVMValueRef res;
    LLVMValueRef dst0[NUM_CHANNELS];
 
diff --git a/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c b/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
index 4abff4e..e8e2e25 100644
--- a/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
+++ b/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
@@ -128,6 +128,7 @@ lp_vbuf_unmap_vertices(struct vbuf_render *vbr,
 {
    struct llvmpipe_vbuf_render *cvbr = llvmpipe_vbuf_render(vbr);
    assert( cvbr->vertex_buffer_size >= (max_index+1) * cvbr->vertex_size );
+   (void) cvbr;
    /* do nothing */
 }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 2e9aa9f..8e2aae4 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -676,6 +676,7 @@ llvmpipe_delete_fs_state(struct pipe_context *pipe, void *fs)
    struct lp_fragment_shader_variant *variant;
 
    assert(fs != llvmpipe->fs);
+   (void) llvmpipe;
 
    variant = shader->variants;
    while(variant) {
diff --git a/src/gallium/drivers/llvmpipe/lp_test_conv.c b/src/gallium/drivers/llvmpipe/lp_test_conv.c
index 968c7a2..faddfb9 100644
--- a/src/gallium/drivers/llvmpipe/lp_test_conv.c
+++ b/src/gallium/drivers/llvmpipe/lp_test_conv.c
@@ -330,7 +330,7 @@ test_one(unsigned verbose,
          fprintf(stderr, "conv.bc written\n");
          fprintf(stderr, "Invoke as \"llc -o - conv.bc\"\n");
          firsttime = FALSE;
-         //abort();
+         /* abort(); */
       }
    }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_cache.h b/src/gallium/drivers/llvmpipe/lp_tex_cache.h
index 9fa6c36..05fded7 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_cache.h
+++ b/src/gallium/drivers/llvmpipe/lp_tex_cache.h
@@ -115,7 +115,7 @@ extern const struct llvmpipe_cached_tex_tile *
 lp_find_cached_tex_tile(struct llvmpipe_tex_tile_cache *tc,
                         union tex_tile_address addr );
 
-static INLINE const union tex_tile_address
+static INLINE union tex_tile_address
 tex_tile_address( unsigned x,
                   unsigned y,
                   unsigned z,
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c b/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
index a1365a0..699394c 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
+++ b/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
@@ -1085,7 +1085,7 @@ lp_get_samples_2d_common(struct tgsi_sampler *tgsi_sampler,
    const struct pipe_sampler_state *sampler = samp->sampler;
    unsigned level0, level1, j, imgFilter;
    int width, height;
-   float levelBlend;
+   float levelBlend = 0.0F;
 
    choose_mipmap_levels(tgsi_sampler, s, t, p, 
                         lodbias,
diff --git a/src/gallium/drivers/llvmpipe/lp_tile_soa.h b/src/gallium/drivers/llvmpipe/lp_tile_soa.h
index 040b018..19d00b5 100644
--- a/src/gallium/drivers/llvmpipe/lp_tile_soa.h
+++ b/src/gallium/drivers/llvmpipe/lp_tile_soa.h
@@ -29,7 +29,7 @@
 #define LP_TILE_SOA_H
 
 #include "pipe/p_compiler.h"
-#include "tgsi/tgsi_exec.h" // for NUM_CHANNELS
+#include "tgsi/tgsi_exec.h" /* for NUM_CHANNELS */
 
 
 #ifdef __cplusplus
diff --git a/src/gallium/drivers/llvmpipe/lp_winsys.h b/src/gallium/drivers/llvmpipe/lp_winsys.h
index 595481c..74b472b 100644
--- a/src/gallium/drivers/llvmpipe/lp_winsys.h
+++ b/src/gallium/drivers/llvmpipe/lp_winsys.h
@@ -35,7 +35,7 @@
 #define LP_WINSYS_H
 
 
-#include "pipe/p_compiler.h" // for boolean
+#include "pipe/p_compiler.h" /* for boolean */
 #include "pipe/p_format.h"
 
 
diff --git a/src/gallium/drivers/nv50/nv50_query.c b/src/gallium/drivers/nv50/nv50_query.c
index 5305c93..f605c47 100644
--- a/src/gallium/drivers/nv50/nv50_query.c
+++ b/src/gallium/drivers/nv50/nv50_query.c
@@ -111,7 +111,7 @@ nv50_query_result(struct pipe_context *pipe, struct pipe_query *pq,
 
 	if (!q->ready) {
 		ret = nouveau_bo_map(q->bo, NOUVEAU_BO_RD |
-				     wait ? 0 : NOUVEAU_BO_NOWAIT);
+				     (wait ? 0 : NOUVEAU_BO_NOWAIT));
 		if (ret)
 			return false;
 		q->result = ((uint32_t *)q->bo->map)[1];
diff --git a/src/gallium/drivers/r300/r300_cs.h b/src/gallium/drivers/r300/r300_cs.h
index 86ba91d..5342488 100644
--- a/src/gallium/drivers/r300/r300_cs.h
+++ b/src/gallium/drivers/r300/r300_cs.h
@@ -51,7 +51,7 @@
 #define CS_LOCALS(context) \
     struct r300_context* const cs_context_copy = (context); \
     struct r300_winsys* cs_winsys = cs_context_copy->winsys; \
-    int cs_count = 0;
+    int cs_count = 0
 
 #define CHECK_CS(size) \
     cs_winsys->check_cs(cs_winsys, (size))
diff --git a/src/gallium/drivers/r300/r300_emit.c b/src/gallium/drivers/r300/r300_emit.c
index eeb97a2..b44c7bd 100644
--- a/src/gallium/drivers/r300/r300_emit.c
+++ b/src/gallium/drivers/r300/r300_emit.c
@@ -871,7 +871,7 @@ validate:
             goto validate;
         }
     } else {
-        // debug_printf("No VBO while emitting dirty state!\n");
+        /* debug_printf("No VBO while emitting dirty state!\n"); */
     }
     if (!r300->winsys->validate(r300->winsys)) {
         r300->context.flush(&r300->context, 0, NULL);
@@ -999,7 +999,7 @@ validate:
     */
 
     /* Finally, emit the VBO. */
-    //r300_emit_vertex_buffer(r300);
+    /* r300_emit_vertex_buffer(r300); */
 
     r300->dirty_hw++;
 }
diff --git a/src/gallium/drivers/r300/r300_flush.c b/src/gallium/drivers/r300/r300_flush.c
index 14a0824..4282357 100644
--- a/src/gallium/drivers/r300/r300_flush.c
+++ b/src/gallium/drivers/r300/r300_flush.c
@@ -39,6 +39,7 @@ static void r300_flush(struct pipe_context* pipe,
     struct r300_query *query;
 
     CS_LOCALS(r300);
+    (void) cs_count;
     /* We probably need to flush Draw, but we may have been called from
      * within Draw. This feels kludgy, but it might be the best thing.
      *
diff --git a/src/gallium/drivers/r300/r300_reg.h b/src/gallium/drivers/r300/r300_reg.h
index 8ca785c..744ea65 100644
--- a/src/gallium/drivers/r300/r300_reg.h
+++ b/src/gallium/drivers/r300/r300_reg.h
@@ -2636,7 +2636,7 @@ enum {
 	VE_COND_MUX_GTE			= 25,
 	VE_SET_GREATER_THAN		= 26,
 	VE_SET_EQUAL			= 27,
-	VE_SET_NOT_EQUAL		= 28,
+	VE_SET_NOT_EQUAL		= 28
 };
 
 enum {
@@ -2670,20 +2670,20 @@ enum {
 	ME_PRED_SET_CLR			= 25,
 	ME_PRED_SET_INV			= 26,
 	ME_PRED_SET_POP			= 27,
-	ME_PRED_SET_RESTORE		= 28,
+	ME_PRED_SET_RESTORE		= 28
 };
 
 enum {
 	/* R3XX */
 	PVS_MACRO_OP_2CLK_MADD		= 0,
-	PVS_MACRO_OP_2CLK_M2X_ADD	= 1,
+	PVS_MACRO_OP_2CLK_M2X_ADD	= 1
 };
 
 enum {
 	PVS_SRC_REG_TEMPORARY		= 0,	/* Intermediate Storage */
 	PVS_SRC_REG_INPUT		= 1,	/* Input Vertex Storage */
 	PVS_SRC_REG_CONSTANT		= 2,	/* Constant State Storage */
-	PVS_SRC_REG_ALT_TEMPORARY	= 3,	/* Alternate Intermediate Storage */
+	PVS_SRC_REG_ALT_TEMPORARY	= 3	/* Alternate Intermediate Storage */
 };
 
 enum {
@@ -2692,7 +2692,7 @@ enum {
 	PVS_DST_REG_OUT			= 2,	/* Output Memory. Used for all outputs */
 	PVS_DST_REG_OUT_REPL_X		= 3,	/* Output Memory & Replicate X to all channels */
 	PVS_DST_REG_ALT_TEMPORARY	= 4,	/* Alternate Intermediate Storage */
-	PVS_DST_REG_INPUT		= 5,	/* Output Memory & Replicate X to all channels */
+	PVS_DST_REG_INPUT		= 5	/* Output Memory & Replicate X to all channels */
 };
 
 enum {
@@ -2701,7 +2701,7 @@ enum {
 	PVS_SRC_SELECT_Z		= 2,	/* Select Z Component */
 	PVS_SRC_SELECT_W		= 3,	/* Select W Component */
 	PVS_SRC_SELECT_FORCE_0		= 4,	/* Force Component to 0.0 */
-	PVS_SRC_SELECT_FORCE_1		= 5,	/* Force Component to 1.0 */
+	PVS_SRC_SELECT_FORCE_1		= 5	/* Force Component to 1.0 */
 };
 
 /* PVS Opcode & Destination Operand Description */
@@ -2740,7 +2740,7 @@ enum {
 	PVS_DST_ADDR_SEL_MASK		= 0x3,
 	PVS_DST_ADDR_SEL_SHIFT		= 29,
 	PVS_DST_ADDR_MODE_0_MASK	= 0x1,
-	PVS_DST_ADDR_MODE_0_SHIFT	= 31,
+	PVS_DST_ADDR_MODE_0_SHIFT	= 31
 };
 
 /* PVS Source Operand Description */
@@ -2775,7 +2775,7 @@ enum {
 	PVS_SRC_ADDR_SEL_MASK		= 0x3,
 	PVS_SRC_ADDR_SEL_SHIFT		= 29,
 	PVS_SRC_ADDR_MODE_1_MASK	= 0x0,
-	PVS_SRC_ADDR_MODE_1_SHIFT	= 32,
+	PVS_SRC_ADDR_MODE_1_SHIFT	= 32
 };
 
 /*\}*/
diff --git a/src/gallium/drivers/r300/r300_state_derived.c b/src/gallium/drivers/r300/r300_state_derived.c
index 7166694..55430a9 100644
--- a/src/gallium/drivers/r300/r300_state_derived.c
+++ b/src/gallium/drivers/r300/r300_state_derived.c
@@ -464,7 +464,7 @@ static void r300_update_rs_block(struct r300_context* r300,
 /* Update the vertex format. */
 static void r300_update_derived_shader_state(struct r300_context* r300)
 {
-    struct r300_screen* r300screen = r300_screen(r300->context.screen);
+    /* struct r300_screen* r300screen = r300_screen(r300->context.screen); */
     struct r300_vertex_info* vformat;
     struct r300_rs_block* rs_block;
     int i;
diff --git a/src/gallium/drivers/softpipe/sp_prim_vbuf.c b/src/gallium/drivers/softpipe/sp_prim_vbuf.c
index 5fbac06..7f573ae 100644
--- a/src/gallium/drivers/softpipe/sp_prim_vbuf.c
+++ b/src/gallium/drivers/softpipe/sp_prim_vbuf.c
@@ -128,6 +128,7 @@ sp_vbuf_unmap_vertices(struct vbuf_render *vbr,
 {
    struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
    assert( cvbr->vertex_buffer_size >= (max_index+1) * cvbr->vertex_size );
+   (void) cvbr;
    /* do nothing */
 }
 
diff --git a/src/gallium/drivers/softpipe/sp_quad_blend.c b/src/gallium/drivers/softpipe/sp_quad_blend.c
index fe6b6ce..d9babe8 100644
--- a/src/gallium/drivers/softpipe/sp_quad_blend.c
+++ b/src/gallium/drivers/softpipe/sp_quad_blend.c
@@ -229,7 +229,7 @@ blend_quad(struct quad_stage *qs,
    static const float zero[4] = { 0, 0, 0, 0 };
    static const float one[4] = { 1, 1, 1, 1 };
    struct softpipe_context *softpipe = qs->softpipe;
-   float source[4][QUAD_SIZE];
+   float source[4][QUAD_SIZE] = { { 0 } };
 
    /*
     * Compute src/first term RGB
diff --git a/src/gallium/drivers/svga/svga_context.c b/src/gallium/drivers/svga/svga_context.c
index c3de12b..af99c9d 100644
--- a/src/gallium/drivers/svga/svga_context.c
+++ b/src/gallium/drivers/svga/svga_context.c
@@ -29,6 +29,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_screen.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "util/u_upload_mgr.h"
 
 #include "svga_context.h"
@@ -61,6 +62,9 @@ static void svga_destroy( struct pipe_context *pipe )
    u_upload_destroy( svga->upload_vb );
    u_upload_destroy( svga->upload_ib );
 
+   util_bitmask_destroy( svga->vs_bm );
+   util_bitmask_destroy( svga->fs_bm );
+
    for(shader = 0; shader < PIPE_SHADER_TYPES; ++shader)
       pipe_buffer_reference( &svga->curr.cb[shader], NULL );
 
@@ -130,7 +134,7 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    svga = CALLOC_STRUCT(svga_context);
    if (svga == NULL)
-      goto error1;
+      goto no_svga;
 
    svga->pipe.winsys = screen->winsys;
    svga->pipe.screen = screen;
@@ -142,7 +146,7 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    svga->swc = svgascreen->sws->context_create(svgascreen->sws);
    if(!svga->swc)
-      goto error2;
+      goto no_swc;
 
    svga_init_blend_functions(svga);
    svga_init_blit_functions(svga);
@@ -165,32 +169,40 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
    svga->debug.disable_shader = debug_get_num_option("SVGA_DISABLE_SHADER", ~0);
 
    if (!svga_init_swtnl(svga))
-      goto error3;
+      goto no_swtnl;
+
+   svga->fs_bm = util_bitmask_create();
+   if (svga->fs_bm == NULL)
+      goto no_fs_bm;
+
+   svga->vs_bm = util_bitmask_create();
+   if (svga->vs_bm == NULL)
+      goto no_vs_bm;
 
    svga->upload_ib = u_upload_create( svga->pipe.screen,
                                       32 * 1024,
                                       16,
                                       PIPE_BUFFER_USAGE_INDEX );
    if (svga->upload_ib == NULL)
-      goto error4;
+      goto no_upload_ib;
 
    svga->upload_vb = u_upload_create( svga->pipe.screen,
                                       128 * 1024,
                                       16,
                                       PIPE_BUFFER_USAGE_VERTEX );
    if (svga->upload_vb == NULL)
-      goto error5;
+      goto no_upload_vb;
 
    svga->hwtnl = svga_hwtnl_create( svga,
                                     svga->upload_ib,
                                     svga->swc );
    if (svga->hwtnl == NULL)
-      goto error6;
+      goto no_hwtnl;
 
 
    ret = svga_emit_initial_state( svga );
    if (ret)
-      goto error7;
+      goto no_state;
    
    /* Avoid shortcircuiting state with initial value of zero.
     */
@@ -209,19 +221,23 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    return &svga->pipe;
 
-error7:
+no_state:
    svga_hwtnl_destroy( svga->hwtnl );
-error6:
+no_hwtnl:
    u_upload_destroy( svga->upload_vb );
-error5:
+no_upload_vb:
    u_upload_destroy( svga->upload_ib );
-error4:
+no_upload_ib:
+   util_bitmask_destroy( svga->vs_bm );
+no_vs_bm:
+   util_bitmask_destroy( svga->fs_bm );
+no_fs_bm:
    svga_destroy_swtnl(svga);
-error3:
+no_swtnl:
    svga->swc->destroy(svga->swc);
-error2:
+no_swc:
    FREE(svga);
-error1:
+no_svga:
    return NULL;
 }
 
diff --git a/src/gallium/drivers/svga/svga_context.h b/src/gallium/drivers/svga/svga_context.h
index e650a25..32e9304 100644
--- a/src/gallium/drivers/svga/svga_context.h
+++ b/src/gallium/drivers/svga/svga_context.h
@@ -41,6 +41,7 @@
 struct draw_vertex_shader;
 struct svga_shader_result;
 struct SVGACmdMemory;
+struct util_bitmask;
 struct u_upload_mgr;
 
 
@@ -267,8 +268,6 @@ struct svga_hw_draw_state
    unsigned ts[16][TS_MAX];
    float cb[PIPE_SHADER_TYPES][CB_MAX][4];
 
-   unsigned shader_id[PIPE_SHADER_TYPES];
-   
    struct svga_shader_result *fs;
    struct svga_shader_result *vs;
    struct svga_hw_view_state views[PIPE_MAX_SAMPLERS];
@@ -321,12 +320,14 @@ struct svga_context
       boolean new_vdecl;
    } swtnl;
 
+   /* Bitmask of used shader IDs */
+   struct util_bitmask *fs_bm;
+   struct util_bitmask *vs_bm;
+
    struct {
       unsigned dirty[4];
 
       unsigned texture_timestamp;
-      unsigned next_fs_id;
-      unsigned next_vs_id;
 
       /* Internally generated shaders:
        */
diff --git a/src/gallium/drivers/svga/svga_draw.c b/src/gallium/drivers/svga/svga_draw.c
index 8db40d0..ca73cf9 100644
--- a/src/gallium/drivers/svga/svga_draw.c
+++ b/src/gallium/drivers/svga/svga_draw.c
@@ -164,7 +164,8 @@ svga_hwtnl_flush( struct svga_hwtnl *hwtnl )
       }
 
       SVGA_DBG(DEBUG_DMA, "draw to sid %p, %d prims\n",
-               svga_surface(svga->curr.framebuffer.cbufs[0])->handle,
+               svga->curr.framebuffer.cbufs[0] ?
+               svga_surface(svga->curr.framebuffer.cbufs[0])->handle : NULL,
                hwtnl->cmd.prim_count);
 
       ret = SVGA3D_BeginDrawPrimitives(swc, 
diff --git a/src/gallium/drivers/svga/svga_pipe_fs.c b/src/gallium/drivers/svga/svga_pipe_fs.c
index e3be840..5f1213e 100644
--- a/src/gallium/drivers/svga/svga_pipe_fs.c
+++ b/src/gallium/drivers/svga/svga_pipe_fs.c
@@ -26,6 +26,7 @@
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "tgsi/tgsi_parse.h"
 #include "tgsi/tgsi_text.h"
 
@@ -107,7 +108,16 @@ void svga_delete_fs_state(struct pipe_context *pipe, void *shader)
          assert(ret == PIPE_OK);
       }
 
+      util_bitmask_clear( svga->fs_bm, result->id );
+
       svga_destroy_shader_result( result );
+
+      /*
+       * Remove stale references to this result to ensure a new result on the
+       * same address will be detected as a change.
+       */
+      if(result == svga->state.hw_draw.fs)
+         svga->state.hw_draw.fs = NULL;
    }
 
    FREE((void *)fs->base.tokens);
diff --git a/src/gallium/drivers/svga/svga_pipe_vs.c b/src/gallium/drivers/svga/svga_pipe_vs.c
index e5ffe66..fd9864c 100644
--- a/src/gallium/drivers/svga/svga_pipe_vs.c
+++ b/src/gallium/drivers/svga/svga_pipe_vs.c
@@ -27,6 +27,7 @@
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "tgsi/tgsi_parse.h"
 #include "tgsi/tgsi_text.h"
 
@@ -172,7 +173,16 @@ static void svga_delete_vs_state(struct pipe_context *pipe, void *shader)
          assert(ret == PIPE_OK);
       }
 
+      util_bitmask_clear( svga->vs_bm, result->id );
+
       svga_destroy_shader_result( result );
+
+      /*
+       * Remove stale references to this result to ensure a new result on the
+       * same address will be detected as a change.
+       */
+      if(result == svga->state.hw_draw.vs)
+         svga->state.hw_draw.vs = NULL;
    }
 
    FREE((void *)vs->base.tokens);
diff --git a/src/gallium/drivers/svga/svga_state_fs.c b/src/gallium/drivers/svga/svga_state_fs.c
index 6ec38ed..44bb58c 100644
--- a/src/gallium/drivers/svga/svga_state_fs.c
+++ b/src/gallium/drivers/svga/svga_state_fs.c
@@ -26,6 +26,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_defines.h"
 #include "util/u_math.h"
+#include "util/u_bitmask.h"
 
 #include "svga_context.h"
 #include "svga_state.h"
@@ -66,7 +67,7 @@ static enum pipe_error compile_fs( struct svga_context *svga,
                                    struct svga_shader_result **out_result )
 {
    struct svga_shader_result *result;
-   enum pipe_error ret;
+   enum pipe_error ret = PIPE_ERROR;
 
    result = svga_translate_fragment_program( fs, key );
    if (result == NULL) {
@@ -74,9 +75,12 @@ static enum pipe_error compile_fs( struct svga_context *svga,
       goto fail;
    }
 
+   result->id = util_bitmask_add(svga->fs_bm);
+   if(result->id == UTIL_BITMASK_INVALID_INDEX)
+      goto fail;
 
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_fs_id,
+                             result->id,
                              SVGA3D_SHADERTYPE_PS,
                              result->tokens, 
                              result->nr_tokens * sizeof result->tokens[0]);
@@ -84,14 +88,16 @@ static enum pipe_error compile_fs( struct svga_context *svga,
       goto fail;
 
    *out_result = result;
-   result->id = svga->state.next_fs_id++;
    result->next = fs->base.results;
    fs->base.results = result;
    return PIPE_OK;
 
 fail:
-   if (result)
+   if (result) {
+      if (result->id != UTIL_BITMASK_INVALID_INDEX)
+         util_bitmask_clear( svga->fs_bm, result->id );
       svga_destroy_shader_result( result );
+   }
    return ret;
 }
 
@@ -116,7 +122,7 @@ fail:
  */
 static int emit_white_fs( struct svga_context *svga )
 {
-   int ret;
+   int ret = PIPE_ERROR;
 
    /* ps_3_0
     * def c0, 1.000000, 0.000000, 0.000000, 1.000000
@@ -137,16 +143,26 @@ static int emit_white_fs( struct svga_context *svga )
       0x0000ffff,
    };
 
+   assert(SVGA3D_INVALID_ID == UTIL_BITMASK_INVALID_INDEX);
+   svga->state.white_fs_id = util_bitmask_add(svga->fs_bm);
+   if(svga->state.white_fs_id == SVGA3D_INVALID_ID)
+      goto no_fs_id;
+
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_fs_id,
+                             svga->state.white_fs_id,
                              SVGA3D_SHADERTYPE_PS,
                              white_tokens, 
                              sizeof(white_tokens));
    if (ret)
-      return ret;
+      goto no_definition;
 
-   svga->state.white_fs_id = svga->state.next_fs_id++;
    return 0;
+
+no_definition:
+   util_bitmask_clear(svga->fs_bm, svga->state.white_fs_id);
+   svga->state.white_fs_id = SVGA3D_INVALID_ID;
+no_fs_id:
+   return ret;
 }
 
 
@@ -251,15 +267,14 @@ static int emit_hw_fs( struct svga_context *svga,
 
    assert(id != SVGA3D_INVALID_ID);
 
-   if (id != svga->state.hw_draw.shader_id[PIPE_SHADER_FRAGMENT]) {
-      ret = SVGA3D_SetShader(svga->swc, 
-                             SVGA3D_SHADERTYPE_PS, 
+   if (result != svga->state.hw_draw.fs) {
+      ret = SVGA3D_SetShader(svga->swc,
+                             SVGA3D_SHADERTYPE_PS,
                              id );
       if (ret)
          return ret;
 
       svga->dirty |= SVGA_NEW_FS_RESULT;
-      svga->state.hw_draw.shader_id[PIPE_SHADER_FRAGMENT] = id;
       svga->state.hw_draw.fs = result;      
    }
 
diff --git a/src/gallium/drivers/svga/svga_state_vs.c b/src/gallium/drivers/svga/svga_state_vs.c
index a947745..db30f27 100644
--- a/src/gallium/drivers/svga/svga_state_vs.c
+++ b/src/gallium/drivers/svga/svga_state_vs.c
@@ -26,6 +26,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_defines.h"
 #include "util/u_math.h"
+#include "util/u_bitmask.h"
 #include "translate/translate.h"
 
 #include "svga_context.h"
@@ -77,8 +78,12 @@ static enum pipe_error compile_vs( struct svga_context *svga,
       goto fail;
    }
 
+   result->id = util_bitmask_add(svga->vs_bm);
+   if(result->id == UTIL_BITMASK_INVALID_INDEX)
+      goto fail;
+
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_vs_id,
+                             result->id,
                              SVGA3D_SHADERTYPE_VS,
                              result->tokens, 
                              result->nr_tokens * sizeof result->tokens[0]);
@@ -86,14 +91,16 @@ static enum pipe_error compile_vs( struct svga_context *svga,
       goto fail;
 
    *out_result = result;
-   result->id = svga->state.next_vs_id++;
    result->next = vs->base.results;
    vs->base.results = result;
    return PIPE_OK;
 
 fail:
-   if (result)
+   if (result) {
+      if (result->id != UTIL_BITMASK_INVALID_INDEX)
+         util_bitmask_clear( svga->vs_bm, result->id );
       svga_destroy_shader_result( result );
+   }
    return ret;
 }
 
@@ -141,15 +148,14 @@ static int emit_hw_vs( struct svga_context *svga,
       id = result->id;
    }
 
-   if (id != svga->state.hw_draw.shader_id[PIPE_SHADER_VERTEX]) {
-      ret = SVGA3D_SetShader(svga->swc, 
-                             SVGA3D_SHADERTYPE_VS, 
+   if (result != svga->state.hw_draw.vs) {
+      ret = SVGA3D_SetShader(svga->swc,
+                             SVGA3D_SHADERTYPE_VS,
                              id );
       if (ret)
          return ret;
 
       svga->dirty |= SVGA_NEW_VS_RESULT;
-      svga->state.hw_draw.shader_id[PIPE_SHADER_VERTEX] = id;
       svga->state.hw_draw.vs = result;      
    }
 
diff --git a/src/gallium/drivers/svga/svga_tgsi.c b/src/gallium/drivers/svga/svga_tgsi.c
index b8ef137..0cd6201 100644
--- a/src/gallium/drivers/svga/svga_tgsi.c
+++ b/src/gallium/drivers/svga/svga_tgsi.c
@@ -31,6 +31,7 @@
 #include "tgsi/tgsi_dump.h"
 #include "tgsi/tgsi_scan.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 
 #include "svgadump/svga_shader_dump.h"
 
@@ -221,6 +222,7 @@ svga_tgsi_translate( const struct svga_shader *shader,
    result->tokens = (const unsigned *)emit.buf;
    result->nr_tokens = (emit.ptr - emit.buf) / sizeof(unsigned);
    memcpy(&result->key, &key, sizeof key);
+   result->id = UTIL_BITMASK_INVALID_INDEX;
 
    if (SVGA_DEBUG & DEBUG_TGSI) 
    {
diff --git a/src/gallium/drivers/trace/tr_context.c b/src/gallium/drivers/trace/tr_context.c
index bf470b4..540855c 100644
--- a/src/gallium/drivers/trace/tr_context.c
+++ b/src/gallium/drivers/trace/tr_context.c
@@ -52,6 +52,7 @@ trace_buffer_unwrap(struct trace_context *tr_ctx,
 
    assert(tr_buf->buffer);
    assert(tr_buf->buffer->screen == tr_scr->screen);
+   (void) tr_scr;
    return tr_buf->buffer;
 }
 
@@ -90,6 +91,7 @@ trace_surface_unwrap(struct trace_context *tr_ctx,
 
    assert(tr_surf->surface);
    assert(tr_surf->surface->texture->screen == tr_scr->screen);
+   (void) tr_scr;
    return tr_surf->surface;
 }
 
diff --git a/src/gallium/drivers/trace/tr_dump.c b/src/gallium/drivers/trace/tr_dump.c
index 7e2ccbc..0f45e21 100644
--- a/src/gallium/drivers/trace/tr_dump.c
+++ b/src/gallium/drivers/trace/tr_dump.c
@@ -40,7 +40,7 @@
 
 #include "pipe/p_config.h"
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE)
 #include <stdlib.h>
 #endif
 
@@ -258,7 +258,7 @@ boolean trace_dump_trace_begin()
       trace_dump_writes("<?xml-stylesheet type='text/xsl' href='trace.xsl'?>\n");
       trace_dump_writes("<trace version='0.1'>\n");
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE)
       /* Linux applications rarely cleanup GL / Gallium resources so catch
        * application exit here */
       atexit(trace_dump_trace_close);
diff --git a/src/gallium/drivers/trace/tr_rbug.c b/src/gallium/drivers/trace/tr_rbug.c
index 81e0a6f..0372d92 100644
--- a/src/gallium/drivers/trace/tr_rbug.c
+++ b/src/gallium/drivers/trace/tr_rbug.c
@@ -44,7 +44,7 @@
 
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  define sleep Sleep
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE)
 void usleep(int);
 #  define sleep usleep
 #else
@@ -179,7 +179,7 @@ static int
 trace_rbug_texture_info(struct trace_rbug *tr_rbug, struct rbug_header *header, uint32_t serial)
 {
    struct trace_screen *tr_scr = tr_rbug->tr_scr;
-   struct trace_texture *tr_tex;
+   struct trace_texture *tr_tex = NULL;
    struct rbug_proto_texture_info *gpti = (struct rbug_proto_texture_info *)header;
    struct tr_list *ptr;
    struct pipe_texture *t;
@@ -220,7 +220,7 @@ trace_rbug_texture_read(struct trace_rbug *tr_rbug, struct rbug_header *header,
    struct rbug_proto_texture_read *gptr = (struct rbug_proto_texture_read *)header;
 
    struct trace_screen *tr_scr = tr_rbug->tr_scr;
-   struct trace_texture *tr_tex;
+   struct trace_texture *tr_tex = NULL;
    struct tr_list *ptr;
 
    struct pipe_screen *screen = tr_scr->screen;
diff --git a/src/gallium/drivers/trace/tr_state.h b/src/gallium/drivers/trace/tr_state.h
index 1c16042..e2f981d 100644
--- a/src/gallium/drivers/trace/tr_state.h
+++ b/src/gallium/drivers/trace/tr_state.h
@@ -32,7 +32,7 @@ struct tgsi_token;
 enum trace_shader_type {
    TRACE_SHADER_FRAGMENT = 0,
    TRACE_SHADER_VERTEX   = 1,
-   TRACE_SHADER_GEOMETRY = 2,
+   TRACE_SHADER_GEOMETRY = 2
 };
 
 struct trace_shader
diff --git a/src/gallium/state_trackers/egl/egl_surface.c b/src/gallium/state_trackers/egl/egl_surface.c
index 91615ab..61b7f98 100644
--- a/src/gallium/state_trackers/egl/egl_surface.c
+++ b/src/gallium/state_trackers/egl/egl_surface.c
@@ -171,9 +171,9 @@ drm_takedown_shown_screen(_EGLDisplay *dpy, struct drm_screen *screen)
 	drmModeSetCrtc(
 		dev->drmFD,
 		screen->crtcID,
-		0, // FD
+		0, /* FD */
 		0, 0,
-		NULL, 0, // List of output ids
+		NULL, 0, /* List of output ids */
 		NULL);
 
 	drmModeRmFB(dev->drmFD, screen->fbID);
diff --git a/src/gallium/state_trackers/egl/egl_tracker.c b/src/gallium/state_trackers/egl/egl_tracker.c
index 745803c..9345b0f 100644
--- a/src/gallium/state_trackers/egl/egl_tracker.c
+++ b/src/gallium/state_trackers/egl/egl_tracker.c
@@ -152,6 +152,7 @@ drm_initialize(_EGLDriver *drv, _EGLDisplay *disp, EGLint *major, EGLint *minor)
 	int num_screens = 0;
 	EGLint i;
 	int fd;
+	_EGLConfig *config;
 
 	dev = (struct drm_device *) calloc(1, sizeof(struct drm_device));
 	if (!dev)
@@ -206,7 +207,7 @@ drm_initialize(_EGLDriver *drv, _EGLDisplay *disp, EGLint *major, EGLint *minor)
 	disp->DriverData = dev;
 
 	/* for now we only have one config */
-	_EGLConfig *config = calloc(1, sizeof(*config));
+	config = calloc(1, sizeof(*config));
 	memset(config, 1, sizeof(*config));
 	_eglInitConfig(config, 1);
 	_eglSetConfigAttrib(config, EGL_RED_SIZE, 8);
diff --git a/src/gallium/state_trackers/glx/xlib/glx_api.c b/src/gallium/state_trackers/glx/xlib/glx_api.c
index f2881b9..228ac9a 100644
--- a/src/gallium/state_trackers/glx/xlib/glx_api.c
+++ b/src/gallium/state_trackers/glx/xlib/glx_api.c
@@ -644,6 +644,7 @@ register_with_display(Display *dpy)
       XExtCodes *c = XAddExtension(dpy);
       ext = dpy->ext_procs;  /* new extension is at head of list */
       assert(c->extension == ext->codes.extension);
+      (void) c;
       ext->name = _mesa_strdup(extName);
       ext->close_display = close_display_callback;
    }
diff --git a/src/gallium/state_trackers/vega/api_path.c b/src/gallium/state_trackers/vega/api_path.c
index a6b7a2b..15ac190 100644
--- a/src/gallium/state_trackers/vega/api_path.c
+++ b/src/gallium/state_trackers/vega/api_path.c
@@ -164,8 +164,7 @@ void vgAppendPathData(VGPath dstPath,
       return;
    }
    for (i = 0; i < numSegments; ++i) {
-      if (pathSegments[i] < VG_CLOSE_PATH ||
-          pathSegments[i] > VG_LCWARC_TO_REL) {
+      if (pathSegments[i] > VG_LCWARC_TO_REL) {
          vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
          return;
       }
diff --git a/src/gallium/state_trackers/vega/arc.c b/src/gallium/state_trackers/vega/arc.c
index 8b04d21..2d12340 100644
--- a/src/gallium/state_trackers/vega/arc.c
+++ b/src/gallium/state_trackers/vega/arc.c
@@ -528,7 +528,6 @@ static INLINE int num_beziers_needed(struct arc *arc)
    double threshold = 0.05;
    VGboolean found = VG_FALSE;
    int n = 1;
-   int i;
    double min_eta, max_eta;
 
    min_eta = MIN2(arc->eta1, arc->eta2);
@@ -538,6 +537,7 @@ static INLINE int num_beziers_needed(struct arc *arc)
       double d_eta = (max_eta - min_eta) / n;
       if (d_eta <= 0.5 * M_PI) {
          double eta_b = min_eta;
+         int i;
          found = VG_TRUE;
          for (i = 0; found && (i < n); ++i) {
             double etaA = eta_b;
diff --git a/src/gallium/state_trackers/vega/bezier.c b/src/gallium/state_trackers/vega/bezier.c
index 0d55040..5769e8e 100644
--- a/src/gallium/state_trackers/vega/bezier.c
+++ b/src/gallium/state_trackers/vega/bezier.c
@@ -256,7 +256,6 @@ static enum shift_result good_offset(const struct bezier *b1,
    const float max_dist_normal = threshold*offset;
    const float spacing = 0.25;
    float i;
-
    for (i = spacing; i < 0.99; i += spacing) {
       float p1[2],p2[2], d, l;
       float normal[2];
diff --git a/src/gallium/state_trackers/vega/stroker.c b/src/gallium/state_trackers/vega/stroker.c
index 1b92d2b..68a5202 100644
--- a/src/gallium/state_trackers/vega/stroker.c
+++ b/src/gallium/state_trackers/vega/stroker.c
@@ -476,7 +476,7 @@ static enum intersection_type line_intersect(const VGfloat *l1,
                                              const VGfloat *l2,
                                              float *intersection_point)
 {
-   VGfloat isect[2];
+   VGfloat isect[2] = { 0 };
    enum intersection_type type;
    VGboolean dx_zero, ldx_zero;
 
@@ -649,7 +649,7 @@ static void create_joins(struct stroker *stroker,
       VGfloat prev_line[] = {stroker->back2_x, stroker->back2_y,
                              stroker->back1_x, stroker->back1_y};
 
-      VGfloat isect[2];
+      VGfloat isect[2] = { 0 };
       enum intersection_type type = line_intersect(prev_line, next_line, isect);
 
       if (join == SquareJoin) {
diff --git a/src/gallium/state_trackers/vega/vg_tracker.c b/src/gallium/state_trackers/vega/vg_tracker.c
index c4da01e..a8ab939 100644
--- a/src/gallium/state_trackers/vega/vg_tracker.c
+++ b/src/gallium/state_trackers/vega/vg_tracker.c
@@ -33,6 +33,7 @@
 #include "pipe/p_screen.h"
 #include "util/u_memory.h"
 #include "util/u_math.h"
+#include "util/u_rect.h"
 
 static struct pipe_texture *
 create_texture(struct pipe_context *pipe, enum pipe_format format,
diff --git a/src/gallium/state_trackers/xorg/xorg_crtc.c b/src/gallium/state_trackers/xorg/xorg_crtc.c
index 337449a..0160b1a 100644
--- a/src/gallium/state_trackers/xorg/xorg_crtc.c
+++ b/src/gallium/state_trackers/xorg/xorg_crtc.c
@@ -70,6 +70,8 @@ struct crtc_private
 static void
 crtc_dpms(xf86CrtcPtr crtc, int mode)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     switch (mode) {
     case DPMSModeOn:
     case DPMSModeStandby:
@@ -120,7 +122,8 @@ crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     drm_mode.vrefresh = mode->VRefresh;
     if (!mode->name)
 	xf86SetModeDefaultName(mode);
-    strncpy(drm_mode.name, mode->name, DRM_DISPLAY_MODE_LEN);
+    strncpy(drm_mode.name, mode->name, DRM_DISPLAY_MODE_LEN - 1);
+    drm_mode.name[DRM_DISPLAY_MODE_LEN - 1] = '\0';
 
     ret = drmModeSetCrtc(ms->fd, drm_crtc->crtc_id, ms->fb_id, x, y,
 			 &drm_connector->connector_id, 1, &drm_mode);
@@ -146,18 +149,23 @@ crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green, CARD16 * blue,
 static void *
 crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     return NULL;
 }
 
 static PixmapPtr
 crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     return NULL;
 }
 
 static void
 crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
 }
 
 /*
diff --git a/src/gallium/state_trackers/xorg/xorg_driver.c b/src/gallium/state_trackers/xorg/xorg_driver.c
index 8a24aa1..b02fe68 100644
--- a/src/gallium/state_trackers/xorg/xorg_driver.c
+++ b/src/gallium/state_trackers/xorg/xorg_driver.c
@@ -181,8 +181,7 @@ drv_crtc_resize(ScrnInfoPtr pScrn, int width, int height)
     if (!pScreen->ModifyPixmapHeader(rootPixmap, width, height, -1, -1, -1, NULL))
 	return FALSE;
 
-    /* HW dependent - FIXME */
-    pScrn->displayWidth = pScrn->virtualX;
+    pScrn->displayWidth = rootPixmap->devKind / (rootPixmap->drawable.bitsPerPixel / 8);
 
     /* now create new frontbuffer */
     return ms->create_front_buffer(pScrn) && ms->bind_front_buffer(pScrn);
@@ -220,6 +219,12 @@ static Bool
 drv_init_resource_management(ScrnInfoPtr pScrn)
 {
     modesettingPtr ms = modesettingPTR(pScrn);
+    /*
+    ScreenPtr pScreen = pScrn->pScreen;
+    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+    Bool fbAccessDisabled;
+    CARD8 *fbstart;
+     */
 
     if (ms->screen || ms->kms)
 	return TRUE;
@@ -249,9 +254,19 @@ static Bool
 drv_close_resource_management(ScrnInfoPtr pScrn)
 {
     modesettingPtr ms = modesettingPTR(pScrn);
+    int i;
 
-    if (ms->screen)
+    if (ms->screen) {
+	assert(ms->ctx == NULL);
+
+	for (i = 0; i < XORG_NR_FENCES; i++) {
+	    if (ms->fence[i]) {
+		ms->screen->fence_finish(ms->screen, ms->fence[i], 0);
+		ms->screen->fence_reference(ms->screen, &ms->fence[i], NULL);
+	    }
+	}
 	ms->screen->destroy(ms->screen);
+    }
     ms->screen = NULL;
 
     if (ms->api && ms->api->destroy)
@@ -461,7 +476,7 @@ static void drv_block_handler(int i, pointer blockData, pointer pTimeout,
         * quite small.  Let us get a fair way ahead of hardware before
         * throttling.
         */
-       for (j = 0; j < XORG_NR_FENCES; j++)
+       for (j = 0; j < XORG_NR_FENCES - 1; j++)
           ms->screen->fence_reference(ms->screen,
                                       &ms->fence[j],
                                       ms->fence[j+1]);
@@ -915,6 +930,12 @@ drv_destroy_front_buffer_kms(ScrnInfoPtr pScrn)
     ScreenPtr pScreen = pScrn->pScreen;
     PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
 
+    /* XXX Do something with the rootPixmap.
+     * This currently works fine but if we are getting crashes in
+     * the fb functions after VT switches maybe look more into it.
+     */
+    (void)rootPixmap;
+
     if (!ms->root_bo)
 	return TRUE;
 
diff --git a/src/gallium/state_trackers/xorg/xorg_exa.c b/src/gallium/state_trackers/xorg/xorg_exa.c
index 17a032e..4e78825 100644
--- a/src/gallium/state_trackers/xorg/xorg_exa.c
+++ b/src/gallium/state_trackers/xorg/xorg_exa.c
@@ -515,6 +515,7 @@ ExaCopy(PixmapPtr pDstPixmap, int srcX, int srcY, int dstX, int dstY,
 #endif
 
    debug_assert(priv == exa->copy.dst);
+   (void) priv;
 
    if (exa->copy.use_surface_copy) {
       /* XXX: consider exposing >1 box in surface_copy interface.
@@ -1020,6 +1021,9 @@ xorg_exa_close(ScrnInfoPtr pScrn)
 
    if (exa->pipe)
       exa->pipe->destroy(exa->pipe);
+   exa->pipe = NULL;
+   /* Since this was shared be proper with the pointer */
+   ms->ctx = NULL;
 
    exaDriverFini(pScrn->pScreen);
    xfree(exa);
diff --git a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
index 13a9840..bed17ca 100644
--- a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
+++ b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
@@ -47,22 +47,22 @@ static void
 print_fs_traits(int fs_traits)
 {
    const char *strings[] = {
-      "FS_COMPOSITE",       // = 1 << 0,
-      "FS_MASK",            // = 1 << 1,
-      "FS_SOLID_FILL",      // = 1 << 2,
-      "FS_LINGRAD_FILL",    // = 1 << 3,
-      "FS_RADGRAD_FILL",    // = 1 << 4,
-      "FS_CA_FULL",         // = 1 << 5, /* src.rgba * mask.rgba */
-      "FS_CA_SRCALPHA",     // = 1 << 6, /* src.aaaa * mask.rgba */
-      "FS_YUV",             // = 1 << 7,
-      "FS_SRC_REPEAT_NONE", // = 1 << 8,
-      "FS_MASK_REPEAT_NONE",// = 1 << 9,
-      "FS_SRC_SWIZZLE_RGB", // = 1 << 10,
-      "FS_MASK_SWIZZLE_RGB",// = 1 << 11,
-      "FS_SRC_SET_ALPHA",   // = 1 << 12,
-      "FS_MASK_SET_ALPHA",  // = 1 << 13,
-      "FS_SRC_LUMINANCE",   // = 1 << 14,
-      "FS_MASK_LUMINANCE",  // = 1 << 15,
+      "FS_COMPOSITE",       /* = 1 << 0, */
+      "FS_MASK",            /* = 1 << 1, */
+      "FS_SOLID_FILL",      /* = 1 << 2, */
+      "FS_LINGRAD_FILL",    /* = 1 << 3, */
+      "FS_RADGRAD_FILL",    /* = 1 << 4, */
+      "FS_CA_FULL",         /* = 1 << 5, */ /* src.rgba * mask.rgba */
+      "FS_CA_SRCALPHA",     /* = 1 << 6, */ /* src.aaaa * mask.rgba */
+      "FS_YUV",             /* = 1 << 7, */
+      "FS_SRC_REPEAT_NONE", /* = 1 << 8, */
+      "FS_MASK_REPEAT_NONE",/* = 1 << 9, */
+      "FS_SRC_SWIZZLE_RGB", /* = 1 << 10, */
+      "FS_MASK_SWIZZLE_RGB",/* = 1 << 11, */
+      "FS_SRC_SET_ALPHA",   /* = 1 << 12, */
+      "FS_MASK_SET_ALPHA",  /* = 1 << 13, */
+      "FS_SRC_LUMINANCE",   /* = 1 << 14, */
+      "FS_MASK_LUMINANCE",  /* = 1 << 15, */
    };
    int i, k;
    debug_printf("%s: ", __func__);
@@ -492,6 +492,7 @@ create_fs(struct pipe_context *pipe,
 
    /* it has to be either a fill, a composite op or a yuv conversion */
    debug_assert((is_fill ^ is_composite) ^ is_yuv);
+   (void) is_yuv;
 
    out = ureg_DECL_output(ureg,
                           TGSI_SEMANTIC_COLOR,
diff --git a/src/gallium/state_trackers/xorg/xorg_renderer.c b/src/gallium/state_trackers/xorg/xorg_renderer.c
index cbb84a8..37c8942 100644
--- a/src/gallium/state_trackers/xorg/xorg_renderer.c
+++ b/src/gallium/state_trackers/xorg/xorg_renderer.c
@@ -437,6 +437,7 @@ void renderer_copy_prepare(struct xorg_renderer *r,
                                       PIPE_TEXTURE_2D,
                                       PIPE_TEXTURE_USAGE_RENDER_TARGET,
                                       0));
+   (void) screen;
 
 
    /* set misc state we care about */
diff --git a/src/gallium/winsys/gdi/SConscript b/src/gallium/winsys/gdi/SConscript
index 8f556da..917a81c 100644
--- a/src/gallium/winsys/gdi/SConscript
+++ b/src/gallium/winsys/gdi/SConscript
@@ -42,6 +42,8 @@ if env['platform'] == 'windows':
         
     drivers += [trace]
 
+    env['no_import_lib'] = 1
+
     env.SharedLibrary(
         target ='opengl32',
         source = sources,
diff --git a/src/gallium/winsys/xlib/xlib_brw_context.c b/src/gallium/winsys/xlib/xlib_brw_context.c
new file mode 100644
index 0000000..fc9addd
--- /dev/null
+++ b/src/gallium/winsys/xlib/xlib_brw_context.c
@@ -0,0 +1,209 @@
+/**************************************************************************
+ * 
+ * Copyright 2007 Tungsten Graphics, Inc., Bismarck, ND., USA
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * 
+ **************************************************************************/
+
+/*
+ * Authors:
+ *   Keith Whitwell
+ *   Brian Paul
+ */
+
+
+/* #include "glxheader.h" */
+/* #include "xmesaP.h" */
+
+#include "pipe/internal/p_winsys_screen.h"
+#include "pipe/p_inlines.h"
+#include "util/u_math.h"
+#include "util/u_memory.h"
+#include "i965simple/brw_winsys.h"
+#include "xlib_brw_aub.h"
+#include "xlib_brw.h"
+
+
+
+
+#define XBCWS_BATCHBUFFER_SIZE 1024
+
+
+/* The backend to the brw driver (ie struct brw_winsys) is actually a
+ * per-context entity.
+ */
+struct xlib_brw_context_winsys {
+   struct brw_winsys brw_context_winsys;   /**< batch buffer funcs */
+   struct aub_context *aub;
+                         
+   struct pipe_winsys *pipe_winsys;
+
+   unsigned batch_data[XBCWS_BATCHBUFFER_SIZE];
+   unsigned batch_nr;
+   unsigned batch_size;
+   unsigned batch_alloc;
+};
+
+
+/* Turn a brw_winsys into an xlib_brw_context_winsys:
+ */
+static inline struct xlib_brw_context_winsys *
+xlib_brw_context_winsys( struct brw_winsys *sws )
+{
+   return (struct xlib_brw_context_winsys *)sws;
+}
+
+
+/* Simple batchbuffer interface:
+ */
+
+static unsigned *xbcws_batch_start( struct brw_winsys *sws,
+					 unsigned dwords,
+					 unsigned relocs )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   if (xbcws->batch_size < xbcws->batch_nr + dwords)
+      return NULL;
+
+   xbcws->batch_alloc = xbcws->batch_nr + dwords;
+   return (void *)1;			/* not a valid pointer! */
+}
+
+static void xbcws_batch_dword( struct brw_winsys *sws,
+				    unsigned dword )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr < xbcws->batch_alloc);
+   xbcws->batch_data[xbcws->batch_nr++] = dword;
+}
+
+static void xbcws_batch_reloc( struct brw_winsys *sws,
+			     struct pipe_buffer *buf,
+			     unsigned access_flags,
+			     unsigned delta )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr < xbcws->batch_alloc);
+   xbcws->batch_data[xbcws->batch_nr++] = 
+      ( xlib_brw_get_buffer_offset( NULL, buf, access_flags ) +
+        delta );
+}
+
+static void xbcws_batch_end( struct brw_winsys *sws )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr <= xbcws->batch_alloc);
+   xbcws->batch_alloc = 0;
+}
+
+static void xbcws_batch_flush( struct brw_winsys *sws,
+				    struct pipe_fence_handle **fence )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+   assert(xbcws->batch_nr <= xbcws->batch_size);
+
+   if (xbcws->batch_nr) {
+      xlib_brw_commands_aub( xbcws->pipe_winsys,
+                             xbcws->batch_data,
+                             xbcws->batch_nr );
+   }
+
+   xbcws->batch_nr = 0;
+}
+
+  
+
+/* Really a per-device function, just pass through:
+ */
+static unsigned xbcws_get_buffer_offset( struct brw_winsys *sws,
+                                         struct pipe_buffer *buf,
+                                         unsigned access_flags )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   return xlib_brw_get_buffer_offset( xbcws->pipe_winsys,
+                                      buf,
+                                      access_flags );
+}
+
+
+/* Really a per-device function, just pass through:
+ */
+static void xbcws_buffer_subdata_typed( struct brw_winsys *sws,
+                                       struct pipe_buffer *buf,
+                                       unsigned long offset, 
+                                       unsigned long size, 
+                                       const void *data,
+                                       unsigned data_type )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   xlib_brw_buffer_subdata_typed( xbcws->pipe_winsys,
+                                  buf,
+                                  offset,
+                                  size,
+                                  data,
+                                  data_type );
+}
+
+
+/**
+ * Create i965 hardware rendering context, but plugged into a
+ * dump-to-aubfile backend.
+ */
+struct pipe_context *
+xlib_create_brw_context( struct pipe_screen *screen,
+                         void *unused )
+{
+   struct xlib_brw_context_winsys *xbcws = CALLOC_STRUCT( xlib_brw_context_winsys );
+   
+   /* Fill in this struct with callbacks that i965simple will need to
+    * communicate with the window system, buffer manager, etc. 
+    */
+   xbcws->brw_context_winsys.batch_start = xbcws_batch_start;
+   xbcws->brw_context_winsys.batch_dword = xbcws_batch_dword;
+   xbcws->brw_context_winsys.batch_reloc = xbcws_batch_reloc;
+   xbcws->brw_context_winsys.batch_end = xbcws_batch_end;
+   xbcws->brw_context_winsys.batch_flush = xbcws_batch_flush;
+   xbcws->brw_context_winsys.buffer_subdata_typed = xbcws_buffer_subdata_typed;
+   xbcws->brw_context_winsys.get_buffer_offset = xbcws_get_buffer_offset;
+
+   xbcws->pipe_winsys = screen->winsys; /* redundant */
+
+   xbcws->batch_size = XBCWS_BATCHBUFFER_SIZE;
+
+   /* Create the i965simple context:
+    */
+#ifdef GALLIUM_CELL
+   return NULL;
+#else
+   return brw_create( screen,
+		      &xbcws->brw_context_winsys,
+		      0 );
+#endif
+}
diff --git a/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h b/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
index 4493296..ba6868a 100644
--- a/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
+++ b/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
@@ -33,6 +33,7 @@
 #ifndef _BEZIERPATCHMESH_H
 #define _BEZIERPATCHMESH_H
 
+#include <GL/gl.h>
 #include "bezierPatch.h"
 
 typedef struct bezierPatchMesh{
diff --git a/src/glu/sgi/libnurbs/interface/glsurfeval.h b/src/glu/sgi/libnurbs/interface/glsurfeval.h
index 1567c6b..621e593 100644
--- a/src/glu/sgi/libnurbs/interface/glsurfeval.h
+++ b/src/glu/sgi/libnurbs/interface/glsurfeval.h
@@ -83,7 +83,7 @@ typedef struct surfEvalMachine{
 
 class StoredVertex {
 public:
-    		StoredVertex() { type = 0; }
+    		StoredVertex() { type = 0; coord[0] = 0; coord[1] = 0; point[0] = 0; point[1] = 0; }
 		~StoredVertex(void) {}
     void	saveEvalCoord(REAL x, REAL y) 
 		    {coord[0] = x; coord[1] = y; type = TYPECOORD; }
diff --git a/src/glu/sgi/libnurbs/internals/arcsorter.h b/src/glu/sgi/libnurbs/internals/arcsorter.h
index d72dd1e..a55df92 100644
--- a/src/glu/sgi/libnurbs/internals/arcsorter.h
+++ b/src/glu/sgi/libnurbs/internals/arcsorter.h
@@ -37,7 +37,6 @@
 #define __gluarcsorter_h_
 
 #include "sorter.h"
-#include "arcsorter.h"
 
 class Arc;
 class Subdivider;
diff --git a/src/glu/sgi/libnurbs/internals/displaylist.h b/src/glu/sgi/libnurbs/internals/displaylist.h
index 22cbec3..d009a42 100644
--- a/src/glu/sgi/libnurbs/internals/displaylist.h
+++ b/src/glu/sgi/libnurbs/internals/displaylist.h
@@ -59,6 +59,7 @@ Dlnode::Dlnode( PFVS _work, void *_arg, PFVS _cleanup )
     work = _work;
     arg = _arg;
     cleanup = _cleanup;
+    next = 0;
 }
 
 class DisplayList {
diff --git a/src/glu/sgi/libnurbs/internals/gridvertex.h b/src/glu/sgi/libnurbs/internals/gridvertex.h
index 36a65c7..2e27436 100644
--- a/src/glu/sgi/libnurbs/internals/gridvertex.h
+++ b/src/glu/sgi/libnurbs/internals/gridvertex.h
@@ -38,7 +38,7 @@
 
 struct GridVertex {
     long 		gparam[2];
-			GridVertex( void ) {}
+			GridVertex( void ) { gparam[0] = 0, gparam[1] = 0; }
 			GridVertex( long u, long v ) { gparam[0] = u, gparam[1] = v; }
     void		set( long u, long v ) { gparam[0] = u, gparam[1] = v; }
     long		nextu() { return gparam[0]++; }
diff --git a/src/glu/sgi/libnurbs/internals/knotvector.cc b/src/glu/sgi/libnurbs/internals/knotvector.cc
index 9eb5cba..dcbf006 100644
--- a/src/glu/sgi/libnurbs/internals/knotvector.cc
+++ b/src/glu/sgi/libnurbs/internals/knotvector.cc
@@ -61,6 +61,9 @@ void Knotvector::init( long _knotcount, long _stride, long _order, INREAL *_knot
 
 Knotvector::Knotvector( void )
 {
+    knotcount = 0;
+    stride = 0;
+    order = 0;
     knotlist = 0;
 }
 
diff --git a/src/glu/sgi/libnurbs/internals/mesher.cc b/src/glu/sgi/libnurbs/internals/mesher.cc
index 9cc436a..b2d83f4 100644
--- a/src/glu/sgi/libnurbs/internals/mesher.cc
+++ b/src/glu/sgi/libnurbs/internals/mesher.cc
@@ -58,6 +58,9 @@ Mesher::Mesher( Backend& b )
 {
     stacksize = 0;
     vdata = 0;
+    last[0] = 0;
+    last[1] = 0;
+    itop = 0;
     lastedge = 0; //needed to prevent purify UMR 
 }
 
diff --git a/src/glu/sgi/libnurbs/internals/reader.cc b/src/glu/sgi/libnurbs/internals/reader.cc
index 6135eef..c59240d 100644
--- a/src/glu/sgi/libnurbs/internals/reader.cc
+++ b/src/glu/sgi/libnurbs/internals/reader.cc
@@ -64,6 +64,7 @@ O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride,
     owner = 0;
     pts = trimpts;
     npts = (int) count;
+    save = 0;
     int i;
 
     /* copy user data into internal trimming data structures */
@@ -115,6 +116,7 @@ O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride,
     owner = 0;
     pts = trimpts;
     npts = (int) count;
+    save = 0;
 
     /* copy user data into internal trimming data structures */
     switch( _type ) {
diff --git a/src/glu/sgi/libnurbs/internals/reader.h b/src/glu/sgi/libnurbs/internals/reader.h
index 8a8dceb..cae6cad 100644
--- a/src/glu/sgi/libnurbs/internals/reader.h
+++ b/src/glu/sgi/libnurbs/internals/reader.h
@@ -64,7 +64,7 @@ struct O_curve : public PooledObj {
     int			save;		/* 1 if in display list		*/
     long		nuid;
     			O_curve() { next = 0; used = 0; owner = 0; 
-				    curve.o_pwlcurve = 0; }
+				    curve.o_pwlcurve = 0; curvetype = ct_none; save = 0; nuid = 0; }
     };
 
 struct O_nurbscurve : public PooledObj {
@@ -77,7 +77,7 @@ struct O_nurbscurve : public PooledObj {
     int			save;		/* 1 if in display list		*/
     O_curve *		owner;		/* owning curve 		*/
 			O_nurbscurve( long _type ) 
-			   { type = _type; owner = 0; next = 0; used = 0; }
+			   { bezier_curves = 0; type = _type; tesselation = 0; method = 0; next = 0; used = 0; save = 0; owner = 0; }
     };
  
 class O_pwlcurve : public PooledObj {
@@ -95,7 +95,7 @@ struct O_trim : public PooledObj {
     O_curve		*o_curve;	/* closed trim loop	 	*/
     O_trim *		next;		/* next loop along trim 	*/
     int			save;		/* 1 if in display list		*/
-			O_trim() { next = 0; o_curve = 0; }
+			O_trim() { next = 0; o_curve = 0; save = 0; }
     };
 
 struct O_nurbssurface : public PooledObj {
@@ -106,7 +106,7 @@ struct O_nurbssurface : public PooledObj {
     int			save;		/* 1 if in display list		*/
     int			used;		/* 1 if prev called in block	*/
 			O_nurbssurface( long _type ) 
-			   { type = _type; owner = 0; next = 0; used = 0; }
+			   { bezier_patches = 0; type = _type; owner = 0; next = 0; save = 0; used = 0; }
     };
 
 struct O_surface : public PooledObj {
@@ -114,7 +114,7 @@ struct O_surface : public PooledObj {
     O_trim *		o_trim;		/* list of trim loops		*/
     int			save;		/* 1 if in display list		*/
     long		nuid;
-			O_surface() { o_trim = 0; o_nurbssurface = 0; }
+			O_surface() { o_trim = 0; o_nurbssurface = 0; save = 0; nuid = 0; }
     };
 
 struct Property : public PooledObj {
@@ -123,9 +123,9 @@ struct Property : public PooledObj {
     REAL		value;
     int			save;		/* 1 if in display list		*/
 			Property( long _type, long _tag, INREAL _value )
-			{ type = _type; tag = _tag; value = (REAL) _value; }
+			{ type = _type; tag = _tag; value = (REAL) _value; save = 0; }
 			Property( long _tag, INREAL _value )
-			{ type = 0; tag = _tag; value = (REAL) _value; }
+			{ type = 0; tag = _tag; value = (REAL) _value; save = 0; }
     };
 
 class NurbsTessellator;
diff --git a/src/glu/sgi/libnurbs/internals/renderhints.cc b/src/glu/sgi/libnurbs/internals/renderhints.cc
index a3aa62d..7025f74 100644
--- a/src/glu/sgi/libnurbs/internals/renderhints.cc
+++ b/src/glu/sgi/libnurbs/internals/renderhints.cc
@@ -54,6 +54,10 @@ Renderhints::Renderhints()
     errorchecking 	= N_MSG;
     subdivisions 	= 6.0;
     tmp1 		= 0.0;
+    displaydomain 	= 0;
+    maxsubdivisions 	= (int) subdivisions;
+    wiretris	 	= 0;
+    wirequads	 	= 0;
 }
 
 void
diff --git a/src/glu/sgi/libnurbs/internals/simplemath.h b/src/glu/sgi/libnurbs/internals/simplemath.h
index 0a060c5..d00062d 100644
--- a/src/glu/sgi/libnurbs/internals/simplemath.h
+++ b/src/glu/sgi/libnurbs/internals/simplemath.h
@@ -38,6 +38,8 @@
 
 /* simple inline routines */
 
+#include "types.h"
+
 inline int 
 max( int x, int y ) { return ( x < y ) ? y : x; }
 
diff --git a/src/glu/sgi/libnurbs/internals/slicer.cc b/src/glu/sgi/libnurbs/internals/slicer.cc
index 27d2a65..1b18d73 100644
--- a/src/glu/sgi/libnurbs/internals/slicer.cc
+++ b/src/glu/sgi/libnurbs/internals/slicer.cc
@@ -1181,6 +1181,10 @@ void Slicer::slice(Arc_ptr loop)
 Slicer::Slicer( Backend &b ) 
 	: CoveAndTiler( b ), Mesher( b ), backend( b )
 {
+    oneOverDu = 0;
+    du = 0;
+    dv = 0;
+    isolines = 0;
     ulinear = 0;
     vlinear = 0;
 }
diff --git a/src/glu/sgi/libnurbs/internals/subdivider.cc b/src/glu/sgi/libnurbs/internals/subdivider.cc
index cc0b514..ccddc27 100644
--- a/src/glu/sgi/libnurbs/internals/subdivider.cc
+++ b/src/glu/sgi/libnurbs/internals/subdivider.cc
@@ -531,16 +531,18 @@ Subdivider::nonSamplingSplit(
 		     patchlist.pspec[param].range[1] ) * 0.5;
 	split( source, left, right, param, mid );
 	Patchlist subpatchlist( patchlist, param, mid );
-	if( left.isnonempty() )
+	if( left.isnonempty() ) {
 	    if( subpatchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
 		freejarcs( left );
 	    else
 	        nonSamplingSplit( left, subpatchlist, subdivisions-1, param );
-	if( right.isnonempty() ) 
+	}
+	if( right.isnonempty() ) {
 	    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
 		freejarcs( right );
 	    else
 	        nonSamplingSplit( right, patchlist, subdivisions-1, param );
+	}
 
     } else {
 	// make bbox calls
diff --git a/src/glu/sgi/libnurbs/internals/varray.cc b/src/glu/sgi/libnurbs/internals/varray.cc
index 31cc73a..1cb2354 100644
--- a/src/glu/sgi/libnurbs/internals/varray.cc
+++ b/src/glu/sgi/libnurbs/internals/varray.cc
@@ -53,8 +53,16 @@ inline long sgn( REAL x )
 
 Varray::Varray( void )
 {
+    int i;
+
     varray = 0;
     size = 0;
+    numquads = 0;
+
+    for (i = 0; i < 1000; i++) {
+        vval[i] = 0;
+        voffset[i] = 0;
+    }
 }
 
 Varray::~Varray( void )
diff --git a/src/glu/sgi/libnurbs/nurbtess/directedLine.cc b/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
index 7445035..d942db7 100644
--- a/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
@@ -309,6 +309,8 @@ directedLine::directedLine()
   nextPolygon = NULL;
   rootBit = 0;/*important to initilzae to 0 meaning not root yet*/
   rootLink = NULL;
+  direction = INCREASING;
+  sline = NULL;
 }
 
 directedLine::~directedLine()
@@ -791,22 +793,30 @@ directedLine* readAllPolygons(char* filename)
 {
   Int i,j;
   FILE* fp = fopen(filename, "r");
-  assert(fp);
   Int nPolygons;
-  fscanf(fp, "%i", &nPolygons);
+  int result;
+
+  assert(fp);
+  result = fscanf(fp, "%i", &nPolygons);
+  assert(result != EOF);
   directedLine *ret = NULL;
 
   for(i=0; i<nPolygons; i++)
     {
       Int nEdges;
-      fscanf(fp, "%i", &nEdges);
-      Real vert[2][2];
+      result = fscanf(fp, "%i", &nEdges);
+      assert(result != EOF);
+      Real vert[2][2] = { { 0 } };
       Real VV[2][2];
       /*the first two vertices*/
-      fscanf(fp, "%f", &(vert[0][0]));
-      fscanf(fp, "%f", &(vert[0][1]));
-      fscanf(fp, "%f", &(vert[1][0]));
-      fscanf(fp, "%f", &(vert[1][1]));
+      result = fscanf(fp, "%f", &(vert[0][0]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[0][1]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[1][0]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[1][1]));
+      assert(result != EOF);
       VV[1][0] = vert[0][0];
       VV[1][1] = vert[0][1];
       sampledLine *sLine = new sampledLine(2, vert);
@@ -818,8 +828,10 @@ thisPoly->rootLinkSet(NULL);
 	{
 	  vert[0][0]=vert[1][0];
 	  vert[0][1]=vert[1][1];
-	  fscanf(fp, "%f", &(vert[1][0]));
-	  fscanf(fp, "%f", &(vert[1][1]));
+	  result = fscanf(fp, "%f", &(vert[1][0]));
+	  assert(result != EOF);
+	  result = fscanf(fp, "%f", &(vert[1][1]));
+	  assert(result != EOF);
 	  sLine = new sampledLine(2,vert);
 	  dLine = new directedLine(INCREASING, sLine);
 dLine->rootLinkSet(thisPoly);
diff --git a/src/glu/sgi/libnurbs/nurbtess/monoChain.cc b/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
index 814bf32..b17b940 100644
--- a/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
@@ -127,6 +127,7 @@ monoChain::monoChain(directedLine* cHead, directedLine* cTail)
     current = chainTail;
 
   isKey = 0;
+  keyY = 0;
 }
 
 //insert a new line between prev and this
diff --git a/src/glu/sgi/libnurbs/nurbtess/partitionY.cc b/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
index 297c629..e097461 100644
--- a/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
@@ -111,8 +111,8 @@ Int isCusp(directedLine *v)
   else if(A[1] > B[1] && C[1] > B[1])
     return 1;
 
-  if(isAbove(v, v) && isAbove(v, v->getPrev()) ||
-     isBelow(v, v) && isBelow(v, v->getPrev()))
+  if((isAbove(v, v) && isAbove(v, v->getPrev())) ||
+     (isBelow(v, v) && isBelow(v, v->getPrev())))
     return 1;
   else
     return 0;
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc b/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
index e12f88b..2e70f83 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
@@ -207,7 +207,7 @@ void sampleBotRightWithGridLine(Real* botVertex,
     return;
   }
 
-  Int segIndexMono, segIndexPass;
+  Int segIndexMono = 0, segIndexPass;
   findBotRightSegment(rightChain,
 		      rightEnd,
 		      rightCorner,
@@ -293,7 +293,7 @@ void sampleBotLeftWithGridLine(Real* botVertex,
     return;
   }
 
-  Int segIndexPass, segIndexMono;
+  Int segIndexPass, segIndexMono = 0;
   findBotLeftSegment(leftChain, leftEnd, leftCorner, grid->get_u_value(leftU), segIndexMono, segIndexPass);
 
   sampleBotLeftWithGridLinePost(botVertex,
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc b/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
index b7b9296..951e937 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
@@ -172,7 +172,7 @@ void sampleTopRightWithGridLine(Real* topVertex,
     return;
   }
 
-  Int segIndexSmall, segIndexLarge;
+  Int segIndexSmall = 0, segIndexLarge;
   findTopRightSegment(rightChain,
                       rightStart,
                       rightEnd,
@@ -294,7 +294,7 @@ void sampleTopLeftWithGridLine(Real* topVertex,
                                 primStream* pStream
                                 )
 {
-  Int segIndexSmall, segIndexLarge;
+  Int segIndexSmall = 0, segIndexLarge;
   //if left chain is empty, then there is only one top vertex with one grid 
   //  line
   if(leftEnd < leftStart) {
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc b/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
index 6253a7c..89f6c6e 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
@@ -107,6 +107,9 @@ sampledLine::sampledLine(Real pt1[2], Real pt2[2])
 //needs tp call init to setup
 sampledLine::sampledLine()
 {
+  npoints = 0;
+  points = NULL;
+  next = NULL;
 }
 
 //warning: ONLY pointer is copies!!!
diff --git a/src/glx/x11/dri2.c b/src/glx/x11/dri2.c
index e144ed3..dad0447 100644
--- a/src/glx/x11/dri2.c
+++ b/src/glx/x11/dri2.c
@@ -31,6 +31,8 @@
  */
 
 
+#ifdef GLX_DIRECT_RENDERING
+
 #define NEED_REPLIES
 #include <X11/Xlibint.h>
 #include <X11/extensions/Xext.h>
@@ -377,3 +379,5 @@ DRI2CopyRegion(Display * dpy, XID drawable, XserverRegion region,
    UnlockDisplay(dpy);
    SyncHandle();
 }
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/glx/x11/dri_glx.c b/src/glx/x11/dri_glx.c
index 4f7acb6..88487b6 100644
--- a/src/glx/x11/dri_glx.c
+++ b/src/glx/x11/dri_glx.c
@@ -280,8 +280,6 @@ static const __DRIextension *loader_extensions[] = {
    NULL
 };
 
-#ifndef GLX_USE_APPLEGL
-
 /**
  * Perform the required libGL-side initialization and call the client-side
  * driver's \c __driCreateNewScreen function.
@@ -475,17 +473,6 @@ CallCreateNewScreen(Display * dpy, int scrn, __GLXscreenConfigs * psc,
    return NULL;
 }
 
-#else /* !GLX_USE_APPLEGL */
-
-static void *
-CallCreateNewScreen(Display * dpy, int scrn, __GLXscreenConfigs * psc,
-                    __GLXDRIdisplayPrivate * driDpy)
-{
-   return NULL;
-}
-
-#endif /* !GLX_USE_APPLEGL */
-
 static void
 driDestroyContext(__GLXDRIcontext * context,
                   __GLXscreenConfigs * psc, Display * dpy)
diff --git a/src/glx/x11/glxcmds.c b/src/glx/x11/glxcmds.c
index daa9076..d1c68dd 100644
--- a/src/glx/x11/glxcmds.c
+++ b/src/glx/x11/glxcmds.c
@@ -2575,7 +2575,7 @@ glXAllocateMemoryMESA(Display * dpy, int scrn,
    (void) readFreq;
    (void) writeFreq;
    (void) priority;
-#endif /* GLX_DIRECT_RENDERING */
+#endif /* __DRI_ALLOCATE */
 
    return NULL;
 }
@@ -2594,7 +2594,7 @@ glXFreeMemoryMESA(Display * dpy, int scrn, void *pointer)
    (void) dpy;
    (void) scrn;
    (void) pointer;
-#endif /* GLX_DIRECT_RENDERING */
+#endif /* __DRI_ALLOCATE */
 }
 
 
diff --git a/src/glx/x11/glxcurrent.c b/src/glx/x11/glxcurrent.c
index f1e3e16..fae1bd9 100644
--- a/src/glx/x11/glxcurrent.c
+++ b/src/glx/x11/glxcurrent.c
@@ -475,13 +475,6 @@ MakeContextCurrent(Display * dpy, GLXDrawable draw,
                IndirectAPI = __glXNewIndirectAPI();
             _glapi_set_dispatch(IndirectAPI);
 
-#ifdef GLX_USE_APPLEGL
-            do {
-               extern void XAppleDRIUseIndirectDispatch(void);
-               XAppleDRIUseIndirectDispatch();
-            } while (0);
-#endif
-
             state = (__GLXattribute *) (gc->client_state_private);
 
             gc->currentContextTag = reply.contextTag;
diff --git a/src/glx/x11/glxext.c b/src/glx/x11/glxext.c
index e5553cb..5633a3e 100644
--- a/src/glx/x11/glxext.c
+++ b/src/glx/x11/glxext.c
@@ -150,8 +150,9 @@ FreeScreenConfigs(__GLXdisplayPrivate * priv)
 
 #ifdef GLX_DIRECT_RENDERING
       if (psc->driver_configs) {
-         for (unsigned int i = 0; psc->driver_configs[i]; i++)
-            free((__DRIconfig *) psc->driver_configs[i]);
+         unsigned int j;
+         for (j = 0; psc->driver_configs[j]; j++)
+            free((__DRIconfig *) psc->driver_configs[j]);
          free(psc->driver_configs);
          psc->driver_configs = NULL;
       }
diff --git a/src/glx/x11/xf86dri.h b/src/glx/x11/xf86dri.h
index f2d0dd5..ba26600 100644
--- a/src/glx/x11/xf86dri.h
+++ b/src/glx/x11/xf86dri.h
@@ -115,6 +115,10 @@ Bool XF86DRIGetDeviceInfo(Display * dpy, int screen,
                           int *fbSize, int *fbStride, int *devPrivateSize,
                           void **pDevPrivate);
 
+Bool XF86DRIOpenFullScreen(Display * dpy, int screen, Drawable drawable);
+
+Bool XF86DRICloseFullScreen(Display * dpy, int screen, Drawable drawable);
+
 _XFUNCPROTOEND
 #endif /* _XF86DRI_SERVER_ */
 #endif /* _XF86DRI_H_ */
diff --git a/src/mesa/Makefile b/src/mesa/Makefile
index 6f58ad6..96b4ff8 100644
--- a/src/mesa/Makefile
+++ b/src/mesa/Makefile
@@ -43,7 +43,7 @@ libglapi.a: $(GLAPI_OBJECTS)
 
 ######################################################################
 # Device drivers
-driver_subdirs: libmesa.a libglapi.a
+driver_subdirs: libmesa.a libglapi.a libmesagallium.a
 	@ (cd drivers && $(MAKE))
 
 
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index cd9075b..28abcc4 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -500,9 +500,9 @@ _mesa_meta_begin(GLcontext *ctx, GLbitfield state)
       _mesa_LoadIdentity();
       _mesa_MatrixMode(GL_PROJECTION);
       _mesa_LoadIdentity();
-      _mesa_Ortho(0.0F, ctx->DrawBuffer->Width,
-                  0.0F, ctx->DrawBuffer->Height,
-                  -1.0F, 1.0F);
+      _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
+                  0.0, ctx->DrawBuffer->Height,
+                  -1.0, 1.0);
       save->ClipPlanesEnabled = ctx->Transform.ClipPlanesEnabled;
       if (ctx->Transform.ClipPlanesEnabled) {
          GLuint i;
@@ -2289,6 +2289,26 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
 
    _mesa_set_enable(ctx, target, GL_TRUE);
 
+   /* setup vertex positions */
+   {
+      verts[0].x = 0.0F;
+      verts[0].y = 0.0F;
+      verts[1].x = 1.0F;
+      verts[1].y = 0.0F;
+      verts[2].x = 1.0F;
+      verts[2].y = 1.0F;
+      verts[3].x = 0.0F;
+      verts[3].y = 1.0F;
+      
+      /* upload new vertex data */
+      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
+   }
+
+   /* setup projection matrix */
+   _mesa_MatrixMode(GL_PROJECTION);
+   _mesa_LoadIdentity();
+   _mesa_Ortho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
+
    /* texture is already locked, unlock now */
    _mesa_unlock_texture(ctx, texObj);
 
@@ -2355,21 +2375,6 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
          }
       }
 
-      /* setup vertex positions */
-      {
-         verts[0].x = 0.0F;
-         verts[0].y = 0.0F;
-         verts[1].x = (GLfloat) dstWidth;
-         verts[1].y = 0.0F;
-         verts[2].x = (GLfloat) dstWidth;
-         verts[2].y = (GLfloat) dstHeight;
-         verts[3].x = 0.0F;
-         verts[3].y = (GLfloat) dstHeight;
-
-         /* upload new vertex data */
-         _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
-      }
-
       /* limit sampling to src level */
       _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, srcLevel);
       _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);
@@ -2408,6 +2413,12 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
          break;
       }
 
+      assert(dstWidth == ctx->DrawBuffer->Width);
+      assert(dstHeight == ctx->DrawBuffer->Height);
+
+      /* setup viewport */
+      _mesa_set_viewport(ctx, 0, 0, dstWidth, dstHeight);
+
       _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
    }
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_tris.c b/src/mesa/drivers/dri/ffb/ffb_tris.c
index d785c15..e7dd960 100644
--- a/src/mesa/drivers/dri/ffb/ffb_tris.c
+++ b/src/mesa/drivers/dri/ffb/ffb_tris.c
@@ -352,7 +352,7 @@ static struct {
 #define LOCAL_VARS(n)				\
    ffbContextPtr fmesa = FFB_CONTEXT(ctx);	\
    __DRIdrawablePrivate *dPriv = fmesa->driDrawable; \
-   ffb_color color[n];				\
+   ffb_color color[n] = { { 0 } };		\
    (void) color; (void) dPriv;
 
 /***********************************************************************
diff --git a/src/mesa/drivers/dri/i810/i810tex.h b/src/mesa/drivers/dri/i810/i810tex.h
index d980927..28958dc 100644
--- a/src/mesa/drivers/dri/i810/i810tex.h
+++ b/src/mesa/drivers/dri/i810/i810tex.h
@@ -29,7 +29,6 @@
 #include "main/mtypes.h"
 #include "main/mm.h"
 
-#include "i810context.h"
 #include "i810_3d_reg.h"
 #include "texmem.h"
 
diff --git a/src/mesa/drivers/dri/i915/i915_program.c b/src/mesa/drivers/dri/i915/i915_program.c
index e7908bd..3902c69 100644
--- a/src/mesa/drivers/dri/i915/i915_program.c
+++ b/src/mesa/drivers/dri/i915/i915_program.c
@@ -245,7 +245,7 @@ GLuint i915_emit_texld( struct i915_fragment_program *p,
    }
    else {
       assert(GET_UREG_TYPE(dest) != REG_TYPE_CONST);
-      assert(dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
+      assert(dest == UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
       /* Can't use unsaved temps for coords, as the phase boundary would result
        * in the contents becoming undefined.
        */
diff --git a/src/mesa/drivers/dri/i915/i915_texstate.c b/src/mesa/drivers/dri/i915/i915_texstate.c
index de25848..825f1db 100644
--- a/src/mesa/drivers/dri/i915/i915_texstate.c
+++ b/src/mesa/drivers/dri/i915/i915_texstate.c
@@ -196,10 +196,11 @@ i915_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
 	 state[I915_TEXREG_MS3] |= MS3_TILE_WALK;
    }
 
-   /* We get one field with fraction bits to cover the maximum addressable (smallest
-    * resolution) LOD.  Use it to cover both MAX_LEVEL and MAX_LOD.
+   /* We get one field with fraction bits for the maximum addressable
+    * (lowest resolution) LOD.  Use it to cover both MAX_LEVEL and
+    * MAX_LOD.
     */
-   maxlod = MIN2(tObj->MaxLod, tObj->MaxLevel - tObj->BaseLevel);
+   maxlod = MIN2(tObj->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
    state[I915_TEXREG_MS4] =
       ((((pitch / 4) - 1) << MS4_PITCH_SHIFT) |
        MS4_CUBE_FACE_ENA_MASK |
diff --git a/src/mesa/drivers/dri/i915/intel_render.c b/src/mesa/drivers/dri/i915/intel_render.c
index 410052b..ec20939 100644
--- a/src/mesa/drivers/dri/i915/intel_render.c
+++ b/src/mesa/drivers/dri/i915/intel_render.c
@@ -117,7 +117,7 @@ intelDmaPrimitive(struct intel_context *intel, GLenum prim)
    intel_set_prim(intel, hw_prim[prim]);
 }
 
-static inline GLuint intel_get_vb_max(struct intel_context *intel)
+static INLINE GLuint intel_get_vb_max(struct intel_context *intel)
 {
    GLuint ret;
 
@@ -129,7 +129,7 @@ static inline GLuint intel_get_vb_max(struct intel_context *intel)
    return ret;
 }
 
-static inline GLuint intel_get_current_max(struct intel_context *intel)
+static INLINE GLuint intel_get_current_max(struct intel_context *intel)
 {
 
    if (intel->intelScreen->no_vbo)
diff --git a/src/mesa/drivers/dri/i965/brw_disasm.c b/src/mesa/drivers/dri/i965/brw_disasm.c
index 9fef230..130bd0f 100644
--- a/src/mesa/drivers/dri/i965/brw_disasm.c
+++ b/src/mesa/drivers/dri/i965/brw_disasm.c
@@ -365,6 +365,7 @@ static int format (FILE *f, char *format, ...)
     va_start (args, format);
 
     vsnprintf (buf, sizeof (buf) - 1, format, args);
+    va_end (args);
     string (f, buf);
     return 0;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_draw_upload.c b/src/mesa/drivers/dri/i965/brw_draw_upload.c
index 271a88d..c66f43a 100644
--- a/src/mesa/drivers/dri/i965/brw_draw_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_draw_upload.c
@@ -249,8 +249,10 @@ static void wrap_buffers( struct brw_context *brw,
     */
    /* DON'T DO THIS AS IF WE HAVE TO RE-ORG MEMORY WE NEED SOMEWHERE WITH
       FAKE TO PUSH THIS STUFF */
-//   if (!brw->intel.ttm)
-//      dri_bo_fake_disable_backing_store(brw->vb.upload.bo, NULL, NULL);
+   /*
+   if (!brw->intel.ttm)
+      dri_bo_fake_disable_backing_store(brw->vb.upload.bo, NULL, NULL);
+    */
 }
 
 static void get_space( struct brw_context *brw,
diff --git a/src/mesa/drivers/dri/i965/brw_eu_emit.c b/src/mesa/drivers/dri/i965/brw_eu_emit.c
index 7ceabba..c8fb0a2 100644
--- a/src/mesa/drivers/dri/i965/brw_eu_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_eu_emit.c
@@ -199,7 +199,7 @@ void brw_set_src1( struct brw_instruction *insn,
        * in the future:
        */
       assert (reg.address_mode == BRW_ADDRESS_DIRECT);
-      //assert (reg.file == BRW_GENERAL_REGISTER_FILE);
+      /* assert (reg.file == BRW_GENERAL_REGISTER_FILE); */
 
       if (insn->header.access_mode == BRW_ALIGN_1) {
 	 insn->bits3.da1.src1_subreg_nr = reg.subnr;
@@ -853,7 +853,7 @@ void brw_land_fwd_jump(struct brw_compile *p,
        jmpi = 2;
 
    assert(jmp_insn->header.opcode == BRW_OPCODE_JMPI);
-   assert(jmp_insn->bits1.da1.src1_reg_file = BRW_IMMEDIATE_VALUE);
+   assert(jmp_insn->bits1.da1.src1_reg_file == BRW_IMMEDIATE_VALUE);
 
    jmp_insn->bits3.ud = jmpi * ((landing - jmp_insn) - 1);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index b129b1f..14d5319 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -35,7 +35,7 @@
 
 #include "brw_context.h"
 
-static inline void
+static INLINE void
 brw_add_validated_bo(struct brw_context *brw, dri_bo *bo)
 {
    assert(brw->state.validated_bo_count < ARRAY_SIZE(brw->state.validated_bos));
diff --git a/src/mesa/drivers/dri/i965/brw_wm_emit.c b/src/mesa/drivers/dri/i965/brw_wm_emit.c
index 5390fd2..c6d10f5 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_emit.c
@@ -692,7 +692,7 @@ void emit_xpd(struct brw_compile *p,
 {
    GLuint i;
 
-   assert(!(mask & WRITEMASK_W) == WRITEMASK_X);
+   assert((mask & WRITEMASK_W) != WRITEMASK_W);
    
    for (i = 0 ; i < 3; i++) {
       if (mask & (1<<i)) {
@@ -1084,7 +1084,7 @@ static void emit_kil_nv( struct brw_wm_compile *c )
 
    brw_push_insn_state(p);
    brw_set_mask_control(p, BRW_MASK_DISABLE);
-   brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); //IMASK
+   brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); /* IMASK */
    brw_AND(p, r0uw, c->emit_mask_reg, r0uw);
    brw_pop_insn_state(p);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm_glsl.c b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
index e8c2cb6..7e5533e 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_glsl.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
@@ -743,7 +743,7 @@ static void emit_kil(struct brw_wm_compile *c)
     struct brw_reg depth = retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UW);
     brw_push_insn_state(p);
     brw_set_mask_control(p, BRW_MASK_DISABLE);
-    brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); //IMASK
+    brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); /* IMASK */
     brw_AND(p, depth, c->emit_mask_reg, depth);
     brw_pop_insn_state(p);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
index 8335e5a..afb36b7 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
@@ -522,7 +522,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       GLubyte color_mask[4];
       GLboolean color_blend;
       uint32_t tiling;
-      uint32_t draw_offset;
+      uint32_t draw_x;
+      uint32_t draw_y;
    } key;
 
    memset(&key, 0, sizeof(key));
@@ -564,7 +565,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       }
       key.pitch = region->pitch;
       key.cpp = region->cpp;
-      key.draw_offset = region->draw_offset; /* cur 3d or cube face offset */
+      key.draw_x = region->draw_x;
+      key.draw_y = region->draw_y;
    } else {
       key.surface_type = BRW_SURFACE_NULL;
       key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
@@ -572,7 +574,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       key.width = 1;
       key.height = 1;
       key.cpp = 4;
-      key.draw_offset = 0;
+      key.draw_x = 0;
+      key.draw_y = 0;
    }
    /* _NEW_COLOR */
    memcpy(key.color_mask, ctx->Color.ColorMask,
@@ -602,25 +605,32 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       surf.ss0.surface_format = key.surface_format;
       surf.ss0.surface_type = key.surface_type;
       if (key.tiling == I915_TILING_NONE) {
-	 surf.ss1.base_addr = key.draw_offset;
+	 surf.ss1.base_addr = (key.draw_x + key.draw_y * key.pitch) * key.cpp;
       } else {
-	 uint32_t tile_offset = key.draw_offset % 4096;
-
-	 surf.ss1.base_addr = key.draw_offset - tile_offset;
-
-	 assert(BRW_IS_G4X(brw) || tile_offset == 0);
-	 if (BRW_IS_G4X(brw)) {
-	    if (key.tiling == I915_TILING_X) {
-	       /* Note that the low bits of these fields are missing, so
-		* there's the possibility of getting in trouble.
-		*/
-	       surf.ss5.x_offset = (tile_offset % 512) / key.cpp / 4;
-	       surf.ss5.y_offset = tile_offset / 512 / 2;
-	    } else {
-	       surf.ss5.x_offset = (tile_offset % 128) / key.cpp / 4;
-	       surf.ss5.y_offset = tile_offset / 128 / 2;
-	    }
+	 uint32_t tile_base, tile_x, tile_y;
+	 uint32_t pitch = key.pitch * key.cpp;
+
+	 if (key.tiling == I915_TILING_X) {
+	    tile_x = key.draw_x % (512 / key.cpp);
+	    tile_y = key.draw_y % 8;
+	    tile_base = ((key.draw_y / 8) * (8 * pitch));
+	    tile_base += (key.draw_x - tile_x) / (512 / key.cpp) * 4096;
+	 } else {
+	    /* Y */
+	    tile_x = key.draw_x % (128 / key.cpp);
+	    tile_y = key.draw_y % 32;
+	    tile_base = ((key.draw_y / 32) * (32 * pitch));
+	    tile_base += (key.draw_x - tile_x) / (128 / key.cpp) * 4096;
 	 }
+	 assert(BRW_IS_G4X(brw) || (tile_x == 0 && tile_y == 0));
+	 assert(tile_x % 4 == 0);
+	 assert(tile_y % 2 == 0);
+	 /* Note that the low bits of these fields are missing, so
+	  * there's the possibility of getting in trouble.
+	  */
+	 surf.ss1.base_addr = tile_base;
+	 surf.ss5.x_offset = tile_x / 4;
+	 surf.ss5.y_offset = tile_y / 2;
       }
       if (region_bo != NULL)
 	 surf.ss1.base_addr += region_bo->offset; /* reloc */
diff --git a/src/mesa/drivers/dri/intel/intel_context.h b/src/mesa/drivers/dri/intel/intel_context.h
index eb7be7d..1afec09 100644
--- a/src/mesa/drivers/dri/intel/intel_context.h
+++ b/src/mesa/drivers/dri/intel/intel_context.h
@@ -354,14 +354,14 @@ extern char *__progname;
 #define ALIGN(value, alignment)  ((value + alignment - 1) & ~(alignment - 1))
 #define IS_POWER_OF_TWO(val) (((val) & (val - 1)) == 0)
 
-static inline uint32_t
+static INLINE uint32_t
 U_FIXED(float value, uint32_t frac_bits)
 {
    value *= (1 << frac_bits);
    return value < 0 ? 0 : value;
 }
 
-static inline uint32_t
+static INLINE uint32_t
 S_FIXED(float value, uint32_t frac_bits)
 {
    return value * (1 << frac_bits);
@@ -588,7 +588,7 @@ is_power_of_two(uint32_t value)
    return (value & (value - 1)) == 0;
 }
 
-static inline void
+static INLINE void
 intel_bo_map_gtt_preferred(struct intel_context *intel,
 			   drm_intel_bo *bo,
 			   GLboolean write)
@@ -599,7 +599,7 @@ intel_bo_map_gtt_preferred(struct intel_context *intel,
       drm_intel_bo_map(bo, write);
 }
 
-static inline void
+static INLINE void
 intel_bo_unmap_gtt_preferred(struct intel_context *intel,
 			     drm_intel_bo *bo)
 {
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
index 204a233..19ca515 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
@@ -32,6 +32,7 @@
 #include "main/mtypes.h"
 #include "main/macros.h"
 #include "main/bufferobj.h"
+#include "main/polygon.h"
 #include "main/pixelstore.h"
 #include "main/polygon.h"
 #include "main/state.h"
@@ -165,7 +166,7 @@ static GLuint get_bitmap_rect(GLsizei width, GLsizei height,
  * Returns the low Y value of the vertical range given, flipped according to
  * whether the framebuffer is or not.
  */
-static inline int
+static INLINE int
 y_flip(struct gl_framebuffer *fb, int y, int height)
 {
    if (fb->Name != 0)
diff --git a/src/mesa/drivers/dri/intel/intel_tex_copy.c b/src/mesa/drivers/dri/intel/intel_tex_copy.c
index 767d04d..ef5aed3 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_copy.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_copy.c
@@ -109,7 +109,7 @@ do_copy_texsubimage(struct intel_context *intel,
       return GL_FALSE;
    }
 
-   //   intelFlush(ctx);
+   /* intelFlush(ctx); */
    LOCK_HARDWARE(intel);
    {
       drm_intel_bo *dst_bo = intel_region_buffer(intel,
@@ -160,13 +160,14 @@ do_copy_texsubimage(struct intel_context *intel,
 			     intelImage->mt->cpp,
 			     src_pitch,
 			     src->buffer,
-			     src->draw_offset,
+			     0,
 			     src->tiling,
 			     intelImage->mt->pitch,
 			     dst_bo,
 			     0,
 			     intelImage->mt->region->tiling,
-			     x, y, image_x + dstx, image_y + dsty,
+			     src->draw_x + x, src->draw_y + y,
+			     image_x + dstx, image_y + dsty,
 			     width, height,
 			     GL_COPY)) {
 	 UNLOCK_HARDWARE(intel);
diff --git a/src/mesa/drivers/dri/r300/compiler/memory_pool.c b/src/mesa/drivers/dri/r300/compiler/memory_pool.c
index 37aa2b6..76c7c60 100644
--- a/src/mesa/drivers/dri/r300/compiler/memory_pool.c
+++ b/src/mesa/drivers/dri/r300/compiler/memory_pool.c
@@ -71,12 +71,14 @@ static void refill_pool(struct memory_pool * pool)
 void * memory_pool_malloc(struct memory_pool * pool, unsigned int bytes)
 {
 	if (bytes < POOL_LARGE_ALLOC) {
+		void * ptr;
+
 		if (pool->head + bytes > pool->end)
 			refill_pool(pool);
 
 		assert(pool->head + bytes <= pool->end);
 
-		void * ptr = pool->head;
+		ptr = pool->head;
 
 		pool->head += bytes;
 		pool->head = (unsigned char*)(((unsigned long)pool->head + POOL_ALIGN - 1) & ~(POOL_ALIGN - 1));
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_code.c b/src/mesa/drivers/dri/r300/compiler/radeon_code.c
index 1a3d8bb..853b2be 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_code.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_code.c
@@ -143,7 +143,8 @@ unsigned rc_constants_add_immediate_scalar(struct rc_constant_list * c, float da
 
 	for(index = 0; index < c->Count; ++index) {
 		if (c->Constants[index].Type == RC_CONSTANT_IMMEDIATE) {
-			for(unsigned comp = 0; comp < c->Constants[index].Size; ++comp) {
+			unsigned comp;
+			for(comp = 0; comp < c->Constants[index].Size; ++comp) {
 				if (c->Constants[index].u.Immediate[comp] == data) {
 					*swizzle = RC_MAKE_SWIZZLE(comp, comp, comp, comp);
 					return index;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c b/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
index c0e7a7f..41ea23e 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
@@ -232,12 +232,16 @@ void rc_copy_output(struct radeon_compiler * c, unsigned output, unsigned dup_ou
 void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsigned new_input)
 {
 	unsigned tempregi = rc_find_free_temporary(c);
+	struct rc_instruction * inst_rcp;
+	struct rc_instruction * inst_mul;
+	struct rc_instruction * inst_mad;
+	struct rc_instruction * inst;
 
 	c->Program.InputsRead &= ~(1 << wpos);
 	c->Program.InputsRead |= 1 << new_input;
 
 	/* perspective divide */
-	struct rc_instruction * inst_rcp = rc_insert_new_instruction(c, &c->Program.Instructions);
+	inst_rcp = rc_insert_new_instruction(c, &c->Program.Instructions);
 	inst_rcp->U.I.Opcode = RC_OPCODE_RCP;
 
 	inst_rcp->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -248,7 +252,7 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_rcp->U.I.SrcReg[0].Index = new_input;
 	inst_rcp->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_WWWW;
 
-	struct rc_instruction * inst_mul = rc_insert_new_instruction(c, inst_rcp);
+	inst_mul = rc_insert_new_instruction(c, inst_rcp);
 	inst_mul->U.I.Opcode = RC_OPCODE_MUL;
 
 	inst_mul->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -263,7 +267,7 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_mul->U.I.SrcReg[1].Swizzle = RC_SWIZZLE_WWWW;
 
 	/* viewport transformation */
-	struct rc_instruction * inst_mad = rc_insert_new_instruction(c, inst_mul);
+	inst_mad = rc_insert_new_instruction(c, inst_mul);
 	inst_mad->U.I.Opcode = RC_OPCODE_MAD;
 
 	inst_mad->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -282,7 +286,6 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_mad->U.I.SrcReg[2].Index = inst_mad->U.I.SrcReg[1].Index;
 	inst_mad->U.I.SrcReg[2].Swizzle = RC_MAKE_SWIZZLE(RC_SWIZZLE_X, RC_SWIZZLE_Y, RC_SWIZZLE_Z, RC_SWIZZLE_ZERO);
 
-	struct rc_instruction * inst;
 	for (inst = inst_mad->Next; inst != &c->Program.Instructions; inst = inst->Next) {
 		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);
 		unsigned i;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_program.c b/src/mesa/drivers/dri/r300/compiler/radeon_program.c
index 0dbc538..a3c41d7 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_program.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_program.c
@@ -94,10 +94,11 @@ unsigned int rc_find_free_temporary(struct radeon_compiler * c)
 {
 	char used[RC_REGISTER_MAX_INDEX];
 	unsigned int i;
+	struct rc_instruction * rcinst;
 
 	memset(used, 0, sizeof(used));
 
-	for (struct rc_instruction * rcinst = c->Program.Instructions.Next; rcinst != &c->Program.Instructions; rcinst = rcinst->Next) {
+	for (rcinst = c->Program.Instructions.Next; rcinst != &c->Program.Instructions; rcinst = rcinst->Next) {
 		const struct rc_sub_instruction *inst = &rcinst->U.I;
 		const struct rc_opcode_info *opcode = rc_get_opcode_info(inst->Opcode);
 		unsigned int k;
@@ -168,8 +169,9 @@ void rc_remove_instruction(struct rc_instruction * inst)
 unsigned int rc_recompute_ips(struct radeon_compiler * c)
 {
 	unsigned int ip = 0;
+	struct rc_instruction * inst;
 
-	for(struct rc_instruction * inst = c->Program.Instructions.Next;
+	for(inst = c->Program.Instructions.Next;
 	    inst != &c->Program.Instructions;
 	    inst = inst->Next) {
 		inst->IP = ip++;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c b/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
index ced66af..b5c08ae 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
@@ -267,9 +267,9 @@ static void transform_LIT(struct radeon_compiler* c,
 	temp = inst->U.I.DstReg.Index;
 	srctemp = srcreg(RC_FILE_TEMPORARY, temp);
 
-	// tmp.x = max(0.0, Src.x);
-	// tmp.y = max(0.0, Src.y);
-	// tmp.w = clamp(Src.z, -128+eps, 128-eps);
+	/* tmp.x = max(0.0, Src.x); */
+	/* tmp.y = max(0.0, Src.y); */
+	/* tmp.w = clamp(Src.z, -128+eps, 128-eps); */
 	emit2(c, inst->Prev, RC_OPCODE_MAX, 0,
 		dstregtmpmask(temp, RC_MASK_XYW),
 		inst->U.I.SrcReg[0],
@@ -280,7 +280,7 @@ static void transform_LIT(struct radeon_compiler* c,
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W),
 		negate(srcregswz(RC_FILE_CONSTANT, constant, constant_swizzle)));
 
-	// tmp.w = Pow(tmp.y, tmp.w)
+	/* tmp.w = Pow(tmp.y, tmp.w) */
 	emit1(c, inst->Prev, RC_OPCODE_LG2, 0,
 		dstregtmpmask(temp, RC_MASK_W),
 		swizzle(srctemp, RC_SWIZZLE_Y, RC_SWIZZLE_Y, RC_SWIZZLE_Y, RC_SWIZZLE_Y));
@@ -292,14 +292,14 @@ static void transform_LIT(struct radeon_compiler* c,
 		dstregtmpmask(temp, RC_MASK_W),
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W));
 
-	// tmp.z = (tmp.x > 0) ? tmp.w : 0.0
+	/* tmp.z = (tmp.x > 0) ? tmp.w : 0.0 */
 	emit3(c, inst->Prev, RC_OPCODE_CMP, inst->U.I.SaturateMode,
 		dstregtmpmask(temp, RC_MASK_Z),
 		negate(swizzle(srctemp, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X)),
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W),
 		builtin_zero);
 
-	// tmp.x, tmp.y, tmp.w = 1.0, tmp.x, 1.0
+	/* tmp.x, tmp.y, tmp.w = 1.0, tmp.x, 1.0 */
 	emit1(c, inst->Prev, RC_OPCODE_MOV, inst->U.I.SaturateMode,
 		dstregtmpmask(temp, RC_MASK_XYW),
 		swizzle(srctemp, RC_SWIZZLE_ONE, RC_SWIZZLE_X, RC_SWIZZLE_ONE, RC_SWIZZLE_ONE));
@@ -533,16 +533,16 @@ static void sincos_constants(struct radeon_compiler* c, unsigned int *constants)
 {
 	static const float SinCosConsts[2][4] = {
 		{
-			1.273239545,		// 4/PI
-			-0.405284735,		// -4/(PI*PI)
-			3.141592654,		// PI
-			0.2225			// weight
+			1.273239545,		/* 4/PI */
+			-0.405284735,		/* -4/(PI*PI) */
+			3.141592654,		/* PI */
+			0.2225			/* weight */
 		},
 		{
 			0.75,
 			0.5,
-			0.159154943,		// 1/(2*PI)
-			6.283185307		// 2*PI
+			0.159154943,		/* 1/(2*PI) */
+			6.283185307		/* 2*PI */
 		}
 	};
 	int i;
@@ -602,9 +602,9 @@ int radeonTransformTrigSimple(struct radeon_compiler* c,
 	sincos_constants(c, constants);
 
 	if (inst->U.I.Opcode == RC_OPCODE_COS) {
-		// MAD tmp.x, src, 1/(2*PI), 0.75
-		// FRC tmp.x, tmp.x
-		// MAD tmp.z, tmp.x, 2*PI, -PI
+		/* MAD tmp.x, src, 1/(2*PI), 0.75 */
+		/* FRC tmp.x, tmp.x */
+		/* MAD tmp.z, tmp.x, 2*PI, -PI */
 		emit3(c, inst->Prev, RC_OPCODE_MAD, 0, dstregtmpmask(tempreg, RC_MASK_W),
 			swizzle(inst->U.I.SrcReg[0], RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X),
 			swizzle(srcreg(RC_FILE_CONSTANT, constants[1]), RC_SWIZZLE_Z, RC_SWIZZLE_Z, RC_SWIZZLE_Z, RC_SWIZZLE_Z),
diff --git a/src/mesa/drivers/dri/r600/r600_context.h b/src/mesa/drivers/dri/r600/r600_context.h
index 394fd75..94662ab 100644
--- a/src/mesa/drivers/dri/r600/r600_context.h
+++ b/src/mesa/drivers/dri/r600/r600_context.h
@@ -108,6 +108,7 @@ typedef struct StreamDesc
 	GLint   size;   //number of data element
 	GLenum  type;  //data element type
 	GLsizei stride;
+	GLenum  format; // GL_RGBA,GLBGRA 
 
 	struct radeon_bo *bo;
 	GLint  bo_offset;
diff --git a/src/mesa/drivers/dri/r600/r600_texstate.c b/src/mesa/drivers/dri/r600/r600_texstate.c
index 4ec315b..fb5abdc 100644
--- a/src/mesa/drivers/dri/r600/r600_texstate.c
+++ b/src/mesa/drivers/dri/r600/r600_texstate.c
@@ -91,7 +91,7 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
 		 FORMAT_COMP_Y_shift, FORMAT_COMP_Y_mask);
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
-		 FORMAT_COMP_X_shift, FORMAT_COMP_Z_mask);
+		 FORMAT_COMP_Z_shift, FORMAT_COMP_Z_mask);
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
 		 FORMAT_COMP_W_shift, FORMAT_COMP_W_mask);
 
@@ -357,37 +357,37 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_RGBA_FLOAT16:
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_RGB_FLOAT32: /* X, Y, Z, ONE */
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
@@ -396,11 +396,11 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
@@ -461,26 +461,26 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_INTENSITY_FLOAT32: /* X, X, X, X */
@@ -706,8 +706,10 @@ static void setup_hardware_state(context_t *rmesa, struct gl_texture_object *tex
 	SETfield(t->SQ_TEX_RESOURCE1, firstImage->Height - 1,
 		 TEX_HEIGHT_shift, TEX_HEIGHT_mask);
 
+	t->SQ_TEX_RESOURCE2 = get_base_teximage_offset(t) / 256;
+
 	if ((t->maxLod - t->minLod) > 0) {
-		t->SQ_TEX_RESOURCE3 = t->mt->levels[t->minLod].size / 256;
+		t->SQ_TEX_RESOURCE3 = radeon_miptree_image_offset(t->mt, 0, t->minLod + 1) / 256;
 		SETfield(t->SQ_TEX_RESOURCE4, 0, BASE_LEVEL_shift, BASE_LEVEL_mask);
 		SETfield(t->SQ_TEX_RESOURCE5, t->maxLod - t->minLod, LAST_LEVEL_shift, LAST_LEVEL_mask);
 	}
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.c b/src/mesa/drivers/dri/r600/r700_assembler.c
index 67e0ee7..b0b3892 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.c
+++ b/src/mesa/drivers/dri/r600/r700_assembler.c
@@ -798,6 +798,7 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
                                        GLubyte             element,
                                        GLuint              _signed,
                                        GLboolean           normalize,
+                                       GLenum              format,
                                        VTX_FETCH_METHOD  * pFetchMethod)
 {
     GLuint client_size_inbyte;
@@ -846,10 +847,21 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
 	vfetch_instruction_ptr->m_Word0.f.src_sel_x        = SQ_SEL_X;
 	vfetch_instruction_ptr->m_Word0.f.mega_fetch_count = mega_fetch_count;
 
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_X;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_Z;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+	if(format == GL_BGRA)
+	{
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_Z;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_X;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+	}
+	else
+	{
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_X;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_Z;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+
+	}
 
 	vfetch_instruction_ptr->m_Word1.f.use_const_fields = 1;
     vfetch_instruction_ptr->m_Word1.f.data_format      = data_format;
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.h b/src/mesa/drivers/dri/r600/r700_assembler.h
index c66db50..ee12582 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.h
+++ b/src/mesa/drivers/dri/r600/r700_assembler.h
@@ -422,6 +422,7 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
                                        GLubyte             element,
                                        GLuint              _signed,
                                        GLboolean           normalize,
+                                       GLenum              format,
                                        VTX_FETCH_METHOD  * pFetchMethod);
 GLboolean cleanup_vfetch_instructions(r700_AssemblerBase* pAsm);
 GLuint gethelpr(r700_AssemblerBase* pAsm);
diff --git a/src/mesa/drivers/dri/r600/r700_chip.c b/src/mesa/drivers/dri/r600/r700_chip.c
index 02c56b9..7f1894d 100644
--- a/src/mesa/drivers/dri/r600/r700_chip.c
+++ b/src/mesa/drivers/dri/r600/r700_chip.c
@@ -54,14 +54,11 @@ static void r700SendTexState(GLcontext *ctx, struct radeon_state_atom *atom)
 	for (i = 0; i < R700_TEXTURE_NUMBERUNITS; i++) {
 		if (ctx->Texture.Unit[i]._ReallyEnabled) {
 			radeonTexObj *t = r700->textures[i];
-			uint32_t offset;
 			if (t) {
 				if (!t->image_override) {
 					bo = t->mt->bo;
-					offset = get_base_teximage_offset(t);
 				} else {
 					bo = t->bo;
-					offset = 0;
 				}
 				if (bo) {
 
@@ -81,7 +78,7 @@ static void r700SendTexState(GLcontext *ctx, struct radeon_state_atom *atom)
 					R600_OUT_BATCH(r700->textures[i]->SQ_TEX_RESOURCE6);
 					R600_OUT_BATCH_RELOC(r700->textures[i]->SQ_TEX_RESOURCE2,
 							     bo,
-							     offset,
+							     r700->textures[i]->SQ_TEX_RESOURCE2,
 							     RADEON_GEM_DOMAIN_GTT|RADEON_GEM_DOMAIN_VRAM, 0, 0);
 					R600_OUT_BATCH_RELOC(r700->textures[i]->SQ_TEX_RESOURCE3,
 							     bo,
diff --git a/src/mesa/drivers/dri/r600/r700_vertprog.c b/src/mesa/drivers/dri/r600/r700_vertprog.c
index ffc6068..4ca5ce6 100644
--- a/src/mesa/drivers/dri/r600/r700_vertprog.c
+++ b/src/mesa/drivers/dri/r600/r700_vertprog.c
@@ -179,7 +179,8 @@ GLboolean Process_Vertex_Program_Vfetch_Instructions2(
                                       context->stream_desc[i].size,
                                       context->stream_desc[i].element,
                                       context->stream_desc[i]._signed,
-                                      context->stream_desc[i].normalize,						            
+                                      context->stream_desc[i].normalize,
+                                      context->stream_desc[i].format,
                                      &vtxFetchMethod);
     }
 
@@ -308,6 +309,7 @@ struct r700_vertex_program* r700TranslateVertexShader(GLcontext *ctx,
 		vp->aos_desc[i].size   = context->stream_desc[i].size;
 		vp->aos_desc[i].stride = context->stream_desc[i].stride;
 		vp->aos_desc[i].type   = context->stream_desc[i].type;
+		vp->aos_desc[i].format = context->stream_desc[i].format;
 	}
 
 	if (context->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV770)
@@ -368,7 +370,8 @@ void r700SelectVertexShader(GLcontext *ctx)
 	match = GL_TRUE;
 	for(i=0; i<context->nNumActiveAos; i++)
 	{
-		if (vp->aos_desc[i].size != context->stream_desc[i].size)
+		if (vp->aos_desc[i].size != context->stream_desc[i].size ||
+		    vp->aos_desc[i].format != context->stream_desc[i].format)
 		{
 			match = GL_FALSE;
 			break;
@@ -471,6 +474,7 @@ static void r700TranslateAttrib(GLcontext *ctx, GLuint unLoc, int count, const s
 	pStreamDesc->size = input->Size;
 	pStreamDesc->dst_loc = context->nNumActiveAos;
 	pStreamDesc->element = unLoc;
+	pStreamDesc->format = input->Format;
 
 	switch (pStreamDesc->type) 
 	{ //GetSurfaceFormat
diff --git a/src/mesa/drivers/dri/r600/r700_vertprog.h b/src/mesa/drivers/dri/r600/r700_vertprog.h
index 00824c2..645c9ac 100644
--- a/src/mesa/drivers/dri/r600/r700_vertprog.h
+++ b/src/mesa/drivers/dri/r600/r700_vertprog.h
@@ -39,6 +39,7 @@ typedef struct ArrayDesc //TEMP
 	GLint size;   //number of data element
 	GLenum type;  //data element type
 	GLsizei stride;
+	GLenum format; //GL_RGBA or GL_BGRA
 } ArrayDesc;
 
 struct r700_vertex_program 
diff --git a/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c b/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
index 45b608a..bf46eb8 100644
--- a/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
+++ b/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
@@ -182,7 +182,7 @@ static int cs_begin(struct radeon_cs_int *cs,
         uint32_t tmp, *ptr;
 	int num = (ndw > 0x3FF) ? ndw : 0x3FF;
 
-        tmp = (cs->cdw + 1 + num) & (~num);
+        tmp = (cs->cdw + ndw + 0x3ff) & (~0x3ff);
         ptr = (uint32_t*)realloc(cs->packets, 4 * tmp);
         if (ptr == NULL) {
             return -ENOMEM;
diff --git a/src/mesa/drivers/dri/radeon/radeon_tcl.c b/src/mesa/drivers/dri/radeon/radeon_tcl.c
index b334ea0..cd02bfb 100644
--- a/src/mesa/drivers/dri/radeon/radeon_tcl.c
+++ b/src/mesa/drivers/dri/radeon/radeon_tcl.c
@@ -412,6 +412,7 @@ static GLuint radeonEnsureEmitSize( GLcontext * ctx , GLuint inputs )
 	space_required += vbuf;
       else
 	space_required += index + elts;
+      space_required += VB->Primitive[i].count * 3;
       space_required += AOS_BUFSZ(nr_aos);
     }
     space_required += SCISSOR_BUFSZ;
diff --git a/src/mesa/drivers/dri/sis/sis_context.c b/src/mesa/drivers/dri/sis/sis_context.c
index f501e7a..346e8c5 100644
--- a/src/mesa/drivers/dri/sis/sis_context.c
+++ b/src/mesa/drivers/dri/sis/sis_context.c
@@ -83,6 +83,7 @@ static struct dri_extension card_extensions[] =
     { NULL,                                NULL }
 };
 
+#if 0
 static struct dri_extension card_extensions_6326[] =
 {
     /*{ "GL_ARB_texture_border_clamp",       NULL },*/
@@ -90,6 +91,7 @@ static struct dri_extension card_extensions_6326[] =
     /*{ "GL_MESA_ycbcr_texture",             NULL },*/
     { NULL,                                NULL }
 };
+#endif
 
 static const struct dri_debug_control debug_control[] =
 {
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_dd.c b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
index 8472df6..ed8a331 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_dd.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
@@ -91,7 +91,7 @@ static const GLubyte *tdfxDDGetString( GLcontext *ctx, GLenum name )
       else {
 	 /* unexpected result: replace spaces with hyphens */
 	 int i;
-	 for (i = 0; hardware[i] && (i < sizeof(hardware)); i++) {
+	 for (i = 0; i < sizeof(hardware) && hardware[i]; i++) {
 	    if (hardware[i] == ' ' || hardware[i] == '\t') {
 	       hardware[i] = '-';
 	    }
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_tex.c b/src/mesa/drivers/dri/tdfx/tdfx_tex.c
index 0aa09e7..e31ae97 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_tex.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_tex.c
@@ -1572,7 +1572,7 @@ tdfxCompressedTexImage2D (GLcontext *ctx, GLenum target,
     tdfxTexInfo *ti;
     tdfxMipMapLevel *mml;
     gl_format mesaFormat;
-    GLuint compressedSize;
+    GLuint compressedSize = 0;
 
     if (TDFX_DEBUG & DEBUG_VERBOSE_DRI) {
         fprintf(stderr, "tdfxCompressedTexImage2D: id=%d int 0x%x  %dx%d\n",
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_texstate.c b/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
index bbd2c8c..3f73787 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
@@ -1314,7 +1314,7 @@ SetupDoubleTexEnvVoodoo3(GLcontext *ctx, int tmu0,
       fxMesa->TexCombine[0].InvertRGB = FXFALSE;
       fxMesa->TexCombine[0].InvertAlpha = FXFALSE;
 
-      if ((baseFormat0 == GL_RGB) && (baseFormat0 == GL_LUMINANCE)) {
+      if ((baseFormat0 == GL_RGB) || (baseFormat0 == GL_LUMINANCE)) {
          fxMesa->AlphaCombine.Function = GR_COMBINE_FUNCTION_LOCAL;
          fxMesa->AlphaCombine.Factor = GR_COMBINE_FACTOR_NONE;
          fxMesa->AlphaCombine.Local = locala;
diff --git a/src/mesa/main/attrib.c b/src/mesa/main/attrib.c
index 246c552..a14f71c 100644
--- a/src/mesa/main/attrib.c
+++ b/src/mesa/main/attrib.c
@@ -1043,22 +1043,39 @@ _mesa_PopAttrib(void)
                   _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
 	       
                for (i = 0; i < ctx->Const.MaxLights; i++) {
-		  const struct gl_light *l = &light->Light[i];
+                  const struct gl_light *l = &light->Light[i];
                   _mesa_set_enable(ctx, GL_LIGHT0 + i, l->Enabled);
-		  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
-		  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
-		  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
-		  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
-		  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
-		  _mesa_light(ctx, i, GL_SPOT_EXPONENT, &l->SpotExponent);
-		  _mesa_light(ctx, i, GL_SPOT_CUTOFF, &l->SpotCutoff);
-		  _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION,
-                              &l->ConstantAttenuation);
-		  _mesa_light(ctx, i, GL_LINEAR_ATTENUATION,
-                              &l->LinearAttenuation);
-		  _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION,
-                              &l->QuadraticAttenuation);
-               }
+                  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
+                  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
+                  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
+                  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
+                  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->SpotExponent;
+                     _mesa_light(ctx, i, GL_SPOT_EXPONENT, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->SpotCutoff;
+                     _mesa_light(ctx, i, GL_SPOT_CUTOFF, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->ConstantAttenuation;
+                     _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->LinearAttenuation;
+                     _mesa_light(ctx, i, GL_LINEAR_ATTENUATION, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->QuadraticAttenuation;
+                     _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION, p);
+                  }
+                }
                /* light model */
                _mesa_LightModelfv(GL_LIGHT_MODEL_AMBIENT,
                                   light->Model.Ambient);
diff --git a/src/mesa/main/dispatch.c b/src/mesa/main/dispatch.c
index 97d213e..eb0d1ff 100644
--- a/src/mesa/main/dispatch.c
+++ b/src/mesa/main/dispatch.c
@@ -37,8 +37,6 @@
  * \author Brian Paul <brian@precisioninsight.com>
  */
 
-#ifndef GLX_USE_APPLEGL
-
 #include "main/glheader.h"
 #include "main/compiler.h"
 #include "glapi/glapi.h"
@@ -92,5 +90,3 @@
 #include "glapi/glapitemp.h"
 
 #endif /* USE_X86_ASM */
-
-#endif /* !GLX_USE_APPLEGL */
diff --git a/src/mesa/main/enums.c b/src/mesa/main/enums.c
index f9f4bc7..8a39401 100644
--- a/src/mesa/main/enums.c
+++ b/src/mesa/main/enums.c
@@ -1787,7 +1787,6 @@ LONGSTRING static const char enum_string_table[] =
    "GL_TEXTURE_WRAP_S\0"
    "GL_TEXTURE_WRAP_T\0"
    "GL_TIMEOUT_EXPIRED\0"
-   "GL_TIMEOUT_IGNORED\0"
    "GL_TIME_ELAPSED_EXT\0"
    "GL_TRACK_MATRIX_NV\0"
    "GL_TRACK_MATRIX_TRANSFORM_NV\0"
@@ -1919,7 +1918,7 @@ LONGSTRING static const char enum_string_table[] =
    "GL_ZOOM_Y\0"
    ;
 
-static const enum_elt all_enums[1881] =
+static const enum_elt all_enums[1880] =
 {
    {     0, 0x00000600 }, /* GL_2D */
    {     6, 0x00001407 }, /* GL_2_BYTES */
@@ -3672,147 +3671,146 @@ static const enum_elt all_enums[1881] =
    { 37686, 0x00002802 }, /* GL_TEXTURE_WRAP_S */
    { 37704, 0x00002803 }, /* GL_TEXTURE_WRAP_T */
    { 37722, 0x0000911B }, /* GL_TIMEOUT_EXPIRED */
-   { 37741, 0xFFFFFFFFFFFFFFFF }, /* GL_TIMEOUT_IGNORED */
-   { 37760, 0x000088BF }, /* GL_TIME_ELAPSED_EXT */
-   { 37780, 0x00008648 }, /* GL_TRACK_MATRIX_NV */
-   { 37799, 0x00008649 }, /* GL_TRACK_MATRIX_TRANSFORM_NV */
-   { 37828, 0x00001000 }, /* GL_TRANSFORM_BIT */
-   { 37845, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX */
-   { 37871, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX_ARB */
-   { 37901, 0x000088B7 }, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
-   { 37933, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
-   { 37963, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX_ARB */
-   { 37997, 0x0000862C }, /* GL_TRANSPOSE_NV */
-   { 38013, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX */
-   { 38044, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX_ARB */
-   { 38079, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX */
-   { 38107, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX_ARB */
-   { 38139, 0x00000004 }, /* GL_TRIANGLES */
-   { 38152, 0x00000006 }, /* GL_TRIANGLE_FAN */
-   { 38168, 0x00008615 }, /* GL_TRIANGLE_MESH_SUN */
-   { 38189, 0x00000005 }, /* GL_TRIANGLE_STRIP */
-   { 38207, 0x00000001 }, /* GL_TRUE */
-   { 38215, 0x00000CF5 }, /* GL_UNPACK_ALIGNMENT */
-   { 38235, 0x0000806E }, /* GL_UNPACK_IMAGE_HEIGHT */
-   { 38258, 0x00000CF1 }, /* GL_UNPACK_LSB_FIRST */
-   { 38278, 0x00000CF2 }, /* GL_UNPACK_ROW_LENGTH */
-   { 38299, 0x0000806D }, /* GL_UNPACK_SKIP_IMAGES */
-   { 38321, 0x00000CF4 }, /* GL_UNPACK_SKIP_PIXELS */
-   { 38343, 0x00000CF3 }, /* GL_UNPACK_SKIP_ROWS */
-   { 38363, 0x00000CF0 }, /* GL_UNPACK_SWAP_BYTES */
-   { 38384, 0x00009118 }, /* GL_UNSIGNALED */
-   { 38398, 0x00001401 }, /* GL_UNSIGNED_BYTE */
-   { 38415, 0x00008362 }, /* GL_UNSIGNED_BYTE_2_3_3_REV */
-   { 38442, 0x00008032 }, /* GL_UNSIGNED_BYTE_3_3_2 */
-   { 38465, 0x00001405 }, /* GL_UNSIGNED_INT */
-   { 38481, 0x00008036 }, /* GL_UNSIGNED_INT_10_10_10_2 */
-   { 38508, 0x000084FA }, /* GL_UNSIGNED_INT_24_8 */
-   { 38529, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_EXT */
-   { 38554, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_NV */
-   { 38578, 0x00008368 }, /* GL_UNSIGNED_INT_2_10_10_10_REV */
-   { 38609, 0x00008035 }, /* GL_UNSIGNED_INT_8_8_8_8 */
-   { 38633, 0x00008367 }, /* GL_UNSIGNED_INT_8_8_8_8_REV */
-   { 38661, 0x00008C17 }, /* GL_UNSIGNED_NORMALIZED */
-   { 38684, 0x00001403 }, /* GL_UNSIGNED_SHORT */
-   { 38702, 0x00008366 }, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
-   { 38732, 0x00008033 }, /* GL_UNSIGNED_SHORT_4_4_4_4 */
-   { 38758, 0x00008365 }, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
-   { 38788, 0x00008034 }, /* GL_UNSIGNED_SHORT_5_5_5_1 */
-   { 38814, 0x00008363 }, /* GL_UNSIGNED_SHORT_5_6_5 */
-   { 38838, 0x00008364 }, /* GL_UNSIGNED_SHORT_5_6_5_REV */
-   { 38866, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_APPLE */
-   { 38894, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_MESA */
-   { 38921, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
-   { 38953, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_MESA */
-   { 38984, 0x00008CA2 }, /* GL_UPPER_LEFT */
-   { 38998, 0x00002A20 }, /* GL_V2F */
-   { 39005, 0x00002A21 }, /* GL_V3F */
-   { 39012, 0x00008B83 }, /* GL_VALIDATE_STATUS */
-   { 39031, 0x00001F00 }, /* GL_VENDOR */
-   { 39041, 0x00001F02 }, /* GL_VERSION */
-   { 39052, 0x00008074 }, /* GL_VERTEX_ARRAY */
-   { 39068, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING */
-   { 39092, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING_APPLE */
-   { 39122, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
-   { 39153, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING_ARB */
-   { 39188, 0x0000808E }, /* GL_VERTEX_ARRAY_POINTER */
-   { 39212, 0x0000807A }, /* GL_VERTEX_ARRAY_SIZE */
-   { 39233, 0x0000807C }, /* GL_VERTEX_ARRAY_STRIDE */
-   { 39256, 0x0000807B }, /* GL_VERTEX_ARRAY_TYPE */
-   { 39277, 0x00008650 }, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
-   { 39304, 0x0000865A }, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
-   { 39332, 0x0000865B }, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
-   { 39360, 0x0000865C }, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
-   { 39388, 0x0000865D }, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
-   { 39416, 0x0000865E }, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
-   { 39444, 0x0000865F }, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
-   { 39472, 0x00008651 }, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
-   { 39499, 0x00008652 }, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
-   { 39526, 0x00008653 }, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
-   { 39553, 0x00008654 }, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
-   { 39580, 0x00008655 }, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
-   { 39607, 0x00008656 }, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
-   { 39634, 0x00008657 }, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
-   { 39661, 0x00008658 }, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
-   { 39688, 0x00008659 }, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
-   { 39715, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
-   { 39753, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB */
-   { 39795, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
-   { 39826, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB */
-   { 39861, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
-   { 39895, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB */
-   { 39933, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
-   { 39964, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB */
-   { 39999, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
-   { 40027, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB */
-   { 40059, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
-   { 40089, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB */
-   { 40123, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
-   { 40151, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB */
-   { 40183, 0x000086A7 }, /* GL_VERTEX_BLEND_ARB */
-   { 40203, 0x00008620 }, /* GL_VERTEX_PROGRAM_ARB */
-   { 40225, 0x0000864A }, /* GL_VERTEX_PROGRAM_BINDING_NV */
-   { 40254, 0x00008620 }, /* GL_VERTEX_PROGRAM_NV */
-   { 40275, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE */
-   { 40304, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_ARB */
-   { 40337, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_NV */
-   { 40369, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE */
-   { 40396, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_ARB */
-   { 40427, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_NV */
-   { 40457, 0x00008B31 }, /* GL_VERTEX_SHADER */
-   { 40474, 0x00008B31 }, /* GL_VERTEX_SHADER_ARB */
-   { 40495, 0x00008621 }, /* GL_VERTEX_STATE_PROGRAM_NV */
-   { 40522, 0x00000BA2 }, /* GL_VIEWPORT */
-   { 40534, 0x00000800 }, /* GL_VIEWPORT_BIT */
-   { 40550, 0x0000911D }, /* GL_WAIT_FAILED */
-   { 40565, 0x000086AD }, /* GL_WEIGHT_ARRAY_ARB */
-   { 40585, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
-   { 40616, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB */
-   { 40651, 0x000086AC }, /* GL_WEIGHT_ARRAY_POINTER_ARB */
-   { 40679, 0x000086AB }, /* GL_WEIGHT_ARRAY_SIZE_ARB */
-   { 40704, 0x000086AA }, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
-   { 40731, 0x000086A9 }, /* GL_WEIGHT_ARRAY_TYPE_ARB */
-   { 40756, 0x000086A6 }, /* GL_WEIGHT_SUM_UNITY_ARB */
-   { 40780, 0x000081D4 }, /* GL_WRAP_BORDER_SUN */
-   { 40799, 0x000088B9 }, /* GL_WRITE_ONLY */
-   { 40813, 0x000088B9 }, /* GL_WRITE_ONLY_ARB */
-   { 40831, 0x00001506 }, /* GL_XOR */
-   { 40838, 0x000085B9 }, /* GL_YCBCR_422_APPLE */
-   { 40857, 0x00008757 }, /* GL_YCBCR_MESA */
-   { 40871, 0x00000000 }, /* GL_ZERO */
-   { 40879, 0x00000D16 }, /* GL_ZOOM_X */
-   { 40889, 0x00000D17 }, /* GL_ZOOM_Y */
+   { 37741, 0x000088BF }, /* GL_TIME_ELAPSED_EXT */
+   { 37761, 0x00008648 }, /* GL_TRACK_MATRIX_NV */
+   { 37780, 0x00008649 }, /* GL_TRACK_MATRIX_TRANSFORM_NV */
+   { 37809, 0x00001000 }, /* GL_TRANSFORM_BIT */
+   { 37826, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX */
+   { 37852, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX_ARB */
+   { 37882, 0x000088B7 }, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
+   { 37914, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
+   { 37944, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX_ARB */
+   { 37978, 0x0000862C }, /* GL_TRANSPOSE_NV */
+   { 37994, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX */
+   { 38025, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX_ARB */
+   { 38060, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX */
+   { 38088, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX_ARB */
+   { 38120, 0x00000004 }, /* GL_TRIANGLES */
+   { 38133, 0x00000006 }, /* GL_TRIANGLE_FAN */
+   { 38149, 0x00008615 }, /* GL_TRIANGLE_MESH_SUN */
+   { 38170, 0x00000005 }, /* GL_TRIANGLE_STRIP */
+   { 38188, 0x00000001 }, /* GL_TRUE */
+   { 38196, 0x00000CF5 }, /* GL_UNPACK_ALIGNMENT */
+   { 38216, 0x0000806E }, /* GL_UNPACK_IMAGE_HEIGHT */
+   { 38239, 0x00000CF1 }, /* GL_UNPACK_LSB_FIRST */
+   { 38259, 0x00000CF2 }, /* GL_UNPACK_ROW_LENGTH */
+   { 38280, 0x0000806D }, /* GL_UNPACK_SKIP_IMAGES */
+   { 38302, 0x00000CF4 }, /* GL_UNPACK_SKIP_PIXELS */
+   { 38324, 0x00000CF3 }, /* GL_UNPACK_SKIP_ROWS */
+   { 38344, 0x00000CF0 }, /* GL_UNPACK_SWAP_BYTES */
+   { 38365, 0x00009118 }, /* GL_UNSIGNALED */
+   { 38379, 0x00001401 }, /* GL_UNSIGNED_BYTE */
+   { 38396, 0x00008362 }, /* GL_UNSIGNED_BYTE_2_3_3_REV */
+   { 38423, 0x00008032 }, /* GL_UNSIGNED_BYTE_3_3_2 */
+   { 38446, 0x00001405 }, /* GL_UNSIGNED_INT */
+   { 38462, 0x00008036 }, /* GL_UNSIGNED_INT_10_10_10_2 */
+   { 38489, 0x000084FA }, /* GL_UNSIGNED_INT_24_8 */
+   { 38510, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_EXT */
+   { 38535, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_NV */
+   { 38559, 0x00008368 }, /* GL_UNSIGNED_INT_2_10_10_10_REV */
+   { 38590, 0x00008035 }, /* GL_UNSIGNED_INT_8_8_8_8 */
+   { 38614, 0x00008367 }, /* GL_UNSIGNED_INT_8_8_8_8_REV */
+   { 38642, 0x00008C17 }, /* GL_UNSIGNED_NORMALIZED */
+   { 38665, 0x00001403 }, /* GL_UNSIGNED_SHORT */
+   { 38683, 0x00008366 }, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
+   { 38713, 0x00008033 }, /* GL_UNSIGNED_SHORT_4_4_4_4 */
+   { 38739, 0x00008365 }, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
+   { 38769, 0x00008034 }, /* GL_UNSIGNED_SHORT_5_5_5_1 */
+   { 38795, 0x00008363 }, /* GL_UNSIGNED_SHORT_5_6_5 */
+   { 38819, 0x00008364 }, /* GL_UNSIGNED_SHORT_5_6_5_REV */
+   { 38847, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_APPLE */
+   { 38875, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_MESA */
+   { 38902, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
+   { 38934, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_MESA */
+   { 38965, 0x00008CA2 }, /* GL_UPPER_LEFT */
+   { 38979, 0x00002A20 }, /* GL_V2F */
+   { 38986, 0x00002A21 }, /* GL_V3F */
+   { 38993, 0x00008B83 }, /* GL_VALIDATE_STATUS */
+   { 39012, 0x00001F00 }, /* GL_VENDOR */
+   { 39022, 0x00001F02 }, /* GL_VERSION */
+   { 39033, 0x00008074 }, /* GL_VERTEX_ARRAY */
+   { 39049, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING */
+   { 39073, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING_APPLE */
+   { 39103, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
+   { 39134, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING_ARB */
+   { 39169, 0x0000808E }, /* GL_VERTEX_ARRAY_POINTER */
+   { 39193, 0x0000807A }, /* GL_VERTEX_ARRAY_SIZE */
+   { 39214, 0x0000807C }, /* GL_VERTEX_ARRAY_STRIDE */
+   { 39237, 0x0000807B }, /* GL_VERTEX_ARRAY_TYPE */
+   { 39258, 0x00008650 }, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
+   { 39285, 0x0000865A }, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
+   { 39313, 0x0000865B }, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
+   { 39341, 0x0000865C }, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
+   { 39369, 0x0000865D }, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
+   { 39397, 0x0000865E }, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
+   { 39425, 0x0000865F }, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
+   { 39453, 0x00008651 }, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
+   { 39480, 0x00008652 }, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
+   { 39507, 0x00008653 }, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
+   { 39534, 0x00008654 }, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
+   { 39561, 0x00008655 }, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
+   { 39588, 0x00008656 }, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
+   { 39615, 0x00008657 }, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
+   { 39642, 0x00008658 }, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
+   { 39669, 0x00008659 }, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
+   { 39696, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
+   { 39734, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB */
+   { 39776, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
+   { 39807, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB */
+   { 39842, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
+   { 39876, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB */
+   { 39914, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
+   { 39945, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB */
+   { 39980, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
+   { 40008, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB */
+   { 40040, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
+   { 40070, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB */
+   { 40104, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
+   { 40132, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB */
+   { 40164, 0x000086A7 }, /* GL_VERTEX_BLEND_ARB */
+   { 40184, 0x00008620 }, /* GL_VERTEX_PROGRAM_ARB */
+   { 40206, 0x0000864A }, /* GL_VERTEX_PROGRAM_BINDING_NV */
+   { 40235, 0x00008620 }, /* GL_VERTEX_PROGRAM_NV */
+   { 40256, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE */
+   { 40285, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_ARB */
+   { 40318, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_NV */
+   { 40350, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE */
+   { 40377, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_ARB */
+   { 40408, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_NV */
+   { 40438, 0x00008B31 }, /* GL_VERTEX_SHADER */
+   { 40455, 0x00008B31 }, /* GL_VERTEX_SHADER_ARB */
+   { 40476, 0x00008621 }, /* GL_VERTEX_STATE_PROGRAM_NV */
+   { 40503, 0x00000BA2 }, /* GL_VIEWPORT */
+   { 40515, 0x00000800 }, /* GL_VIEWPORT_BIT */
+   { 40531, 0x0000911D }, /* GL_WAIT_FAILED */
+   { 40546, 0x000086AD }, /* GL_WEIGHT_ARRAY_ARB */
+   { 40566, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
+   { 40597, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB */
+   { 40632, 0x000086AC }, /* GL_WEIGHT_ARRAY_POINTER_ARB */
+   { 40660, 0x000086AB }, /* GL_WEIGHT_ARRAY_SIZE_ARB */
+   { 40685, 0x000086AA }, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
+   { 40712, 0x000086A9 }, /* GL_WEIGHT_ARRAY_TYPE_ARB */
+   { 40737, 0x000086A6 }, /* GL_WEIGHT_SUM_UNITY_ARB */
+   { 40761, 0x000081D4 }, /* GL_WRAP_BORDER_SUN */
+   { 40780, 0x000088B9 }, /* GL_WRITE_ONLY */
+   { 40794, 0x000088B9 }, /* GL_WRITE_ONLY_ARB */
+   { 40812, 0x00001506 }, /* GL_XOR */
+   { 40819, 0x000085B9 }, /* GL_YCBCR_422_APPLE */
+   { 40838, 0x00008757 }, /* GL_YCBCR_MESA */
+   { 40852, 0x00000000 }, /* GL_ZERO */
+   { 40860, 0x00000D16 }, /* GL_ZOOM_X */
+   { 40870, 0x00000D17 }, /* GL_ZOOM_Y */
 };
 
-static const unsigned reduced_enums[1347] =
+static const unsigned reduced_enums[1346] =
 {
        479, /* GL_FALSE */
        701, /* GL_LINES */
        703, /* GL_LINE_LOOP */
        710, /* GL_LINE_STRIP */
-      1766, /* GL_TRIANGLES */
-      1769, /* GL_TRIANGLE_STRIP */
-      1767, /* GL_TRIANGLE_FAN */
+      1765, /* GL_TRIANGLES */
+      1768, /* GL_TRIANGLE_STRIP */
+      1766, /* GL_TRIANGLE_FAN */
       1285, /* GL_QUADS */
       1289, /* GL_QUAD_STRIP */
       1171, /* GL_POLYGON */
@@ -3946,7 +3944,7 @@ static const unsigned reduced_enums[1347] =
       1533, /* GL_STENCIL_WRITEMASK */
        853, /* GL_MATRIX_MODE */
       1025, /* GL_NORMALIZE */
-      1861, /* GL_VIEWPORT */
+      1860, /* GL_VIEWPORT */
        999, /* GL_MODELVIEW_STACK_DEPTH */
       1263, /* GL_PROJECTION_STACK_DEPTH */
       1740, /* GL_TEXTURE_STACK_DEPTH */
@@ -4008,12 +4006,12 @@ static const unsigned reduced_enums[1347] =
       1117, /* GL_PIXEL_MAP_G_TO_G_SIZE */
       1115, /* GL_PIXEL_MAP_B_TO_B_SIZE */
       1113, /* GL_PIXEL_MAP_A_TO_A_SIZE */
-      1778, /* GL_UNPACK_SWAP_BYTES */
-      1773, /* GL_UNPACK_LSB_FIRST */
-      1774, /* GL_UNPACK_ROW_LENGTH */
-      1777, /* GL_UNPACK_SKIP_ROWS */
-      1776, /* GL_UNPACK_SKIP_PIXELS */
-      1771, /* GL_UNPACK_ALIGNMENT */
+      1777, /* GL_UNPACK_SWAP_BYTES */
+      1772, /* GL_UNPACK_LSB_FIRST */
+      1773, /* GL_UNPACK_ROW_LENGTH */
+      1776, /* GL_UNPACK_SKIP_ROWS */
+      1775, /* GL_UNPACK_SKIP_PIXELS */
+      1770, /* GL_UNPACK_ALIGNMENT */
       1099, /* GL_PACK_SWAP_BYTES */
       1094, /* GL_PACK_LSB_FIRST */
       1095, /* GL_PACK_ROW_LENGTH */
@@ -4026,8 +4024,8 @@ static const unsigned reduced_enums[1347] =
        641, /* GL_INDEX_OFFSET */
       1313, /* GL_RED_SCALE */
       1311, /* GL_RED_BIAS */
-      1879, /* GL_ZOOM_X */
-      1880, /* GL_ZOOM_Y */
+      1878, /* GL_ZOOM_X */
+      1879, /* GL_ZOOM_Y */
        603, /* GL_GREEN_SCALE */
        601, /* GL_GREEN_BIAS */
         93, /* GL_BLUE_SCALE */
@@ -4112,11 +4110,11 @@ static const unsigned reduced_enums[1347] =
        244, /* GL_COMPILE */
        245, /* GL_COMPILE_AND_EXECUTE */
        120, /* GL_BYTE */
-      1780, /* GL_UNSIGNED_BYTE */
+      1779, /* GL_UNSIGNED_BYTE */
       1437, /* GL_SHORT */
-      1792, /* GL_UNSIGNED_SHORT */
+      1791, /* GL_UNSIGNED_SHORT */
        645, /* GL_INT */
-      1783, /* GL_UNSIGNED_INT */
+      1782, /* GL_UNSIGNED_INT */
        489, /* GL_FLOAT */
          1, /* GL_2_BYTES */
          5, /* GL_3_BYTES */
@@ -4128,7 +4126,7 @@ static const unsigned reduced_enums[1347] =
        299, /* GL_COPY */
         51, /* GL_AND_INVERTED */
       1023, /* GL_NOOP */
-      1875, /* GL_XOR */
+      1874, /* GL_XOR */
       1086, /* GL_OR */
       1024, /* GL_NOR */
        470, /* GL_EQUIV */
@@ -4172,9 +4170,9 @@ static const unsigned reduced_enums[1347] =
       1339, /* GL_REPLACE */
        627, /* GL_INCR */
        342, /* GL_DECR */
-      1807, /* GL_VENDOR */
+      1806, /* GL_VENDOR */
       1336, /* GL_RENDERER */
-      1808, /* GL_VERSION */
+      1807, /* GL_VERSION */
        474, /* GL_EXTENSIONS */
       1387, /* GL_S */
       1553, /* GL_T */
@@ -4207,8 +4205,8 @@ static const unsigned reduced_enums[1347] =
       1178, /* GL_POLYGON_OFFSET_POINT */
       1177, /* GL_POLYGON_OFFSET_LINE */
       1297, /* GL_R3_G3_B2 */
-      1804, /* GL_V2F */
-      1805, /* GL_V3F */
+      1803, /* GL_V2F */
+      1804, /* GL_V3F */
        123, /* GL_C4UB_V2F */
        124, /* GL_C4UB_V3F */
        121, /* GL_C3F_V3F */
@@ -4281,11 +4279,11 @@ static const unsigned reduced_enums[1347] =
        951, /* GL_MINMAX_FORMAT */
        953, /* GL_MINMAX_SINK */
       1561, /* GL_TABLE_TOO_LARGE_EXT */
-      1782, /* GL_UNSIGNED_BYTE_3_3_2 */
-      1794, /* GL_UNSIGNED_SHORT_4_4_4_4 */
-      1796, /* GL_UNSIGNED_SHORT_5_5_5_1 */
-      1789, /* GL_UNSIGNED_INT_8_8_8_8 */
-      1784, /* GL_UNSIGNED_INT_10_10_10_2 */
+      1781, /* GL_UNSIGNED_BYTE_3_3_2 */
+      1793, /* GL_UNSIGNED_SHORT_4_4_4_4 */
+      1795, /* GL_UNSIGNED_SHORT_5_5_5_1 */
+      1788, /* GL_UNSIGNED_INT_8_8_8_8 */
+      1783, /* GL_UNSIGNED_INT_10_10_10_2 */
       1176, /* GL_POLYGON_OFFSET_FILL */
       1175, /* GL_POLYGON_OFFSET_FACTOR */
       1174, /* GL_POLYGON_OFFSET_BIAS */
@@ -4340,22 +4338,22 @@ static const unsigned reduced_enums[1347] =
       1639, /* GL_TEXTURE_BINDING_3D */
       1096, /* GL_PACK_SKIP_IMAGES */
       1092, /* GL_PACK_IMAGE_HEIGHT */
-      1775, /* GL_UNPACK_SKIP_IMAGES */
-      1772, /* GL_UNPACK_IMAGE_HEIGHT */
+      1774, /* GL_UNPACK_SKIP_IMAGES */
+      1771, /* GL_UNPACK_IMAGE_HEIGHT */
       1631, /* GL_TEXTURE_3D */
       1277, /* GL_PROXY_TEXTURE_3D */
       1694, /* GL_TEXTURE_DEPTH */
       1747, /* GL_TEXTURE_WRAP_R */
        856, /* GL_MAX_3D_TEXTURE_SIZE */
-      1809, /* GL_VERTEX_ARRAY */
+      1808, /* GL_VERTEX_ARRAY */
       1026, /* GL_NORMAL_ARRAY */
        148, /* GL_COLOR_ARRAY */
        631, /* GL_INDEX_ARRAY */
       1672, /* GL_TEXTURE_COORD_ARRAY */
        459, /* GL_EDGE_FLAG_ARRAY */
-      1815, /* GL_VERTEX_ARRAY_SIZE */
-      1817, /* GL_VERTEX_ARRAY_TYPE */
-      1816, /* GL_VERTEX_ARRAY_STRIDE */
+      1814, /* GL_VERTEX_ARRAY_SIZE */
+      1816, /* GL_VERTEX_ARRAY_TYPE */
+      1815, /* GL_VERTEX_ARRAY_STRIDE */
       1031, /* GL_NORMAL_ARRAY_TYPE */
       1030, /* GL_NORMAL_ARRAY_STRIDE */
        152, /* GL_COLOR_ARRAY_SIZE */
@@ -4367,7 +4365,7 @@ static const unsigned reduced_enums[1347] =
       1678, /* GL_TEXTURE_COORD_ARRAY_TYPE */
       1677, /* GL_TEXTURE_COORD_ARRAY_STRIDE */
        463, /* GL_EDGE_FLAG_ARRAY_STRIDE */
-      1814, /* GL_VERTEX_ARRAY_POINTER */
+      1813, /* GL_VERTEX_ARRAY_POINTER */
       1029, /* GL_NORMAL_ARRAY_POINTER */
        151, /* GL_COLOR_ARRAY_POINTER */
        634, /* GL_INDEX_ARRAY_POINTER */
@@ -4467,7 +4465,7 @@ static const unsigned reduced_enums[1347] =
        306, /* GL_CULL_VERTEX_EXT */
        308, /* GL_CULL_VERTEX_OBJECT_POSITION_EXT */
        307, /* GL_CULL_VERTEX_EYE_POSITION_EXT */
-      1872, /* GL_WRAP_BORDER_SUN */
+      1871, /* GL_WRAP_BORDER_SUN */
       1656, /* GL_TEXTURE_COLOR_WRITEMASK_SGIS */
        690, /* GL_LIGHT_MODEL_COLOR_CONTROL */
       1440, /* GL_SINGLE_COLOR */
@@ -4485,13 +4483,13 @@ static const unsigned reduced_enums[1347] =
        580, /* GL_FRAMEBUFFER_UNDEFINED */
        373, /* GL_DEPTH_STENCIL_ATTACHMENT */
        630, /* GL_INDEX */
-      1781, /* GL_UNSIGNED_BYTE_2_3_3_REV */
-      1797, /* GL_UNSIGNED_SHORT_5_6_5 */
-      1798, /* GL_UNSIGNED_SHORT_5_6_5_REV */
-      1795, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
-      1793, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
-      1790, /* GL_UNSIGNED_INT_8_8_8_8_REV */
-      1788, /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      1780, /* GL_UNSIGNED_BYTE_2_3_3_REV */
+      1796, /* GL_UNSIGNED_SHORT_5_6_5 */
+      1797, /* GL_UNSIGNED_SHORT_5_6_5_REV */
+      1794, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
+      1792, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
+      1789, /* GL_UNSIGNED_INT_8_8_8_8_REV */
+      1787, /* GL_UNSIGNED_INT_2_10_10_10_REV */
       1726, /* GL_TEXTURE_MAX_CLAMP_S_SGIX */
       1727, /* GL_TEXTURE_MAX_CLAMP_T_SGIX */
       1725, /* GL_TEXTURE_MAX_CLAMP_R_SGIX */
@@ -4562,10 +4560,10 @@ static const unsigned reduced_enums[1347] =
         18, /* GL_ACTIVE_TEXTURE */
        133, /* GL_CLIENT_ACTIVE_TEXTURE */
        934, /* GL_MAX_TEXTURE_UNITS */
-      1759, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
-      1762, /* GL_TRANSPOSE_PROJECTION_MATRIX */
-      1764, /* GL_TRANSPOSE_TEXTURE_MATRIX */
-      1756, /* GL_TRANSPOSE_COLOR_MATRIX */
+      1758, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
+      1761, /* GL_TRANSPOSE_PROJECTION_MATRIX */
+      1763, /* GL_TRANSPOSE_TEXTURE_MATRIX */
+      1755, /* GL_TRANSPOSE_COLOR_MATRIX */
       1545, /* GL_SUBTRACT */
        919, /* GL_MAX_RENDERBUFFER_SIZE */
        247, /* GL_COMPRESSED_ALPHA */
@@ -4580,7 +4578,7 @@ static const unsigned reduced_enums[1347] =
       1281, /* GL_PROXY_TEXTURE_RECTANGLE_ARB */
        917, /* GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB */
        372, /* GL_DEPTH_STENCIL */
-      1785, /* GL_UNSIGNED_INT_24_8 */
+      1784, /* GL_UNSIGNED_INT_24_8 */
        930, /* GL_MAX_TEXTURE_LOD_BIAS */
       1724, /* GL_TEXTURE_MAX_ANISOTROPY_EXT */
        931, /* GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT */
@@ -4633,32 +4631,32 @@ static const unsigned reduced_enums[1347] =
       1072, /* GL_OPERAND1_ALPHA */
       1078, /* GL_OPERAND2_ALPHA */
       1084, /* GL_OPERAND3_ALPHA_NV */
-      1810, /* GL_VERTEX_ARRAY_BINDING */
+      1809, /* GL_VERTEX_ARRAY_BINDING */
       1733, /* GL_TEXTURE_RANGE_LENGTH_APPLE */
       1734, /* GL_TEXTURE_RANGE_POINTER_APPLE */
-      1876, /* GL_YCBCR_422_APPLE */
-      1799, /* GL_UNSIGNED_SHORT_8_8_APPLE */
-      1801, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
+      1875, /* GL_YCBCR_422_APPLE */
+      1798, /* GL_UNSIGNED_SHORT_8_8_APPLE */
+      1800, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
       1743, /* GL_TEXTURE_STORAGE_HINT_APPLE */
       1536, /* GL_STORAGE_PRIVATE_APPLE */
       1535, /* GL_STORAGE_CACHED_APPLE */
       1537, /* GL_STORAGE_SHARED_APPLE */
       1442, /* GL_SLICE_ACCUM_SUN */
       1288, /* GL_QUAD_MESH_SUN */
-      1768, /* GL_TRIANGLE_MESH_SUN */
-      1849, /* GL_VERTEX_PROGRAM_ARB */
-      1860, /* GL_VERTEX_STATE_PROGRAM_NV */
-      1836, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
-      1842, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
-      1844, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
-      1846, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
+      1767, /* GL_TRIANGLE_MESH_SUN */
+      1848, /* GL_VERTEX_PROGRAM_ARB */
+      1859, /* GL_VERTEX_STATE_PROGRAM_NV */
+      1835, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
+      1841, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
+      1843, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
+      1845, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
        334, /* GL_CURRENT_VERTEX_ATTRIB */
       1240, /* GL_PROGRAM_LENGTH_ARB */
       1254, /* GL_PROGRAM_STRING_ARB */
        998, /* GL_MODELVIEW_PROJECTION_NV */
        623, /* GL_IDENTITY_NV */
        670, /* GL_INVERSE_NV */
-      1761, /* GL_TRANSPOSE_NV */
+      1760, /* GL_TRANSPOSE_NV */
        671, /* GL_INVERSE_TRANSPOSE_NV */
        903, /* GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB */
        902, /* GL_MAX_PROGRAM_MATRICES_ARB */
@@ -4672,33 +4670,33 @@ static const unsigned reduced_enums[1347] =
        845, /* GL_MATRIX7_NV */
        318, /* GL_CURRENT_MATRIX_STACK_DEPTH_ARB */
        315, /* GL_CURRENT_MATRIX_ARB */
-      1852, /* GL_VERTEX_PROGRAM_POINT_SIZE */
-      1855, /* GL_VERTEX_PROGRAM_TWO_SIDE */
+      1851, /* GL_VERTEX_PROGRAM_POINT_SIZE */
+      1854, /* GL_VERTEX_PROGRAM_TWO_SIDE */
       1252, /* GL_PROGRAM_PARAMETER_NV */
-      1840, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
+      1839, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
       1256, /* GL_PROGRAM_TARGET_NV */
       1253, /* GL_PROGRAM_RESIDENT_NV */
-      1753, /* GL_TRACK_MATRIX_NV */
-      1754, /* GL_TRACK_MATRIX_TRANSFORM_NV */
-      1850, /* GL_VERTEX_PROGRAM_BINDING_NV */
+      1752, /* GL_TRACK_MATRIX_NV */
+      1753, /* GL_TRACK_MATRIX_TRANSFORM_NV */
+      1849, /* GL_VERTEX_PROGRAM_BINDING_NV */
       1234, /* GL_PROGRAM_ERROR_POSITION_ARB */
        356, /* GL_DEPTH_CLAMP */
-      1818, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
-      1825, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
-      1826, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
-      1827, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
-      1828, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
-      1829, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
-      1830, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
-      1831, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
-      1832, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
-      1833, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
-      1819, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
-      1820, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
-      1821, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
-      1822, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
-      1823, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
-      1824, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
+      1817, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
+      1824, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
+      1825, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
+      1826, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
+      1827, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
+      1828, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
+      1829, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
+      1830, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
+      1831, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
+      1832, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
+      1818, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
+      1819, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
+      1820, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
+      1821, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
+      1822, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
+      1823, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
        757, /* GL_MAP1_VERTEX_ATTRIB0_4_NV */
        764, /* GL_MAP1_VERTEX_ATTRIB1_4_NV */
        765, /* GL_MAP1_VERTEX_ATTRIB2_4_NV */
@@ -4737,14 +4735,14 @@ static const unsigned reduced_enums[1347] =
        269, /* GL_COMPRESSED_TEXTURE_FORMATS */
        946, /* GL_MAX_VERTEX_UNITS_ARB */
         22, /* GL_ACTIVE_VERTEX_UNITS_ARB */
-      1871, /* GL_WEIGHT_SUM_UNITY_ARB */
-      1848, /* GL_VERTEX_BLEND_ARB */
+      1870, /* GL_WEIGHT_SUM_UNITY_ARB */
+      1847, /* GL_VERTEX_BLEND_ARB */
        336, /* GL_CURRENT_WEIGHT_ARB */
-      1870, /* GL_WEIGHT_ARRAY_TYPE_ARB */
-      1869, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
-      1868, /* GL_WEIGHT_ARRAY_SIZE_ARB */
-      1867, /* GL_WEIGHT_ARRAY_POINTER_ARB */
-      1864, /* GL_WEIGHT_ARRAY_ARB */
+      1869, /* GL_WEIGHT_ARRAY_TYPE_ARB */
+      1868, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
+      1867, /* GL_WEIGHT_ARRAY_SIZE_ARB */
+      1866, /* GL_WEIGHT_ARRAY_POINTER_ARB */
+      1863, /* GL_WEIGHT_ARRAY_ARB */
        386, /* GL_DOT3_RGB */
        387, /* GL_DOT3_RGBA */
        263, /* GL_COMPRESSED_RGB_FXT1_3DFX */
@@ -4789,7 +4787,7 @@ static const unsigned reduced_enums[1347] =
       1001, /* GL_MODULATE_ADD_ATI */
       1002, /* GL_MODULATE_SIGNED_ADD_ATI */
       1003, /* GL_MODULATE_SUBTRACT_ATI */
-      1877, /* GL_YCBCR_MESA */
+      1876, /* GL_YCBCR_MESA */
       1093, /* GL_PACK_INVERT_MESA */
        339, /* GL_DEBUG_OBJECT_MESA */
        340, /* GL_DEBUG_PRINT_MESA */
@@ -4862,7 +4860,7 @@ static const unsigned reduced_enums[1347] =
       1292, /* GL_QUERY_RESULT */
       1294, /* GL_QUERY_RESULT_AVAILABLE */
        940, /* GL_MAX_VERTEX_ATTRIBS */
-      1838, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
+      1837, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
        377, /* GL_DEPTH_STENCIL_TO_RGBA_NV */
        376, /* GL_DEPTH_STENCIL_TO_BGRA_NV */
        926, /* GL_MAX_TEXTURE_COORDS */
@@ -4877,7 +4875,7 @@ static const unsigned reduced_enums[1347] =
        464, /* GL_ELEMENT_ARRAY_BUFFER */
         54, /* GL_ARRAY_BUFFER_BINDING */
        465, /* GL_ELEMENT_ARRAY_BUFFER_BINDING */
-      1812, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
+      1811, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
       1027, /* GL_NORMAL_ARRAY_BUFFER_BINDING */
        149, /* GL_COLOR_ARRAY_BUFFER_BINDING */
        632, /* GL_INDEX_ARRAY_BUFFER_BINDING */
@@ -4885,8 +4883,8 @@ static const unsigned reduced_enums[1347] =
        460, /* GL_EDGE_FLAG_ARRAY_BUFFER_BINDING */
       1416, /* GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING */
        514, /* GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING */
-      1865, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
-      1834, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
+      1864, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
+      1833, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
       1239, /* GL_PROGRAM_INSTRUCTIONS_ARB */
        898, /* GL_MAX_PROGRAM_INSTRUCTIONS_ARB */
       1245, /* GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB */
@@ -4910,14 +4908,14 @@ static const unsigned reduced_enums[1347] =
        899, /* GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB */
        895, /* GL_MAX_PROGRAM_ENV_PARAMETERS_ARB */
       1260, /* GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB */
-      1758, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
+      1757, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
       1304, /* GL_READ_ONLY */
-      1873, /* GL_WRITE_ONLY */
+      1872, /* GL_WRITE_ONLY */
       1306, /* GL_READ_WRITE */
        102, /* GL_BUFFER_ACCESS */
        105, /* GL_BUFFER_MAPPED */
        107, /* GL_BUFFER_MAP_POINTER */
-      1752, /* GL_TIME_ELAPSED_EXT */
+      1751, /* GL_TIME_ELAPSED_EXT */
        808, /* GL_MATRIX0_ARB */
        820, /* GL_MATRIX1_ARB */
        832, /* GL_MATRIX2_ARB */
@@ -4978,7 +4976,7 @@ static const unsigned reduced_enums[1347] =
        109, /* GL_BUFFER_SERIALIZED_MODIFY_APPLE */
        104, /* GL_BUFFER_FLUSHING_UNMAP_APPLE */
        537, /* GL_FRAGMENT_SHADER */
-      1858, /* GL_VERTEX_SHADER */
+      1857, /* GL_VERTEX_SHADER */
       1250, /* GL_PROGRAM_OBJECT_ARB */
       1429, /* GL_SHADER_OBJECT_ARB */
        882, /* GL_MAX_FRAGMENT_UNIFORM_COMPONENTS */
@@ -5016,7 +5014,7 @@ static const unsigned reduced_enums[1347] =
        345, /* GL_DELETE_STATUS */
        246, /* GL_COMPILE_STATUS */
        715, /* GL_LINK_STATUS */
-      1806, /* GL_VALIDATE_STATUS */
+      1805, /* GL_VALIDATE_STATUS */
        644, /* GL_INFO_LOG_LENGTH */
         56, /* GL_ATTACHED_SHADERS */
         20, /* GL_ACTIVE_UNIFORMS */
@@ -5039,7 +5037,7 @@ static const unsigned reduced_enums[1347] =
       1106, /* GL_PALETTE8_RGB5_A1_OES */
        626, /* GL_IMPLEMENTATION_COLOR_READ_TYPE_OES */
        625, /* GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES */
-      1791, /* GL_UNSIGNED_NORMALIZED */
+      1790, /* GL_UNSIGNED_NORMALIZED */
       1628, /* GL_TEXTURE_1D_ARRAY_EXT */
       1272, /* GL_PROXY_TEXTURE_1D_ARRAY_EXT */
       1630, /* GL_TEXTURE_2D_ARRAY_EXT */
@@ -5060,7 +5058,7 @@ static const unsigned reduced_enums[1347] =
        266, /* GL_COMPRESSED_SLUMINANCE_ALPHA */
       1167, /* GL_POINT_SPRITE_COORD_ORIGIN */
        723, /* GL_LOWER_LEFT */
-      1803, /* GL_UPPER_LEFT */
+      1802, /* GL_UPPER_LEFT */
       1509, /* GL_STENCIL_BACK_REF */
       1510, /* GL_STENCIL_BACK_VALUE_MASK */
       1511, /* GL_STENCIL_BACK_WRITEMASK */
@@ -5138,12 +5136,12 @@ static const unsigned reduced_enums[1347] =
       1549, /* GL_SYNC_FLAGS */
       1548, /* GL_SYNC_FENCE */
       1551, /* GL_SYNC_GPU_COMMANDS_COMPLETE */
-      1779, /* GL_UNSIGNALED */
+      1778, /* GL_UNSIGNALED */
       1438, /* GL_SIGNALED */
         46, /* GL_ALREADY_SIGNALED */
       1750, /* GL_TIMEOUT_EXPIRED */
        270, /* GL_CONDITION_SATISFIED */
-      1863, /* GL_WAIT_FAILED */
+      1862, /* GL_WAIT_FAILED */
        471, /* GL_EVAL_BIT */
       1298, /* GL_RASTER_POSITION_UNCLIPPED_IBM */
        717, /* GL_LIST_BIT */
@@ -5152,7 +5150,6 @@ static const unsigned reduced_enums[1347] =
         29, /* GL_ALL_ATTRIB_BITS */
       1008, /* GL_MULTISAMPLE_BIT */
         30, /* GL_ALL_CLIENT_ATTRIB_BITS */
-      1751, /* GL_TIMEOUT_IGNORED */
 };
 
 typedef int (*cfunc)(const void *, const void *);
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index 329b795..5983f00 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -910,6 +910,7 @@ _mesa_test_formats(void)
             GLuint t = info->RedBits + info->GreenBits
                + info->BlueBits + info->AlphaBits;
             assert(t / 8 == info->BytesPerBlock);
+            (void) t;
          }
       }
 
diff --git a/src/mesa/main/image.c b/src/mesa/main/image.c
index 139e56a..3b685cb 100644
--- a/src/mesa/main/image.c
+++ b/src/mesa/main/image.c
@@ -3228,6 +3228,7 @@ extract_float_rgba(GLuint n, GLfloat rgba[][4],
           srcFormat == GL_RGBA ||
           srcFormat == GL_BGRA ||
           srcFormat == GL_ABGR_EXT ||
+          srcFormat == GL_DU8DV8_ATI ||
           srcFormat == GL_DUDV_ATI);
 
    ASSERT(srcType == GL_UNSIGNED_BYTE ||
@@ -3343,6 +3344,7 @@ extract_float_rgba(GLuint n, GLfloat rgba[][4],
          aComp = 0;
          stride = 4;
          break;
+      case GL_DU8DV8_ATI:
       case GL_DUDV_ATI:
          redIndex = 0;
          greenIndex = 1;
diff --git a/src/mesa/main/texgetimage.c b/src/mesa/main/texgetimage.c
index 23765d2..ac467c4 100644
--- a/src/mesa/main/texgetimage.c
+++ b/src/mesa/main/texgetimage.c
@@ -103,7 +103,7 @@ get_tex_color_index(GLcontext *ctx, GLuint dimensions,
 
    for (img = 0; img < depth; img++) {
       for (row = 0; row < height; row++) {
-         GLuint indexRow[MAX_WIDTH];
+         GLuint indexRow[MAX_WIDTH] = { 0 };
          void *dest = _mesa_image_address(dimensions, &ctx->Pack, pixels,
                                           width, height, format, type,
                                           img, row, 0);
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index db4c7a5..9e1a889 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -1165,6 +1165,7 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
       return;
    }
 
+   _mesa_lock_texture(ctx, obj);
    switch (pname) {
       case GL_TEXTURE_MAG_FILTER:
          *params = (GLint) obj->MagFilter;
diff --git a/src/mesa/main/version.h b/src/mesa/main/version.h
index 9c758ce..1c5749f 100644
--- a/src/mesa/main/version.h
+++ b/src/mesa/main/version.h
@@ -1,9 +1,9 @@
 /*
  * Mesa 3-D graphics library
- * Version:  7.7
+ * Version:  7.7.1
  *
  * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
- * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
+ * Copyright (C) 2009-2010  VMware, Inc.  All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -31,8 +31,8 @@
 /* Mesa version */
 #define MESA_MAJOR 7
 #define MESA_MINOR 7
-#define MESA_PATCH 0
-#define MESA_VERSION_STRING "7.7"
+#define MESA_PATCH 1
+#define MESA_VERSION_STRING "7.7.1-DEVEL"
 
 /* To make version comparison easy */
 #define MESA_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff --git a/src/mesa/shader/nvfragparse.c b/src/mesa/shader/nvfragparse.c
index b739a6a..8ee7c93 100644
--- a/src/mesa/shader/nvfragparse.c
+++ b/src/mesa/shader/nvfragparse.c
@@ -642,7 +642,7 @@ Parse_SwizzleSuffix(const GLubyte *token, GLuint swizzle[4])
    else {
       /* 4-component swizzle (vector) */
       GLint k;
-      for (k = 0; token[k] && k < 4; k++) {
+      for (k = 0; k < 4 && token[k]; k++) {
          if (token[k] == 'x')
             swizzle[k] = 0;
          else if (token[k] == 'y')
diff --git a/src/mesa/shader/prog_optimize.c b/src/mesa/shader/prog_optimize.c
index 4fe3512..8b9466a 100644
--- a/src/mesa/shader/prog_optimize.c
+++ b/src/mesa/shader/prog_optimize.c
@@ -578,7 +578,7 @@ _mesa_remove_extra_moves(struct gl_program *prog)
 
             /* get pointer to previous instruction */
             prevI = i - 1;
-            while (removeInst[prevI] && prevI > 0)
+            while (prevI > 0 && removeInst[prevI])
                prevI--;
             prevInst = prog->Instructions + prevI;
 
diff --git a/src/mesa/shader/prog_parameter.c b/src/mesa/shader/prog_parameter.c
index f22492e..5822510 100644
--- a/src/mesa/shader/prog_parameter.c
+++ b/src/mesa/shader/prog_parameter.c
@@ -230,9 +230,8 @@ _mesa_add_named_constant(struct gl_program_parameter_list *paramList,
  * Add a new unnamed constant to the parameter list.  This will be used
  * when a fragment/vertex program contains something like this:
  *    MOV r, { 0, 1, 2, 3 };
- * We'll search the parameter list for an existing instance of the
- * constant.  If swizzleOut is non-null, we'll try swizzling when
- * looking for a match.
+ * If swizzleOut is non-null we'll search the parameter list for an
+ * existing instance of the constant which matches with a swizzle.
  *
  * \param paramList  the parameter list
  * \param values  four float values
@@ -248,7 +247,8 @@ _mesa_add_unnamed_constant(struct gl_program_parameter_list *paramList,
    ASSERT(size >= 1);
    ASSERT(size <= 4);
 
-   if (_mesa_lookup_parameter_constant(paramList, values,
+   if (swizzleOut &&
+       _mesa_lookup_parameter_constant(paramList, values,
                                        size, &pos, swizzleOut)) {
       return pos;
    }
diff --git a/src/mesa/shader/prog_parameter_layout.c b/src/mesa/shader/prog_parameter_layout.c
index 1c37b3a..a888573 100644
--- a/src/mesa/shader/prog_parameter_layout.c
+++ b/src/mesa/shader/prog_parameter_layout.c
@@ -72,14 +72,11 @@ copy_indirect_accessed_array(struct gl_program_parameter_list *src,
 			     unsigned first, unsigned count)
 {
    const int base = dst->NumParameters;
-   unsigned i;
-   unsigned j;
-
+   unsigned i, j;
 
    for (i = first; i < (first + count); i++) {
       struct gl_program_parameter *curr = & src->Parameters[i];
 
-
       if (curr->Type == PROGRAM_CONSTANT) {
 	 j = dst->NumParameters;
       } else {
@@ -93,10 +90,15 @@ copy_indirect_accessed_array(struct gl_program_parameter_list *src,
 
       assert(j == dst->NumParameters);
 
+      /* copy src parameter [i] to dest parameter [j] */
       memcpy(& dst->Parameters[j], curr,
 	     sizeof(dst->Parameters[j]));
       memcpy(dst->ParameterValues[j], src->ParameterValues[i],
 	     sizeof(GLfloat) * 4);
+
+      /* Pointer to the string name was copied.  Null-out src param name
+       * to prevent double free later.
+       */
       curr->Name = NULL;
 
       dst->NumParameters++;
@@ -117,11 +119,9 @@ _mesa_layout_parameters(struct asm_parser_state *state)
    struct asm_instruction *inst;
    unsigned i;
 
-
    layout =
       _mesa_new_parameter_list_sized(state->prog->Parameters->NumParameters);
 
-
    /* PASS 1:  Move any parameters that are accessed indirectly from the
     * original parameter list to the new parameter list.
     */
@@ -155,7 +155,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
       }
    }
 
-
    /* PASS 2:  Move any parameters that are not accessed indirectly from the
     * original parameter list to the new parameter list.
     */
@@ -165,7 +164,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 	 const int idx = inst->SrcReg[i].Base.Index;
 	 unsigned swizzle = SWIZZLE_NOOP;
 
-
 	 /* All relative addressed operands were processed on the first
 	  * pass.  Just skip them here.
 	  */
@@ -173,7 +171,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 	    continue;
 	 }
 
-
 	 if ((inst->SrcReg[i].Base.File <= PROGRAM_VARYING )
 	     || (inst->SrcReg[i].Base.File >= PROGRAM_WRITE_ONLY)) {
 	    continue;
@@ -209,7 +206,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
       }
    }
 
-
    _mesa_free_parameter_list(state->prog->Parameters);
    state->prog->Parameters = layout;
 
diff --git a/src/mesa/shader/prog_print.c b/src/mesa/shader/prog_print.c
index 52c102c..9f9789e 100644
--- a/src/mesa/shader/prog_print.c
+++ b/src/mesa/shader/prog_print.c
@@ -821,8 +821,10 @@ _mesa_print_program(const struct gl_program *prog)
 
 
 /**
- * Return binary representation of value (as a string).
+ * Return binary representation of 64-bit value (as a string).
  * Insert a comma to separate each group of 8 bits.
+ * Note we return a pointer to local static storage so this is not
+ * re-entrant, etc.
  * XXX move to imports.[ch] if useful elsewhere.
  */
 static const char *
@@ -831,7 +833,7 @@ binary(GLbitfield64 val)
    static char buf[80];
    GLint i, len = 0;
    for (i = 63; i >= 0; --i) {
-      if (val & (1 << i))
+      if (val & (1ULL << i))
          buf[len++] = '1';
       else if (len > 0 || i == 0)
          buf[len++] = '0';
@@ -855,7 +857,7 @@ _mesa_fprint_program_parameters(FILE *f,
 
    _mesa_fprintf(f, "InputsRead: 0x%x (0b%s)\n",
                  prog->InputsRead, binary(prog->InputsRead));
-   _mesa_fprintf(f, "OutputsWritten: 0x%x (0b%s)\n",
+   _mesa_fprintf(f, "OutputsWritten: 0x%llx (0b%s)\n",
                  prog->OutputsWritten, binary(prog->OutputsWritten));
    _mesa_fprintf(f, "NumInstructions=%d\n", prog->NumInstructions);
    _mesa_fprintf(f, "NumTemporaries=%d\n", prog->NumTemporaries);
diff --git a/src/mesa/shader/program_parse.tab.c b/src/mesa/shader/program_parse.tab.c
index d4f8429..b12dcee 100644
--- a/src/mesa/shader/program_parse.tab.c
+++ b/src/mesa/shader/program_parse.tab.c
@@ -123,7 +123,8 @@ static int initialize_symbol_from_param(struct gl_program *prog,
     struct asm_symbol *param_var, const gl_state_index tokens[STATE_LENGTH]);
 
 static int initialize_symbol_from_const(struct gl_program *prog,
-    struct asm_symbol *param_var, const struct asm_vector *vec);
+    struct asm_symbol *param_var, const struct asm_vector *vec,
+    GLboolean allowSwizzle);
 
 static int yyparse(struct asm_parser_state *state);
 
@@ -145,6 +146,9 @@ static void init_src_reg(struct asm_src_register *r);
 static void set_src_reg(struct asm_src_register *r,
                         gl_register_file file, GLint index);
 
+static void set_src_reg_swz(struct asm_src_register *r,
+                            gl_register_file file, GLint index, GLuint swizzle);
+
 static void asm_instruction_set_operands(struct asm_instruction *inst,
     const struct prog_dst_register *dst, const struct asm_src_register *src0,
     const struct asm_src_register *src1, const struct asm_src_register *src2);
@@ -185,7 +189,7 @@ static struct asm_instruction *asm_instruction_copy_ctor(
 
 
 /* Line 189 of yacc.c  */
-#line 189 "program_parse.tab.c"
+#line 193 "program_parse.tab.c"
 
 /* Enabling traces.  */
 #ifndef YYDEBUG
@@ -327,7 +331,7 @@ typedef union YYSTYPE
 {
 
 /* Line 214 of yacc.c  */
-#line 122 "program_parse.y"
+#line 126 "program_parse.y"
 
    struct asm_instruction *inst;
    struct asm_symbol *sym;
@@ -356,7 +360,7 @@ typedef union YYSTYPE
 
 
 /* Line 214 of yacc.c  */
-#line 360 "program_parse.tab.c"
+#line 364 "program_parse.tab.c"
 } YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
@@ -380,14 +384,14 @@ typedef struct YYLTYPE
 /* Copy the second part of user declarations.  */
 
 /* Line 264 of yacc.c  */
-#line 267 "program_parse.y"
+#line 271 "program_parse.y"
 
 extern int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param,
     void *yyscanner);
 
 
 /* Line 264 of yacc.c  */
-#line 391 "program_parse.tab.c"
+#line 395 "program_parse.tab.c"
 
 #ifdef short
 # undef short
@@ -788,35 +792,35 @@ static const yytype_int16 yyrhs[] =
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   274,   274,   277,   285,   297,   298,   301,   325,   326,
-     329,   344,   347,   352,   359,   360,   361,   362,   363,   364,
-     365,   368,   369,   370,   373,   379,   385,   391,   398,   404,
-     411,   455,   460,   470,   514,   520,   521,   522,   523,   524,
-     525,   526,   527,   528,   529,   530,   531,   534,   546,   554,
-     571,   578,   595,   606,   626,   651,   658,   691,   698,   713,
-     768,   809,   818,   839,   848,   852,   881,   900,   900,   902,
-     909,   921,   922,   923,   926,   940,   954,   974,   985,   997,
-     999,  1000,  1001,  1002,  1005,  1005,  1005,  1005,  1006,  1009,
-    1013,  1018,  1025,  1032,  1039,  1062,  1085,  1086,  1087,  1088,
-    1089,  1090,  1093,  1112,  1116,  1122,  1126,  1130,  1134,  1143,
-    1152,  1156,  1161,  1167,  1178,  1178,  1179,  1181,  1185,  1189,
-    1193,  1199,  1199,  1201,  1218,  1243,  1246,  1257,  1263,  1269,
-    1270,  1277,  1283,  1289,  1297,  1303,  1309,  1317,  1323,  1329,
-    1337,  1338,  1341,  1342,  1343,  1344,  1345,  1346,  1347,  1348,
-    1349,  1350,  1351,  1354,  1363,  1367,  1371,  1377,  1386,  1390,
-    1394,  1403,  1407,  1413,  1419,  1426,  1431,  1439,  1449,  1451,
-    1459,  1465,  1469,  1473,  1479,  1490,  1499,  1503,  1508,  1512,
-    1516,  1520,  1526,  1533,  1537,  1543,  1551,  1562,  1569,  1573,
-    1579,  1589,  1600,  1604,  1622,  1631,  1634,  1640,  1644,  1648,
-    1654,  1665,  1670,  1675,  1680,  1685,  1690,  1698,  1701,  1706,
-    1719,  1727,  1738,  1746,  1746,  1748,  1748,  1750,  1760,  1765,
-    1772,  1782,  1791,  1796,  1803,  1813,  1823,  1835,  1835,  1836,
-    1836,  1838,  1848,  1856,  1866,  1874,  1882,  1891,  1902,  1906,
-    1912,  1913,  1914,  1917,  1917,  1920,  1955,  1959,  1959,  1962,
-    1969,  1978,  1992,  2001,  2010,  2014,  2023,  2032,  2043,  2050,
-    2055,  2064,  2076,  2079,  2088,  2099,  2100,  2101,  2104,  2105,
-    2106,  2109,  2110,  2113,  2114,  2117,  2118,  2121,  2132,  2143,
-    2154,  2180,  2181
+       0,   278,   278,   281,   289,   301,   302,   305,   329,   330,
+     333,   348,   351,   356,   363,   364,   365,   366,   367,   368,
+     369,   372,   373,   374,   377,   383,   389,   395,   402,   408,
+     415,   459,   464,   474,   518,   524,   525,   526,   527,   528,
+     529,   530,   531,   532,   533,   534,   535,   538,   550,   558,
+     575,   582,   601,   612,   632,   657,   664,   697,   704,   719,
+     774,   817,   826,   847,   857,   861,   890,   909,   909,   911,
+     918,   930,   931,   932,   935,   949,   963,   983,   994,  1006,
+    1008,  1009,  1010,  1011,  1014,  1014,  1014,  1014,  1015,  1018,
+    1022,  1027,  1034,  1041,  1048,  1071,  1094,  1095,  1096,  1097,
+    1098,  1099,  1102,  1121,  1125,  1131,  1135,  1139,  1143,  1152,
+    1161,  1165,  1170,  1176,  1187,  1187,  1188,  1190,  1194,  1198,
+    1202,  1208,  1208,  1210,  1228,  1254,  1257,  1268,  1274,  1280,
+    1281,  1288,  1294,  1300,  1308,  1314,  1320,  1328,  1334,  1340,
+    1348,  1349,  1352,  1353,  1354,  1355,  1356,  1357,  1358,  1359,
+    1360,  1361,  1362,  1365,  1374,  1378,  1382,  1388,  1397,  1401,
+    1405,  1414,  1418,  1424,  1430,  1437,  1442,  1450,  1460,  1462,
+    1470,  1476,  1480,  1484,  1490,  1501,  1510,  1514,  1519,  1523,
+    1527,  1531,  1537,  1544,  1548,  1554,  1562,  1573,  1580,  1584,
+    1590,  1600,  1611,  1615,  1633,  1642,  1645,  1651,  1655,  1659,
+    1665,  1676,  1681,  1686,  1691,  1696,  1701,  1709,  1712,  1717,
+    1730,  1738,  1749,  1757,  1757,  1759,  1759,  1761,  1771,  1776,
+    1783,  1793,  1802,  1807,  1814,  1824,  1834,  1846,  1846,  1847,
+    1847,  1849,  1859,  1867,  1877,  1885,  1893,  1902,  1913,  1917,
+    1923,  1924,  1925,  1928,  1928,  1931,  1966,  1970,  1970,  1973,
+    1980,  1989,  2003,  2012,  2021,  2025,  2034,  2043,  2054,  2061,
+    2066,  2075,  2087,  2090,  2099,  2110,  2111,  2112,  2115,  2116,
+    2117,  2120,  2121,  2124,  2125,  2128,  2129,  2132,  2143,  2154,
+    2165,  2191,  2192
 };
 #endif
 
@@ -2125,7 +2129,7 @@ yyreduce:
         case 3:
 
 /* Line 1455 of yacc.c  */
-#line 278 "program_parse.y"
+#line 282 "program_parse.y"
     {
 	   if (state->prog->Target != GL_VERTEX_PROGRAM_ARB) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid fragment program header");
@@ -2138,7 +2142,7 @@ yyreduce:
   case 4:
 
 /* Line 1455 of yacc.c  */
-#line 286 "program_parse.y"
+#line 290 "program_parse.y"
     {
 	   if (state->prog->Target != GL_FRAGMENT_PROGRAM_ARB) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid vertex program header");
@@ -2153,7 +2157,7 @@ yyreduce:
   case 7:
 
 /* Line 1455 of yacc.c  */
-#line 302 "program_parse.y"
+#line 306 "program_parse.y"
     {
 	   int valid = 0;
 
@@ -2180,7 +2184,7 @@ yyreduce:
   case 10:
 
 /* Line 1455 of yacc.c  */
-#line 330 "program_parse.y"
+#line 334 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (2)].inst) != NULL) {
 	      if (state->inst_tail == NULL) {
@@ -2200,7 +2204,7 @@ yyreduce:
   case 12:
 
 /* Line 1455 of yacc.c  */
-#line 348 "program_parse.y"
+#line 352 "program_parse.y"
     {
 	   (yyval.inst) = (yyvsp[(1) - (1)].inst);
 	   state->prog->NumAluInstructions++;
@@ -2210,7 +2214,7 @@ yyreduce:
   case 13:
 
 /* Line 1455 of yacc.c  */
-#line 353 "program_parse.y"
+#line 357 "program_parse.y"
     {
 	   (yyval.inst) = (yyvsp[(1) - (1)].inst);
 	   state->prog->NumTexInstructions++;
@@ -2220,7 +2224,7 @@ yyreduce:
   case 24:
 
 /* Line 1455 of yacc.c  */
-#line 374 "program_parse.y"
+#line 378 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_ARL, & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2229,7 +2233,7 @@ yyreduce:
   case 25:
 
 /* Line 1455 of yacc.c  */
-#line 380 "program_parse.y"
+#line 384 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (4)].temp_inst), & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2238,7 +2242,7 @@ yyreduce:
   case 26:
 
 /* Line 1455 of yacc.c  */
-#line 386 "program_parse.y"
+#line 390 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (4)].temp_inst), & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2247,7 +2251,7 @@ yyreduce:
   case 27:
 
 /* Line 1455 of yacc.c  */
-#line 392 "program_parse.y"
+#line 396 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (6)].temp_inst), & (yyvsp[(2) - (6)].dst_reg), & (yyvsp[(4) - (6)].src_reg), & (yyvsp[(6) - (6)].src_reg), NULL);
 	;}
@@ -2256,7 +2260,7 @@ yyreduce:
   case 28:
 
 /* Line 1455 of yacc.c  */
-#line 399 "program_parse.y"
+#line 403 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (6)].temp_inst), & (yyvsp[(2) - (6)].dst_reg), & (yyvsp[(4) - (6)].src_reg), & (yyvsp[(6) - (6)].src_reg), NULL);
 	;}
@@ -2265,7 +2269,7 @@ yyreduce:
   case 29:
 
 /* Line 1455 of yacc.c  */
-#line 406 "program_parse.y"
+#line 410 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (8)].temp_inst), & (yyvsp[(2) - (8)].dst_reg), & (yyvsp[(4) - (8)].src_reg), & (yyvsp[(6) - (8)].src_reg), & (yyvsp[(8) - (8)].src_reg));
 	;}
@@ -2274,7 +2278,7 @@ yyreduce:
   case 30:
 
 /* Line 1455 of yacc.c  */
-#line 412 "program_parse.y"
+#line 416 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (8)].temp_inst), & (yyvsp[(2) - (8)].dst_reg), & (yyvsp[(4) - (8)].src_reg), NULL, NULL);
 	   if ((yyval.inst) != NULL) {
@@ -2321,7 +2325,7 @@ yyreduce:
   case 31:
 
 /* Line 1455 of yacc.c  */
-#line 456 "program_parse.y"
+#line 460 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_KIL, NULL, & (yyvsp[(2) - (2)].src_reg), NULL, NULL);
 	   state->fragment.UsesKill = 1;
@@ -2331,7 +2335,7 @@ yyreduce:
   case 32:
 
 /* Line 1455 of yacc.c  */
-#line 461 "program_parse.y"
+#line 465 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_KIL_NV, NULL, NULL, NULL, NULL);
 	   (yyval.inst)->Base.DstReg.CondMask = (yyvsp[(2) - (2)].dst_reg).CondMask;
@@ -2344,7 +2348,7 @@ yyreduce:
   case 33:
 
 /* Line 1455 of yacc.c  */
-#line 471 "program_parse.y"
+#line 475 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (12)].temp_inst), & (yyvsp[(2) - (12)].dst_reg), & (yyvsp[(4) - (12)].src_reg), & (yyvsp[(6) - (12)].src_reg), & (yyvsp[(8) - (12)].src_reg));
 	   if ((yyval.inst) != NULL) {
@@ -2391,7 +2395,7 @@ yyreduce:
   case 34:
 
 /* Line 1455 of yacc.c  */
-#line 515 "program_parse.y"
+#line 519 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (2)].integer);
 	;}
@@ -2400,91 +2404,91 @@ yyreduce:
   case 35:
 
 /* Line 1455 of yacc.c  */
-#line 520 "program_parse.y"
+#line 524 "program_parse.y"
     { (yyval.integer) = TEXTURE_1D_INDEX; ;}
     break;
 
   case 36:
 
 /* Line 1455 of yacc.c  */
-#line 521 "program_parse.y"
+#line 525 "program_parse.y"
     { (yyval.integer) = TEXTURE_2D_INDEX; ;}
     break;
 
   case 37:
 
 /* Line 1455 of yacc.c  */
-#line 522 "program_parse.y"
+#line 526 "program_parse.y"
     { (yyval.integer) = TEXTURE_3D_INDEX; ;}
     break;
 
   case 38:
 
 /* Line 1455 of yacc.c  */
-#line 523 "program_parse.y"
+#line 527 "program_parse.y"
     { (yyval.integer) = TEXTURE_CUBE_INDEX; ;}
     break;
 
   case 39:
 
 /* Line 1455 of yacc.c  */
-#line 524 "program_parse.y"
+#line 528 "program_parse.y"
     { (yyval.integer) = TEXTURE_RECT_INDEX; ;}
     break;
 
   case 40:
 
 /* Line 1455 of yacc.c  */
-#line 525 "program_parse.y"
+#line 529 "program_parse.y"
     { (yyval.integer) = -TEXTURE_1D_INDEX; ;}
     break;
 
   case 41:
 
 /* Line 1455 of yacc.c  */
-#line 526 "program_parse.y"
+#line 530 "program_parse.y"
     { (yyval.integer) = -TEXTURE_2D_INDEX; ;}
     break;
 
   case 42:
 
 /* Line 1455 of yacc.c  */
-#line 527 "program_parse.y"
+#line 531 "program_parse.y"
     { (yyval.integer) = -TEXTURE_RECT_INDEX; ;}
     break;
 
   case 43:
 
 /* Line 1455 of yacc.c  */
-#line 528 "program_parse.y"
+#line 532 "program_parse.y"
     { (yyval.integer) = TEXTURE_1D_ARRAY_INDEX; ;}
     break;
 
   case 44:
 
 /* Line 1455 of yacc.c  */
-#line 529 "program_parse.y"
+#line 533 "program_parse.y"
     { (yyval.integer) = TEXTURE_2D_ARRAY_INDEX; ;}
     break;
 
   case 45:
 
 /* Line 1455 of yacc.c  */
-#line 530 "program_parse.y"
+#line 534 "program_parse.y"
     { (yyval.integer) = -TEXTURE_1D_ARRAY_INDEX; ;}
     break;
 
   case 46:
 
 /* Line 1455 of yacc.c  */
-#line 531 "program_parse.y"
+#line 535 "program_parse.y"
     { (yyval.integer) = -TEXTURE_2D_ARRAY_INDEX; ;}
     break;
 
   case 47:
 
 /* Line 1455 of yacc.c  */
-#line 535 "program_parse.y"
+#line 539 "program_parse.y"
     {
 	   /* FIXME: Is this correct?  Should the extenedSwizzle be applied
 	    * FIXME: to the existing swizzle?
@@ -2499,7 +2503,7 @@ yyreduce:
   case 48:
 
 /* Line 1455 of yacc.c  */
-#line 547 "program_parse.y"
+#line 551 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(2) - (2)].src_reg);
 
@@ -2512,7 +2516,7 @@ yyreduce:
   case 49:
 
 /* Line 1455 of yacc.c  */
-#line 555 "program_parse.y"
+#line 559 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(3) - (4)].src_reg);
 
@@ -2532,7 +2536,7 @@ yyreduce:
   case 50:
 
 /* Line 1455 of yacc.c  */
-#line 572 "program_parse.y"
+#line 576 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(1) - (2)].src_reg);
 
@@ -2544,7 +2548,7 @@ yyreduce:
   case 51:
 
 /* Line 1455 of yacc.c  */
-#line 579 "program_parse.y"
+#line 583 "program_parse.y"
     {
 	   struct asm_symbol temp_sym;
 
@@ -2555,16 +2559,18 @@ yyreduce:
 
 	   memset(& temp_sym, 0, sizeof(temp_sym));
 	   temp_sym.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & temp_sym, & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & temp_sym, & (yyvsp[(1) - (1)].vector), GL_TRUE);
 
-	   set_src_reg(& (yyval.src_reg), PROGRAM_CONSTANT, temp_sym.param_binding_begin);
+	   set_src_reg_swz(& (yyval.src_reg), PROGRAM_CONSTANT,
+                           temp_sym.param_binding_begin,
+                           temp_sym.param_binding_swizzle);
 	;}
     break;
 
   case 52:
 
 /* Line 1455 of yacc.c  */
-#line 596 "program_parse.y"
+#line 602 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(2) - (3)].src_reg);
 
@@ -2580,7 +2586,7 @@ yyreduce:
   case 53:
 
 /* Line 1455 of yacc.c  */
-#line 607 "program_parse.y"
+#line 613 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(3) - (5)].src_reg);
 
@@ -2602,7 +2608,7 @@ yyreduce:
   case 54:
 
 /* Line 1455 of yacc.c  */
-#line 627 "program_parse.y"
+#line 633 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (3)].dst_reg);
 	   (yyval.dst_reg).WriteMask = (yyvsp[(2) - (3)].swiz_mask).mask;
@@ -2630,7 +2636,7 @@ yyreduce:
   case 55:
 
 /* Line 1455 of yacc.c  */
-#line 652 "program_parse.y"
+#line 658 "program_parse.y"
     {
 	   set_dst_reg(& (yyval.dst_reg), PROGRAM_ADDRESS, 0);
 	   (yyval.dst_reg).WriteMask = (yyvsp[(2) - (2)].swiz_mask).mask;
@@ -2640,7 +2646,7 @@ yyreduce:
   case 56:
 
 /* Line 1455 of yacc.c  */
-#line 659 "program_parse.y"
+#line 665 "program_parse.y"
     {
 	   const unsigned xyzw_valid =
 	      ((yyvsp[(1) - (7)].ext_swizzle).xyzw_valid << 0)
@@ -2676,7 +2682,7 @@ yyreduce:
   case 57:
 
 /* Line 1455 of yacc.c  */
-#line 692 "program_parse.y"
+#line 698 "program_parse.y"
     {
 	   (yyval.ext_swizzle) = (yyvsp[(2) - (2)].ext_swizzle);
 	   (yyval.ext_swizzle).negate = ((yyvsp[(1) - (2)].negate)) ? 1 : 0;
@@ -2686,7 +2692,7 @@ yyreduce:
   case 58:
 
 /* Line 1455 of yacc.c  */
-#line 699 "program_parse.y"
+#line 705 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) != 0) && ((yyvsp[(1) - (1)].integer) != 1)) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid extended swizzle selector");
@@ -2706,7 +2712,7 @@ yyreduce:
   case 59:
 
 /* Line 1455 of yacc.c  */
-#line 714 "program_parse.y"
+#line 720 "program_parse.y"
     {
 	   char s;
 
@@ -2764,7 +2770,7 @@ yyreduce:
   case 60:
 
 /* Line 1455 of yacc.c  */
-#line 769 "program_parse.y"
+#line 775 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2789,7 +2795,9 @@ yyreduce:
 	      set_src_reg(& (yyval.src_reg), PROGRAM_TEMPORARY, s->temp_binding);
 	      break;
 	   case at_param:
-	      set_src_reg(& (yyval.src_reg), s->param_binding_type, s->param_binding_begin);
+              set_src_reg_swz(& (yyval.src_reg), s->param_binding_type,
+                              s->param_binding_begin,
+                              s->param_binding_swizzle);
 	      break;
 	   case at_attrib:
 	      set_src_reg(& (yyval.src_reg), PROGRAM_INPUT, s->attrib_binding);
@@ -2810,7 +2818,7 @@ yyreduce:
   case 61:
 
 /* Line 1455 of yacc.c  */
-#line 810 "program_parse.y"
+#line 818 "program_parse.y"
     {
 	   set_src_reg(& (yyval.src_reg), PROGRAM_INPUT, (yyvsp[(1) - (1)].attrib));
 	   state->prog->InputsRead |= (1U << (yyval.src_reg).Base.Index);
@@ -2824,7 +2832,7 @@ yyreduce:
   case 62:
 
 /* Line 1455 of yacc.c  */
-#line 819 "program_parse.y"
+#line 827 "program_parse.y"
     {
 	   if (! (yyvsp[(3) - (4)].src_reg).Base.RelAddr
 	       && ((unsigned) (yyvsp[(3) - (4)].src_reg).Base.Index >= (yyvsp[(1) - (4)].sym)->param_binding_length)) {
@@ -2850,19 +2858,20 @@ yyreduce:
   case 63:
 
 /* Line 1455 of yacc.c  */
-#line 840 "program_parse.y"
+#line 848 "program_parse.y"
     {
            gl_register_file file = ((yyvsp[(1) - (1)].temp_sym).name != NULL) 
 	      ? (yyvsp[(1) - (1)].temp_sym).param_binding_type
 	      : PROGRAM_CONSTANT;
-	   set_src_reg(& (yyval.src_reg), file, (yyvsp[(1) - (1)].temp_sym).param_binding_begin);
+           set_src_reg_swz(& (yyval.src_reg), file, (yyvsp[(1) - (1)].temp_sym).param_binding_begin,
+                           (yyvsp[(1) - (1)].temp_sym).param_binding_swizzle);
 	;}
     break;
 
   case 64:
 
 /* Line 1455 of yacc.c  */
-#line 849 "program_parse.y"
+#line 858 "program_parse.y"
     {
 	   set_dst_reg(& (yyval.dst_reg), PROGRAM_OUTPUT, (yyvsp[(1) - (1)].result));
 	;}
@@ -2871,7 +2880,7 @@ yyreduce:
   case 65:
 
 /* Line 1455 of yacc.c  */
-#line 853 "program_parse.y"
+#line 862 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2903,7 +2912,7 @@ yyreduce:
   case 66:
 
 /* Line 1455 of yacc.c  */
-#line 882 "program_parse.y"
+#line 891 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2925,7 +2934,7 @@ yyreduce:
   case 69:
 
 /* Line 1455 of yacc.c  */
-#line 903 "program_parse.y"
+#line 912 "program_parse.y"
     {
 	   init_src_reg(& (yyval.src_reg));
 	   (yyval.src_reg).Base.Index = (yyvsp[(1) - (1)].integer);
@@ -2935,7 +2944,7 @@ yyreduce:
   case 70:
 
 /* Line 1455 of yacc.c  */
-#line 910 "program_parse.y"
+#line 919 "program_parse.y"
     {
 	   /* FINISHME: Add support for multiple address registers.
 	    */
@@ -2950,28 +2959,28 @@ yyreduce:
   case 71:
 
 /* Line 1455 of yacc.c  */
-#line 921 "program_parse.y"
+#line 930 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 72:
 
 /* Line 1455 of yacc.c  */
-#line 922 "program_parse.y"
+#line 931 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 73:
 
 /* Line 1455 of yacc.c  */
-#line 923 "program_parse.y"
+#line 932 "program_parse.y"
     { (yyval.integer) = -(yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 74:
 
 /* Line 1455 of yacc.c  */
-#line 927 "program_parse.y"
+#line 936 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 0) || ((yyvsp[(1) - (1)].integer) > 63)) {
               char s[100];
@@ -2988,7 +2997,7 @@ yyreduce:
   case 75:
 
 /* Line 1455 of yacc.c  */
-#line 941 "program_parse.y"
+#line 950 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 0) || ((yyvsp[(1) - (1)].integer) > 64)) {
               char s[100];
@@ -3005,7 +3014,7 @@ yyreduce:
   case 76:
 
 /* Line 1455 of yacc.c  */
-#line 955 "program_parse.y"
+#line 964 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -3028,7 +3037,7 @@ yyreduce:
   case 77:
 
 /* Line 1455 of yacc.c  */
-#line 975 "program_parse.y"
+#line 984 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].swiz_mask).mask != WRITEMASK_X) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid address component selector");
@@ -3042,7 +3051,7 @@ yyreduce:
   case 78:
 
 /* Line 1455 of yacc.c  */
-#line 986 "program_parse.y"
+#line 995 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].swiz_mask).mask != WRITEMASK_X) {
 	      yyerror(& (yylsp[(1) - (1)]), state,
@@ -3057,21 +3066,21 @@ yyreduce:
   case 83:
 
 /* Line 1455 of yacc.c  */
-#line 1002 "program_parse.y"
+#line 1011 "program_parse.y"
     { (yyval.swiz_mask).swizzle = SWIZZLE_NOOP; (yyval.swiz_mask).mask = WRITEMASK_XYZW; ;}
     break;
 
   case 88:
 
 /* Line 1455 of yacc.c  */
-#line 1006 "program_parse.y"
+#line 1015 "program_parse.y"
     { (yyval.swiz_mask).swizzle = SWIZZLE_NOOP; (yyval.swiz_mask).mask = WRITEMASK_XYZW; ;}
     break;
 
   case 89:
 
 /* Line 1455 of yacc.c  */
-#line 1010 "program_parse.y"
+#line 1019 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(2) - (3)].dst_reg);
 	;}
@@ -3080,7 +3089,7 @@ yyreduce:
   case 90:
 
 /* Line 1455 of yacc.c  */
-#line 1014 "program_parse.y"
+#line 1023 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(2) - (3)].dst_reg);
 	;}
@@ -3089,7 +3098,7 @@ yyreduce:
   case 91:
 
 /* Line 1455 of yacc.c  */
-#line 1018 "program_parse.y"
+#line 1027 "program_parse.y"
     {
 	   (yyval.dst_reg).CondMask = COND_TR;
 	   (yyval.dst_reg).CondSwizzle = SWIZZLE_NOOP;
@@ -3100,7 +3109,7 @@ yyreduce:
   case 92:
 
 /* Line 1455 of yacc.c  */
-#line 1026 "program_parse.y"
+#line 1035 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (2)].dst_reg);
 	   (yyval.dst_reg).CondSwizzle = (yyvsp[(2) - (2)].swiz_mask).swizzle;
@@ -3110,7 +3119,7 @@ yyreduce:
   case 93:
 
 /* Line 1455 of yacc.c  */
-#line 1033 "program_parse.y"
+#line 1042 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (2)].dst_reg);
 	   (yyval.dst_reg).CondSwizzle = (yyvsp[(2) - (2)].swiz_mask).swizzle;
@@ -3120,7 +3129,7 @@ yyreduce:
   case 94:
 
 /* Line 1455 of yacc.c  */
-#line 1040 "program_parse.y"
+#line 1049 "program_parse.y"
     {
 	   const int cond = _mesa_parse_cc((yyvsp[(1) - (1)].string));
 	   if ((cond == 0) || ((yyvsp[(1) - (1)].string)[2] != '\0')) {
@@ -3146,7 +3155,7 @@ yyreduce:
   case 95:
 
 /* Line 1455 of yacc.c  */
-#line 1063 "program_parse.y"
+#line 1072 "program_parse.y"
     {
 	   const int cond = _mesa_parse_cc((yyvsp[(1) - (1)].string));
 	   if ((cond == 0) || ((yyvsp[(1) - (1)].string)[2] != '\0')) {
@@ -3172,7 +3181,7 @@ yyreduce:
   case 102:
 
 /* Line 1455 of yacc.c  */
-#line 1094 "program_parse.y"
+#line 1103 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(2) - (4)].string), at_attrib, & (yylsp[(2) - (4)]));
@@ -3194,7 +3203,7 @@ yyreduce:
   case 103:
 
 /* Line 1455 of yacc.c  */
-#line 1113 "program_parse.y"
+#line 1122 "program_parse.y"
     {
 	   (yyval.attrib) = (yyvsp[(2) - (2)].attrib);
 	;}
@@ -3203,7 +3212,7 @@ yyreduce:
   case 104:
 
 /* Line 1455 of yacc.c  */
-#line 1117 "program_parse.y"
+#line 1126 "program_parse.y"
     {
 	   (yyval.attrib) = (yyvsp[(2) - (2)].attrib);
 	;}
@@ -3212,7 +3221,7 @@ yyreduce:
   case 105:
 
 /* Line 1455 of yacc.c  */
-#line 1123 "program_parse.y"
+#line 1132 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_POS;
 	;}
@@ -3221,7 +3230,7 @@ yyreduce:
   case 106:
 
 /* Line 1455 of yacc.c  */
-#line 1127 "program_parse.y"
+#line 1136 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_WEIGHT;
 	;}
@@ -3230,7 +3239,7 @@ yyreduce:
   case 107:
 
 /* Line 1455 of yacc.c  */
-#line 1131 "program_parse.y"
+#line 1140 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_NORMAL;
 	;}
@@ -3239,7 +3248,7 @@ yyreduce:
   case 108:
 
 /* Line 1455 of yacc.c  */
-#line 1135 "program_parse.y"
+#line 1144 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_secondary_color) {
 	      yyerror(& (yylsp[(2) - (2)]), state, "GL_EXT_secondary_color not supported");
@@ -3253,7 +3262,7 @@ yyreduce:
   case 109:
 
 /* Line 1455 of yacc.c  */
-#line 1144 "program_parse.y"
+#line 1153 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_fog_coord) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "GL_EXT_fog_coord not supported");
@@ -3267,7 +3276,7 @@ yyreduce:
   case 110:
 
 /* Line 1455 of yacc.c  */
-#line 1153 "program_parse.y"
+#line 1162 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_TEX0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3276,7 +3285,7 @@ yyreduce:
   case 111:
 
 /* Line 1455 of yacc.c  */
-#line 1157 "program_parse.y"
+#line 1166 "program_parse.y"
     {
 	   yyerror(& (yylsp[(1) - (4)]), state, "GL_ARB_matrix_palette not supported");
 	   YYERROR;
@@ -3286,7 +3295,7 @@ yyreduce:
   case 112:
 
 /* Line 1455 of yacc.c  */
-#line 1162 "program_parse.y"
+#line 1171 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_GENERIC0 + (yyvsp[(3) - (4)].integer);
 	;}
@@ -3295,7 +3304,7 @@ yyreduce:
   case 113:
 
 /* Line 1455 of yacc.c  */
-#line 1168 "program_parse.y"
+#line 1177 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxAttribs) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid vertex attribute reference");
@@ -3309,7 +3318,7 @@ yyreduce:
   case 117:
 
 /* Line 1455 of yacc.c  */
-#line 1182 "program_parse.y"
+#line 1191 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_WPOS;
 	;}
@@ -3318,7 +3327,7 @@ yyreduce:
   case 118:
 
 /* Line 1455 of yacc.c  */
-#line 1186 "program_parse.y"
+#line 1195 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_COL0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3327,7 +3336,7 @@ yyreduce:
   case 119:
 
 /* Line 1455 of yacc.c  */
-#line 1190 "program_parse.y"
+#line 1199 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_FOGC;
 	;}
@@ -3336,7 +3345,7 @@ yyreduce:
   case 120:
 
 /* Line 1455 of yacc.c  */
-#line 1194 "program_parse.y"
+#line 1203 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_TEX0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3345,7 +3354,7 @@ yyreduce:
   case 123:
 
 /* Line 1455 of yacc.c  */
-#line 1202 "program_parse.y"
+#line 1211 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(2) - (3)].string), at_param, & (yylsp[(2) - (3)]));
@@ -3357,6 +3366,7 @@ yyreduce:
 	      s->param_binding_type = (yyvsp[(3) - (3)].temp_sym).param_binding_type;
 	      s->param_binding_begin = (yyvsp[(3) - (3)].temp_sym).param_binding_begin;
 	      s->param_binding_length = (yyvsp[(3) - (3)].temp_sym).param_binding_length;
+              s->param_binding_swizzle = SWIZZLE_XYZW;
 	      s->param_is_array = 0;
 	   }
 	;}
@@ -3365,7 +3375,7 @@ yyreduce:
   case 124:
 
 /* Line 1455 of yacc.c  */
-#line 1219 "program_parse.y"
+#line 1229 "program_parse.y"
     {
 	   if (((yyvsp[(4) - (6)].integer) != 0) && ((unsigned) (yyvsp[(4) - (6)].integer) != (yyvsp[(6) - (6)].temp_sym).param_binding_length)) {
 	      free((yyvsp[(2) - (6)].string));
@@ -3383,6 +3393,7 @@ yyreduce:
 		 s->param_binding_type = (yyvsp[(6) - (6)].temp_sym).param_binding_type;
 		 s->param_binding_begin = (yyvsp[(6) - (6)].temp_sym).param_binding_begin;
 		 s->param_binding_length = (yyvsp[(6) - (6)].temp_sym).param_binding_length;
+                 s->param_binding_swizzle = SWIZZLE_XYZW;
 		 s->param_is_array = 1;
 	      }
 	   }
@@ -3392,7 +3403,7 @@ yyreduce:
   case 125:
 
 /* Line 1455 of yacc.c  */
-#line 1243 "program_parse.y"
+#line 1254 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -3401,7 +3412,7 @@ yyreduce:
   case 126:
 
 /* Line 1455 of yacc.c  */
-#line 1247 "program_parse.y"
+#line 1258 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 1) || ((unsigned) (yyvsp[(1) - (1)].integer) > state->limits->MaxParameters)) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid parameter array size");
@@ -3415,7 +3426,7 @@ yyreduce:
   case 127:
 
 /* Line 1455 of yacc.c  */
-#line 1258 "program_parse.y"
+#line 1269 "program_parse.y"
     {
 	   (yyval.temp_sym) = (yyvsp[(2) - (2)].temp_sym);
 	;}
@@ -3424,7 +3435,7 @@ yyreduce:
   case 128:
 
 /* Line 1455 of yacc.c  */
-#line 1264 "program_parse.y"
+#line 1275 "program_parse.y"
     {
 	   (yyval.temp_sym) = (yyvsp[(3) - (4)].temp_sym);
 	;}
@@ -3433,7 +3444,7 @@ yyreduce:
   case 130:
 
 /* Line 1455 of yacc.c  */
-#line 1271 "program_parse.y"
+#line 1282 "program_parse.y"
     {
 	   (yyvsp[(1) - (3)].temp_sym).param_binding_length += (yyvsp[(3) - (3)].temp_sym).param_binding_length;
 	   (yyval.temp_sym) = (yyvsp[(1) - (3)].temp_sym);
@@ -3443,7 +3454,7 @@ yyreduce:
   case 131:
 
 /* Line 1455 of yacc.c  */
-#line 1278 "program_parse.y"
+#line 1289 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3454,7 +3465,7 @@ yyreduce:
   case 132:
 
 /* Line 1455 of yacc.c  */
-#line 1284 "program_parse.y"
+#line 1295 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3465,18 +3476,18 @@ yyreduce:
   case 133:
 
 /* Line 1455 of yacc.c  */
-#line 1290 "program_parse.y"
+#line 1301 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_TRUE);
 	;}
     break;
 
   case 134:
 
 /* Line 1455 of yacc.c  */
-#line 1298 "program_parse.y"
+#line 1309 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3487,7 +3498,7 @@ yyreduce:
   case 135:
 
 /* Line 1455 of yacc.c  */
-#line 1304 "program_parse.y"
+#line 1315 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3498,18 +3509,18 @@ yyreduce:
   case 136:
 
 /* Line 1455 of yacc.c  */
-#line 1310 "program_parse.y"
+#line 1321 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_TRUE);
 	;}
     break;
 
   case 137:
 
 /* Line 1455 of yacc.c  */
-#line 1318 "program_parse.y"
+#line 1329 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3520,7 +3531,7 @@ yyreduce:
   case 138:
 
 /* Line 1455 of yacc.c  */
-#line 1324 "program_parse.y"
+#line 1335 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3531,109 +3542,109 @@ yyreduce:
   case 139:
 
 /* Line 1455 of yacc.c  */
-#line 1330 "program_parse.y"
+#line 1341 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_FALSE);
 	;}
     break;
 
   case 140:
 
 /* Line 1455 of yacc.c  */
-#line 1337 "program_parse.y"
+#line 1348 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(1) - (1)].state), sizeof((yyval.state))); ;}
     break;
 
   case 141:
 
 /* Line 1455 of yacc.c  */
-#line 1338 "program_parse.y"
+#line 1349 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 142:
 
 /* Line 1455 of yacc.c  */
-#line 1341 "program_parse.y"
+#line 1352 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 143:
 
 /* Line 1455 of yacc.c  */
-#line 1342 "program_parse.y"
+#line 1353 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 144:
 
 /* Line 1455 of yacc.c  */
-#line 1343 "program_parse.y"
+#line 1354 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 145:
 
 /* Line 1455 of yacc.c  */
-#line 1344 "program_parse.y"
+#line 1355 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 146:
 
 /* Line 1455 of yacc.c  */
-#line 1345 "program_parse.y"
+#line 1356 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 147:
 
 /* Line 1455 of yacc.c  */
-#line 1346 "program_parse.y"
+#line 1357 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 148:
 
 /* Line 1455 of yacc.c  */
-#line 1347 "program_parse.y"
+#line 1358 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 149:
 
 /* Line 1455 of yacc.c  */
-#line 1348 "program_parse.y"
+#line 1359 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 150:
 
 /* Line 1455 of yacc.c  */
-#line 1349 "program_parse.y"
+#line 1360 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 151:
 
 /* Line 1455 of yacc.c  */
-#line 1350 "program_parse.y"
+#line 1361 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 152:
 
 /* Line 1455 of yacc.c  */
-#line 1351 "program_parse.y"
+#line 1362 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 153:
 
 /* Line 1455 of yacc.c  */
-#line 1355 "program_parse.y"
+#line 1366 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_MATERIAL;
@@ -3645,7 +3656,7 @@ yyreduce:
   case 154:
 
 /* Line 1455 of yacc.c  */
-#line 1364 "program_parse.y"
+#line 1375 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -3654,7 +3665,7 @@ yyreduce:
   case 155:
 
 /* Line 1455 of yacc.c  */
-#line 1368 "program_parse.y"
+#line 1379 "program_parse.y"
     {
 	   (yyval.integer) = STATE_EMISSION;
 	;}
@@ -3663,7 +3674,7 @@ yyreduce:
   case 156:
 
 /* Line 1455 of yacc.c  */
-#line 1372 "program_parse.y"
+#line 1383 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SHININESS;
 	;}
@@ -3672,7 +3683,7 @@ yyreduce:
   case 157:
 
 /* Line 1455 of yacc.c  */
-#line 1378 "program_parse.y"
+#line 1389 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHT;
@@ -3684,7 +3695,7 @@ yyreduce:
   case 158:
 
 /* Line 1455 of yacc.c  */
-#line 1387 "program_parse.y"
+#line 1398 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -3693,7 +3704,7 @@ yyreduce:
   case 159:
 
 /* Line 1455 of yacc.c  */
-#line 1391 "program_parse.y"
+#line 1402 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POSITION;
 	;}
@@ -3702,7 +3713,7 @@ yyreduce:
   case 160:
 
 /* Line 1455 of yacc.c  */
-#line 1395 "program_parse.y"
+#line 1406 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_point_parameters) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "GL_ARB_point_parameters not supported");
@@ -3716,7 +3727,7 @@ yyreduce:
   case 161:
 
 /* Line 1455 of yacc.c  */
-#line 1404 "program_parse.y"
+#line 1415 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (2)].integer);
 	;}
@@ -3725,7 +3736,7 @@ yyreduce:
   case 162:
 
 /* Line 1455 of yacc.c  */
-#line 1408 "program_parse.y"
+#line 1419 "program_parse.y"
     {
 	   (yyval.integer) = STATE_HALF_VECTOR;
 	;}
@@ -3734,7 +3745,7 @@ yyreduce:
   case 163:
 
 /* Line 1455 of yacc.c  */
-#line 1414 "program_parse.y"
+#line 1425 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SPOT_DIRECTION;
 	;}
@@ -3743,7 +3754,7 @@ yyreduce:
   case 164:
 
 /* Line 1455 of yacc.c  */
-#line 1420 "program_parse.y"
+#line 1431 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].state)[1];
@@ -3753,7 +3764,7 @@ yyreduce:
   case 165:
 
 /* Line 1455 of yacc.c  */
-#line 1427 "program_parse.y"
+#line 1438 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTMODEL_AMBIENT;
@@ -3763,7 +3774,7 @@ yyreduce:
   case 166:
 
 /* Line 1455 of yacc.c  */
-#line 1432 "program_parse.y"
+#line 1443 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTMODEL_SCENECOLOR;
@@ -3774,7 +3785,7 @@ yyreduce:
   case 167:
 
 /* Line 1455 of yacc.c  */
-#line 1440 "program_parse.y"
+#line 1451 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTPROD;
@@ -3787,7 +3798,7 @@ yyreduce:
   case 169:
 
 /* Line 1455 of yacc.c  */
-#line 1452 "program_parse.y"
+#line 1463 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(3) - (3)].integer);
@@ -3798,7 +3809,7 @@ yyreduce:
   case 170:
 
 /* Line 1455 of yacc.c  */
-#line 1460 "program_parse.y"
+#line 1471 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXENV_COLOR;
 	;}
@@ -3807,7 +3818,7 @@ yyreduce:
   case 171:
 
 /* Line 1455 of yacc.c  */
-#line 1466 "program_parse.y"
+#line 1477 "program_parse.y"
     {
 	   (yyval.integer) = STATE_AMBIENT;
 	;}
@@ -3816,7 +3827,7 @@ yyreduce:
   case 172:
 
 /* Line 1455 of yacc.c  */
-#line 1470 "program_parse.y"
+#line 1481 "program_parse.y"
     {
 	   (yyval.integer) = STATE_DIFFUSE;
 	;}
@@ -3825,7 +3836,7 @@ yyreduce:
   case 173:
 
 /* Line 1455 of yacc.c  */
-#line 1474 "program_parse.y"
+#line 1485 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SPECULAR;
 	;}
@@ -3834,7 +3845,7 @@ yyreduce:
   case 174:
 
 /* Line 1455 of yacc.c  */
-#line 1480 "program_parse.y"
+#line 1491 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxLights) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid light selector");
@@ -3848,7 +3859,7 @@ yyreduce:
   case 175:
 
 /* Line 1455 of yacc.c  */
-#line 1491 "program_parse.y"
+#line 1502 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_TEXGEN;
@@ -3860,7 +3871,7 @@ yyreduce:
   case 176:
 
 /* Line 1455 of yacc.c  */
-#line 1500 "program_parse.y"
+#line 1511 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_S;
 	;}
@@ -3869,7 +3880,7 @@ yyreduce:
   case 177:
 
 /* Line 1455 of yacc.c  */
-#line 1504 "program_parse.y"
+#line 1515 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_OBJECT_S;
 	;}
@@ -3878,7 +3889,7 @@ yyreduce:
   case 178:
 
 /* Line 1455 of yacc.c  */
-#line 1509 "program_parse.y"
+#line 1520 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_S - STATE_TEXGEN_EYE_S;
 	;}
@@ -3887,7 +3898,7 @@ yyreduce:
   case 179:
 
 /* Line 1455 of yacc.c  */
-#line 1513 "program_parse.y"
+#line 1524 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_T - STATE_TEXGEN_EYE_S;
 	;}
@@ -3896,7 +3907,7 @@ yyreduce:
   case 180:
 
 /* Line 1455 of yacc.c  */
-#line 1517 "program_parse.y"
+#line 1528 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_R - STATE_TEXGEN_EYE_S;
 	;}
@@ -3905,7 +3916,7 @@ yyreduce:
   case 181:
 
 /* Line 1455 of yacc.c  */
-#line 1521 "program_parse.y"
+#line 1532 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_Q - STATE_TEXGEN_EYE_S;
 	;}
@@ -3914,7 +3925,7 @@ yyreduce:
   case 182:
 
 /* Line 1455 of yacc.c  */
-#line 1527 "program_parse.y"
+#line 1538 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].integer);
@@ -3924,7 +3935,7 @@ yyreduce:
   case 183:
 
 /* Line 1455 of yacc.c  */
-#line 1534 "program_parse.y"
+#line 1545 "program_parse.y"
     {
 	   (yyval.integer) = STATE_FOG_COLOR;
 	;}
@@ -3933,7 +3944,7 @@ yyreduce:
   case 184:
 
 /* Line 1455 of yacc.c  */
-#line 1538 "program_parse.y"
+#line 1549 "program_parse.y"
     {
 	   (yyval.integer) = STATE_FOG_PARAMS;
 	;}
@@ -3942,7 +3953,7 @@ yyreduce:
   case 185:
 
 /* Line 1455 of yacc.c  */
-#line 1544 "program_parse.y"
+#line 1555 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_CLIPPLANE;
@@ -3953,7 +3964,7 @@ yyreduce:
   case 186:
 
 /* Line 1455 of yacc.c  */
-#line 1552 "program_parse.y"
+#line 1563 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxClipPlanes) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid clip plane selector");
@@ -3967,7 +3978,7 @@ yyreduce:
   case 187:
 
 /* Line 1455 of yacc.c  */
-#line 1563 "program_parse.y"
+#line 1574 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].integer);
@@ -3977,7 +3988,7 @@ yyreduce:
   case 188:
 
 /* Line 1455 of yacc.c  */
-#line 1570 "program_parse.y"
+#line 1581 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POINT_SIZE;
 	;}
@@ -3986,7 +3997,7 @@ yyreduce:
   case 189:
 
 /* Line 1455 of yacc.c  */
-#line 1574 "program_parse.y"
+#line 1585 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POINT_ATTENUATION;
 	;}
@@ -3995,7 +4006,7 @@ yyreduce:
   case 190:
 
 /* Line 1455 of yacc.c  */
-#line 1580 "program_parse.y"
+#line 1591 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (5)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(1) - (5)].state)[1];
@@ -4008,7 +4019,7 @@ yyreduce:
   case 191:
 
 /* Line 1455 of yacc.c  */
-#line 1590 "program_parse.y"
+#line 1601 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (2)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(1) - (2)].state)[1];
@@ -4021,7 +4032,7 @@ yyreduce:
   case 192:
 
 /* Line 1455 of yacc.c  */
-#line 1600 "program_parse.y"
+#line 1611 "program_parse.y"
     {
 	   (yyval.state)[2] = 0;
 	   (yyval.state)[3] = 3;
@@ -4031,7 +4042,7 @@ yyreduce:
   case 193:
 
 /* Line 1455 of yacc.c  */
-#line 1605 "program_parse.y"
+#line 1616 "program_parse.y"
     {
 	   /* It seems logical that the matrix row range specifier would have
 	    * to specify a range or more than one row (i.e., $5 > $3).
@@ -4052,7 +4063,7 @@ yyreduce:
   case 194:
 
 /* Line 1455 of yacc.c  */
-#line 1623 "program_parse.y"
+#line 1634 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(2) - (3)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(2) - (3)].state)[1];
@@ -4063,7 +4074,7 @@ yyreduce:
   case 195:
 
 /* Line 1455 of yacc.c  */
-#line 1631 "program_parse.y"
+#line 1642 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -4072,7 +4083,7 @@ yyreduce:
   case 196:
 
 /* Line 1455 of yacc.c  */
-#line 1635 "program_parse.y"
+#line 1646 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -4081,7 +4092,7 @@ yyreduce:
   case 197:
 
 /* Line 1455 of yacc.c  */
-#line 1641 "program_parse.y"
+#line 1652 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_INVERSE;
 	;}
@@ -4090,7 +4101,7 @@ yyreduce:
   case 198:
 
 /* Line 1455 of yacc.c  */
-#line 1645 "program_parse.y"
+#line 1656 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_TRANSPOSE;
 	;}
@@ -4099,7 +4110,7 @@ yyreduce:
   case 199:
 
 /* Line 1455 of yacc.c  */
-#line 1649 "program_parse.y"
+#line 1660 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_INVTRANS;
 	;}
@@ -4108,7 +4119,7 @@ yyreduce:
   case 200:
 
 /* Line 1455 of yacc.c  */
-#line 1655 "program_parse.y"
+#line 1666 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].integer) > 3) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid matrix row reference");
@@ -4122,7 +4133,7 @@ yyreduce:
   case 201:
 
 /* Line 1455 of yacc.c  */
-#line 1666 "program_parse.y"
+#line 1677 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_MODELVIEW_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].integer);
@@ -4132,7 +4143,7 @@ yyreduce:
   case 202:
 
 /* Line 1455 of yacc.c  */
-#line 1671 "program_parse.y"
+#line 1682 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_PROJECTION_MATRIX;
 	   (yyval.state)[1] = 0;
@@ -4142,7 +4153,7 @@ yyreduce:
   case 203:
 
 /* Line 1455 of yacc.c  */
-#line 1676 "program_parse.y"
+#line 1687 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_MVP_MATRIX;
 	   (yyval.state)[1] = 0;
@@ -4152,7 +4163,7 @@ yyreduce:
   case 204:
 
 /* Line 1455 of yacc.c  */
-#line 1681 "program_parse.y"
+#line 1692 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_TEXTURE_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].integer);
@@ -4162,7 +4173,7 @@ yyreduce:
   case 205:
 
 /* Line 1455 of yacc.c  */
-#line 1686 "program_parse.y"
+#line 1697 "program_parse.y"
     {
 	   yyerror(& (yylsp[(1) - (4)]), state, "GL_ARB_matrix_palette not supported");
 	   YYERROR;
@@ -4172,7 +4183,7 @@ yyreduce:
   case 206:
 
 /* Line 1455 of yacc.c  */
-#line 1691 "program_parse.y"
+#line 1702 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_PROGRAM_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(3) - (4)].integer);
@@ -4182,7 +4193,7 @@ yyreduce:
   case 207:
 
 /* Line 1455 of yacc.c  */
-#line 1698 "program_parse.y"
+#line 1709 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -4191,7 +4202,7 @@ yyreduce:
   case 208:
 
 /* Line 1455 of yacc.c  */
-#line 1702 "program_parse.y"
+#line 1713 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (3)].integer);
 	;}
@@ -4200,7 +4211,7 @@ yyreduce:
   case 209:
 
 /* Line 1455 of yacc.c  */
-#line 1707 "program_parse.y"
+#line 1718 "program_parse.y"
     {
 	   /* Since GL_ARB_vertex_blend isn't supported, only modelview matrix
 	    * zero is valid.
@@ -4217,7 +4228,7 @@ yyreduce:
   case 210:
 
 /* Line 1455 of yacc.c  */
-#line 1720 "program_parse.y"
+#line 1731 "program_parse.y"
     {
 	   /* Since GL_ARB_matrix_palette isn't supported, just let any value
 	    * through here.  The error will be generated later.
@@ -4229,7 +4240,7 @@ yyreduce:
   case 211:
 
 /* Line 1455 of yacc.c  */
-#line 1728 "program_parse.y"
+#line 1739 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxProgramMatrices) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid program matrix selector");
@@ -4243,7 +4254,7 @@ yyreduce:
   case 212:
 
 /* Line 1455 of yacc.c  */
-#line 1739 "program_parse.y"
+#line 1750 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_DEPTH_RANGE;
@@ -4253,7 +4264,7 @@ yyreduce:
   case 217:
 
 /* Line 1455 of yacc.c  */
-#line 1751 "program_parse.y"
+#line 1762 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4266,7 +4277,7 @@ yyreduce:
   case 218:
 
 /* Line 1455 of yacc.c  */
-#line 1761 "program_parse.y"
+#line 1772 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (1)].integer);
 	   (yyval.state)[1] = (yyvsp[(1) - (1)].integer);
@@ -4276,7 +4287,7 @@ yyreduce:
   case 219:
 
 /* Line 1455 of yacc.c  */
-#line 1766 "program_parse.y"
+#line 1777 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (3)].integer);
 	   (yyval.state)[1] = (yyvsp[(3) - (3)].integer);
@@ -4286,7 +4297,7 @@ yyreduce:
   case 220:
 
 /* Line 1455 of yacc.c  */
-#line 1773 "program_parse.y"
+#line 1784 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4299,7 +4310,7 @@ yyreduce:
   case 221:
 
 /* Line 1455 of yacc.c  */
-#line 1783 "program_parse.y"
+#line 1794 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4312,7 +4323,7 @@ yyreduce:
   case 222:
 
 /* Line 1455 of yacc.c  */
-#line 1792 "program_parse.y"
+#line 1803 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (1)].integer);
 	   (yyval.state)[1] = (yyvsp[(1) - (1)].integer);
@@ -4322,7 +4333,7 @@ yyreduce:
   case 223:
 
 /* Line 1455 of yacc.c  */
-#line 1797 "program_parse.y"
+#line 1808 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (3)].integer);
 	   (yyval.state)[1] = (yyvsp[(3) - (3)].integer);
@@ -4332,7 +4343,7 @@ yyreduce:
   case 224:
 
 /* Line 1455 of yacc.c  */
-#line 1804 "program_parse.y"
+#line 1815 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4345,7 +4356,7 @@ yyreduce:
   case 225:
 
 /* Line 1455 of yacc.c  */
-#line 1814 "program_parse.y"
+#line 1825 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxEnvParams) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid environment parameter reference");
@@ -4358,7 +4369,7 @@ yyreduce:
   case 226:
 
 /* Line 1455 of yacc.c  */
-#line 1824 "program_parse.y"
+#line 1835 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxLocalParams) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid local parameter reference");
@@ -4371,7 +4382,7 @@ yyreduce:
   case 231:
 
 /* Line 1455 of yacc.c  */
-#line 1839 "program_parse.y"
+#line 1850 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(1) - (1)].real);
@@ -4384,7 +4395,7 @@ yyreduce:
   case 232:
 
 /* Line 1455 of yacc.c  */
-#line 1849 "program_parse.y"
+#line 1860 "program_parse.y"
     {
 	   (yyval.vector).count = 1;
 	   (yyval.vector).data[0] = (yyvsp[(1) - (1)].real);
@@ -4397,7 +4408,7 @@ yyreduce:
   case 233:
 
 /* Line 1455 of yacc.c  */
-#line 1857 "program_parse.y"
+#line 1868 "program_parse.y"
     {
 	   (yyval.vector).count = 1;
 	   (yyval.vector).data[0] = (float) (yyvsp[(1) - (1)].integer);
@@ -4410,7 +4421,7 @@ yyreduce:
   case 234:
 
 /* Line 1455 of yacc.c  */
-#line 1867 "program_parse.y"
+#line 1878 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (3)].real);
@@ -4423,7 +4434,7 @@ yyreduce:
   case 235:
 
 /* Line 1455 of yacc.c  */
-#line 1875 "program_parse.y"
+#line 1886 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (5)].real);
@@ -4436,7 +4447,7 @@ yyreduce:
   case 236:
 
 /* Line 1455 of yacc.c  */
-#line 1884 "program_parse.y"
+#line 1895 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (7)].real);
@@ -4449,7 +4460,7 @@ yyreduce:
   case 237:
 
 /* Line 1455 of yacc.c  */
-#line 1893 "program_parse.y"
+#line 1904 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (9)].real);
@@ -4462,7 +4473,7 @@ yyreduce:
   case 238:
 
 /* Line 1455 of yacc.c  */
-#line 1903 "program_parse.y"
+#line 1914 "program_parse.y"
     {
 	   (yyval.real) = ((yyvsp[(1) - (2)].negate)) ? -(yyvsp[(2) - (2)].real) : (yyvsp[(2) - (2)].real);
 	;}
@@ -4471,7 +4482,7 @@ yyreduce:
   case 239:
 
 /* Line 1455 of yacc.c  */
-#line 1907 "program_parse.y"
+#line 1918 "program_parse.y"
     {
 	   (yyval.real) = (float)(((yyvsp[(1) - (2)].negate)) ? -(yyvsp[(2) - (2)].integer) : (yyvsp[(2) - (2)].integer));
 	;}
@@ -4480,35 +4491,35 @@ yyreduce:
   case 240:
 
 /* Line 1455 of yacc.c  */
-#line 1912 "program_parse.y"
+#line 1923 "program_parse.y"
     { (yyval.negate) = FALSE; ;}
     break;
 
   case 241:
 
 /* Line 1455 of yacc.c  */
-#line 1913 "program_parse.y"
+#line 1924 "program_parse.y"
     { (yyval.negate) = TRUE;  ;}
     break;
 
   case 242:
 
 /* Line 1455 of yacc.c  */
-#line 1914 "program_parse.y"
+#line 1925 "program_parse.y"
     { (yyval.negate) = FALSE; ;}
     break;
 
   case 243:
 
 /* Line 1455 of yacc.c  */
-#line 1917 "program_parse.y"
+#line 1928 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 245:
 
 /* Line 1455 of yacc.c  */
-#line 1921 "program_parse.y"
+#line 1932 "program_parse.y"
     {
 	   /* NV_fragment_program_option defines the size qualifiers in a
 	    * fairly broken way.  "SHORT" or "LONG" can optionally be used
@@ -4547,7 +4558,7 @@ yyreduce:
   case 246:
 
 /* Line 1455 of yacc.c  */
-#line 1955 "program_parse.y"
+#line 1966 "program_parse.y"
     {
 	;}
     break;
@@ -4555,14 +4566,14 @@ yyreduce:
   case 247:
 
 /* Line 1455 of yacc.c  */
-#line 1959 "program_parse.y"
+#line 1970 "program_parse.y"
     { (yyval.integer) = (yyvsp[(1) - (1)].integer); ;}
     break;
 
   case 249:
 
 /* Line 1455 of yacc.c  */
-#line 1963 "program_parse.y"
+#line 1974 "program_parse.y"
     {
 	   if (!declare_variable(state, (yyvsp[(3) - (3)].string), (yyvsp[(0) - (3)].integer), & (yylsp[(3) - (3)]))) {
 	      free((yyvsp[(3) - (3)].string));
@@ -4574,7 +4585,7 @@ yyreduce:
   case 250:
 
 /* Line 1455 of yacc.c  */
-#line 1970 "program_parse.y"
+#line 1981 "program_parse.y"
     {
 	   if (!declare_variable(state, (yyvsp[(1) - (1)].string), (yyvsp[(0) - (1)].integer), & (yylsp[(1) - (1)]))) {
 	      free((yyvsp[(1) - (1)].string));
@@ -4586,7 +4597,7 @@ yyreduce:
   case 251:
 
 /* Line 1455 of yacc.c  */
-#line 1979 "program_parse.y"
+#line 1990 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(3) - (5)].string), at_output, & (yylsp[(3) - (5)]));
@@ -4603,7 +4614,7 @@ yyreduce:
   case 252:
 
 /* Line 1455 of yacc.c  */
-#line 1993 "program_parse.y"
+#line 2004 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_HPOS;
@@ -4617,7 +4628,7 @@ yyreduce:
   case 253:
 
 /* Line 1455 of yacc.c  */
-#line 2002 "program_parse.y"
+#line 2013 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_FOGC;
@@ -4631,7 +4642,7 @@ yyreduce:
   case 254:
 
 /* Line 1455 of yacc.c  */
-#line 2011 "program_parse.y"
+#line 2022 "program_parse.y"
     {
 	   (yyval.result) = (yyvsp[(2) - (2)].result);
 	;}
@@ -4640,7 +4651,7 @@ yyreduce:
   case 255:
 
 /* Line 1455 of yacc.c  */
-#line 2015 "program_parse.y"
+#line 2026 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_PSIZ;
@@ -4654,7 +4665,7 @@ yyreduce:
   case 256:
 
 /* Line 1455 of yacc.c  */
-#line 2024 "program_parse.y"
+#line 2035 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_TEX0 + (yyvsp[(3) - (3)].integer);
@@ -4668,7 +4679,7 @@ yyreduce:
   case 257:
 
 /* Line 1455 of yacc.c  */
-#line 2033 "program_parse.y"
+#line 2044 "program_parse.y"
     {
 	   if (state->mode == ARB_fragment) {
 	      (yyval.result) = FRAG_RESULT_DEPTH;
@@ -4682,7 +4693,7 @@ yyreduce:
   case 258:
 
 /* Line 1455 of yacc.c  */
-#line 2044 "program_parse.y"
+#line 2055 "program_parse.y"
     {
 	   (yyval.result) = (yyvsp[(2) - (3)].integer) + (yyvsp[(3) - (3)].integer);
 	;}
@@ -4691,7 +4702,7 @@ yyreduce:
   case 259:
 
 /* Line 1455 of yacc.c  */
-#line 2050 "program_parse.y"
+#line 2061 "program_parse.y"
     {
 	   (yyval.integer) = (state->mode == ARB_vertex)
 	      ? VERT_RESULT_COL0
@@ -4702,7 +4713,7 @@ yyreduce:
   case 260:
 
 /* Line 1455 of yacc.c  */
-#line 2056 "program_parse.y"
+#line 2067 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = VERT_RESULT_COL0;
@@ -4716,7 +4727,7 @@ yyreduce:
   case 261:
 
 /* Line 1455 of yacc.c  */
-#line 2065 "program_parse.y"
+#line 2076 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = VERT_RESULT_BFC0;
@@ -4730,7 +4741,7 @@ yyreduce:
   case 262:
 
 /* Line 1455 of yacc.c  */
-#line 2076 "program_parse.y"
+#line 2087 "program_parse.y"
     {
 	   (yyval.integer) = 0; 
 	;}
@@ -4739,7 +4750,7 @@ yyreduce:
   case 263:
 
 /* Line 1455 of yacc.c  */
-#line 2080 "program_parse.y"
+#line 2091 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = 0;
@@ -4753,7 +4764,7 @@ yyreduce:
   case 264:
 
 /* Line 1455 of yacc.c  */
-#line 2089 "program_parse.y"
+#line 2100 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = 1;
@@ -4767,91 +4778,91 @@ yyreduce:
   case 265:
 
 /* Line 1455 of yacc.c  */
-#line 2099 "program_parse.y"
+#line 2110 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 266:
 
 /* Line 1455 of yacc.c  */
-#line 2100 "program_parse.y"
+#line 2111 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 267:
 
 /* Line 1455 of yacc.c  */
-#line 2101 "program_parse.y"
+#line 2112 "program_parse.y"
     { (yyval.integer) = 1; ;}
     break;
 
   case 268:
 
 /* Line 1455 of yacc.c  */
-#line 2104 "program_parse.y"
+#line 2115 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 269:
 
 /* Line 1455 of yacc.c  */
-#line 2105 "program_parse.y"
+#line 2116 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 270:
 
 /* Line 1455 of yacc.c  */
-#line 2106 "program_parse.y"
+#line 2117 "program_parse.y"
     { (yyval.integer) = 1; ;}
     break;
 
   case 271:
 
 /* Line 1455 of yacc.c  */
-#line 2109 "program_parse.y"
+#line 2120 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 272:
 
 /* Line 1455 of yacc.c  */
-#line 2110 "program_parse.y"
+#line 2121 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 273:
 
 /* Line 1455 of yacc.c  */
-#line 2113 "program_parse.y"
+#line 2124 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 274:
 
 /* Line 1455 of yacc.c  */
-#line 2114 "program_parse.y"
+#line 2125 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 275:
 
 /* Line 1455 of yacc.c  */
-#line 2117 "program_parse.y"
+#line 2128 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 276:
 
 /* Line 1455 of yacc.c  */
-#line 2118 "program_parse.y"
+#line 2129 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 277:
 
 /* Line 1455 of yacc.c  */
-#line 2122 "program_parse.y"
+#line 2133 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureCoordUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture coordinate unit selector");
@@ -4865,7 +4876,7 @@ yyreduce:
   case 278:
 
 /* Line 1455 of yacc.c  */
-#line 2133 "program_parse.y"
+#line 2144 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureImageUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture image unit selector");
@@ -4879,7 +4890,7 @@ yyreduce:
   case 279:
 
 /* Line 1455 of yacc.c  */
-#line 2144 "program_parse.y"
+#line 2155 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture unit selector");
@@ -4893,7 +4904,7 @@ yyreduce:
   case 280:
 
 /* Line 1455 of yacc.c  */
-#line 2155 "program_parse.y"
+#line 2166 "program_parse.y"
     {
 	   struct asm_symbol *exist = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(2) - (4)].string));
@@ -4922,7 +4933,7 @@ yyreduce:
 
 
 /* Line 1455 of yacc.c  */
-#line 4926 "program_parse.tab.c"
+#line 4937 "program_parse.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -5141,7 +5152,7 @@ yyreturn:
 
 
 /* Line 1675 of yacc.c  */
-#line 2184 "program_parse.y"
+#line 2195 "program_parse.y"
 
 
 void
@@ -5248,7 +5259,9 @@ set_dst_reg(struct prog_dst_register *r, gl_register_file file, GLint index)
    const GLint maxIndex = 1 << INST_INDEX_BITS;
    const GLint minIndex = 0;
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
+   (void) maxIndex;
    ASSERT(file == PROGRAM_TEMPORARY ||
 	  file == PROGRAM_ADDRESS ||
 	  file == PROGRAM_OUTPUT);
@@ -5271,19 +5284,31 @@ init_src_reg(struct asm_src_register *r)
 }
 
 
-/** Like init_src_reg() but set the File and Index fields. */
+/** Like init_src_reg() but set the File and Index fields.
+ * \return GL_TRUE if a valid src register, GL_FALSE otherwise
+ */
 void
 set_src_reg(struct asm_src_register *r, gl_register_file file, GLint index)
 {
+   set_src_reg_swz(r, file, index, SWIZZLE_XYZW);
+}
+
+
+void
+set_src_reg_swz(struct asm_src_register *r, gl_register_file file, GLint index,
+                GLuint swizzle)
+{
    const GLint maxIndex = (1 << INST_INDEX_BITS) - 1;
    const GLint minIndex = -(1 << INST_INDEX_BITS);
+   ASSERT(file < PROGRAM_FILE_MAX);
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
-   ASSERT(file < PROGRAM_FILE_MAX);
+   (void) maxIndex;
    memset(r, 0, sizeof(*r));
    r->Base.File = file;
    r->Base.Index = index;
-   r->Base.Swizzle = SWIZZLE_NOOP;
+   r->Base.Swizzle = swizzle;
    r->Symbol = NULL;
 }
 
@@ -5415,15 +5440,20 @@ initialize_symbol_from_state(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
+
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -5447,9 +5477,12 @@ initialize_symbol_from_param(struct gl_program *prog,
    assert((state_tokens[1] == STATE_ENV)
 	  || (state_tokens[1] == STATE_LOCAL));
 
+   /*
+    * The param type is STATE_VAR.  The program parameter entry will
+    * effectively be a pointer into the LOCAL or ENV parameter array.
+    */
    param_var->type = at_param;
-   param_var->param_binding_type = (state_tokens[1] == STATE_ENV)
-     ? PROGRAM_ENV_PARAM : PROGRAM_LOCAL_PARAM;
+   param_var->param_binding_type = PROGRAM_STATE_VAR;
 
    /* If we are adding a STATE_ENV or STATE_LOCAL that has multiple elements,
     * we need to unroll it and call add_state_reference() for each row
@@ -5463,15 +5496,19 @@ initialize_symbol_from_param(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -5479,20 +5516,34 @@ initialize_symbol_from_param(struct gl_program *prog,
 }
 
 
+/**
+ * Put a float/vector constant/literal into the parameter list.
+ * \param param_var  returns info about the parameter/constant's location,
+ *                   binding, type, etc.
+ * \param vec  the vector/constant to add
+ * \param allowSwizzle  if true, try to consolidate constants which only differ
+ *                      by a swizzle.  We don't want to do this when building
+ *                      arrays of constants that may be indexed indirectly.
+ * \return index of the constant in the parameter list.
+ */
 int
 initialize_symbol_from_const(struct gl_program *prog,
 			     struct asm_symbol *param_var, 
-			     const struct asm_vector *vec)
+			     const struct asm_vector *vec,
+                             GLboolean allowSwizzle)
 {
-   const int idx = _mesa_add_parameter(prog->Parameters, PROGRAM_CONSTANT,
-				       NULL, vec->count, GL_NONE, vec->data,
-				       NULL, 0x0);
+   unsigned swizzle;
+   const int idx = _mesa_add_unnamed_constant(prog->Parameters,
+                                              vec->data, vec->count,
+                                              allowSwizzle ? &swizzle : NULL);
 
    param_var->type = at_param;
    param_var->param_binding_type = PROGRAM_CONSTANT;
 
-   if (param_var->param_binding_begin == ~0U)
+   if (param_var->param_binding_begin == ~0U) {
       param_var->param_binding_begin = idx;
+      param_var->param_binding_swizzle = allowSwizzle ? swizzle : SWIZZLE_XYZW;
+   }
    param_var->param_binding_length++;
 
    return idx;
diff --git a/src/mesa/shader/program_parse.tab.h b/src/mesa/shader/program_parse.tab.h
index 406100c..045241d 100644
--- a/src/mesa/shader/program_parse.tab.h
+++ b/src/mesa/shader/program_parse.tab.h
@@ -154,7 +154,7 @@ typedef union YYSTYPE
 {
 
 /* Line 1676 of yacc.c  */
-#line 122 "program_parse.y"
+#line 126 "program_parse.y"
 
    struct asm_instruction *inst;
    struct asm_symbol *sym;
diff --git a/src/mesa/shader/program_parse.y b/src/mesa/shader/program_parse.y
index 8ca6f98..5c5d8d7 100644
--- a/src/mesa/shader/program_parse.y
+++ b/src/mesa/shader/program_parse.y
@@ -52,7 +52,8 @@ static int initialize_symbol_from_param(struct gl_program *prog,
     struct asm_symbol *param_var, const gl_state_index tokens[STATE_LENGTH]);
 
 static int initialize_symbol_from_const(struct gl_program *prog,
-    struct asm_symbol *param_var, const struct asm_vector *vec);
+    struct asm_symbol *param_var, const struct asm_vector *vec,
+    GLboolean allowSwizzle);
 
 static int yyparse(struct asm_parser_state *state);
 
@@ -74,6 +75,9 @@ static void init_src_reg(struct asm_src_register *r);
 static void set_src_reg(struct asm_src_register *r,
                         gl_register_file file, GLint index);
 
+static void set_src_reg_swz(struct asm_src_register *r,
+                            gl_register_file file, GLint index, GLuint swizzle);
+
 static void asm_instruction_set_operands(struct asm_instruction *inst,
     const struct prog_dst_register *dst, const struct asm_src_register *src0,
     const struct asm_src_register *src1, const struct asm_src_register *src2);
@@ -586,9 +590,11 @@ scalarUse:  srcReg scalarSuffix
 
 	   memset(& temp_sym, 0, sizeof(temp_sym));
 	   temp_sym.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & temp_sym, & $1);
+	   initialize_symbol_from_const(state->prog, & temp_sym, & $1, GL_TRUE);
 
-	   set_src_reg(& $$, PROGRAM_CONSTANT, temp_sym.param_binding_begin);
+	   set_src_reg_swz(& $$, PROGRAM_CONSTANT,
+                           temp_sym.param_binding_begin,
+                           temp_sym.param_binding_swizzle);
 	}
 	;
 
@@ -790,7 +796,9 @@ srcReg: USED_IDENTIFIER /* temporaryReg | progParamSingle */
 	      set_src_reg(& $$, PROGRAM_TEMPORARY, s->temp_binding);
 	      break;
 	   case at_param:
-	      set_src_reg(& $$, s->param_binding_type, s->param_binding_begin);
+              set_src_reg_swz(& $$, s->param_binding_type,
+                              s->param_binding_begin,
+                              s->param_binding_swizzle);
 	      break;
 	   case at_attrib:
 	      set_src_reg(& $$, PROGRAM_INPUT, s->attrib_binding);
@@ -841,7 +849,8 @@ srcReg: USED_IDENTIFIER /* temporaryReg | progParamSingle */
            gl_register_file file = ($1.name != NULL) 
 	      ? $1.param_binding_type
 	      : PROGRAM_CONSTANT;
-	   set_src_reg(& $$, file, $1.param_binding_begin);
+           set_src_reg_swz(& $$, file, $1.param_binding_begin,
+                           $1.param_binding_swizzle);
 	}
 	;
 
@@ -1210,6 +1219,7 @@ PARAM_singleStmt: PARAM IDENTIFIER paramSingleInit
 	      s->param_binding_type = $3.param_binding_type;
 	      s->param_binding_begin = $3.param_binding_begin;
 	      s->param_binding_length = $3.param_binding_length;
+              s->param_binding_swizzle = SWIZZLE_XYZW;
 	      s->param_is_array = 0;
 	   }
 	}
@@ -1233,6 +1243,7 @@ PARAM_multipleStmt: PARAM IDENTIFIER '[' optArraySize ']' paramMultipleInit
 		 s->param_binding_type = $6.param_binding_type;
 		 s->param_binding_begin = $6.param_binding_begin;
 		 s->param_binding_length = $6.param_binding_length;
+                 s->param_binding_swizzle = SWIZZLE_XYZW;
 		 s->param_is_array = 1;
 	      }
 	   }
@@ -1290,7 +1301,7 @@ paramSingleItemDecl: stateSingleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_TRUE);
 	}
 	;
 
@@ -1310,7 +1321,7 @@ paramSingleItemUse: stateSingleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_TRUE);
 	}
 	;
 
@@ -1330,7 +1341,7 @@ paramMultipleItem: stateMultipleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_FALSE);
 	}
 	;
 
@@ -2287,7 +2298,9 @@ set_dst_reg(struct prog_dst_register *r, gl_register_file file, GLint index)
    const GLint maxIndex = 1 << INST_INDEX_BITS;
    const GLint minIndex = 0;
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
+   (void) maxIndex;
    ASSERT(file == PROGRAM_TEMPORARY ||
 	  file == PROGRAM_ADDRESS ||
 	  file == PROGRAM_OUTPUT);
@@ -2310,19 +2323,31 @@ init_src_reg(struct asm_src_register *r)
 }
 
 
-/** Like init_src_reg() but set the File and Index fields. */
+/** Like init_src_reg() but set the File and Index fields.
+ * \return GL_TRUE if a valid src register, GL_FALSE otherwise
+ */
 void
 set_src_reg(struct asm_src_register *r, gl_register_file file, GLint index)
 {
+   set_src_reg_swz(r, file, index, SWIZZLE_XYZW);
+}
+
+
+void
+set_src_reg_swz(struct asm_src_register *r, gl_register_file file, GLint index,
+                GLuint swizzle)
+{
    const GLint maxIndex = (1 << INST_INDEX_BITS) - 1;
    const GLint minIndex = -(1 << INST_INDEX_BITS);
+   ASSERT(file < PROGRAM_FILE_MAX);
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
-   ASSERT(file < PROGRAM_FILE_MAX);
+   (void) maxIndex;
    memset(r, 0, sizeof(*r));
    r->Base.File = file;
    r->Base.Index = index;
-   r->Base.Swizzle = SWIZZLE_NOOP;
+   r->Base.Swizzle = swizzle;
    r->Symbol = NULL;
 }
 
@@ -2454,15 +2479,20 @@ initialize_symbol_from_state(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
+
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -2486,9 +2516,12 @@ initialize_symbol_from_param(struct gl_program *prog,
    assert((state_tokens[1] == STATE_ENV)
 	  || (state_tokens[1] == STATE_LOCAL));
 
+   /*
+    * The param type is STATE_VAR.  The program parameter entry will
+    * effectively be a pointer into the LOCAL or ENV parameter array.
+    */
    param_var->type = at_param;
-   param_var->param_binding_type = (state_tokens[1] == STATE_ENV)
-     ? PROGRAM_ENV_PARAM : PROGRAM_LOCAL_PARAM;
+   param_var->param_binding_type = PROGRAM_STATE_VAR;
 
    /* If we are adding a STATE_ENV or STATE_LOCAL that has multiple elements,
     * we need to unroll it and call add_state_reference() for each row
@@ -2502,15 +2535,19 @@ initialize_symbol_from_param(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -2518,20 +2555,34 @@ initialize_symbol_from_param(struct gl_program *prog,
 }
 
 
+/**
+ * Put a float/vector constant/literal into the parameter list.
+ * \param param_var  returns info about the parameter/constant's location,
+ *                   binding, type, etc.
+ * \param vec  the vector/constant to add
+ * \param allowSwizzle  if true, try to consolidate constants which only differ
+ *                      by a swizzle.  We don't want to do this when building
+ *                      arrays of constants that may be indexed indirectly.
+ * \return index of the constant in the parameter list.
+ */
 int
 initialize_symbol_from_const(struct gl_program *prog,
 			     struct asm_symbol *param_var, 
-			     const struct asm_vector *vec)
+			     const struct asm_vector *vec,
+                             GLboolean allowSwizzle)
 {
-   const int idx = _mesa_add_parameter(prog->Parameters, PROGRAM_CONSTANT,
-				       NULL, vec->count, GL_NONE, vec->data,
-				       NULL, 0x0);
+   unsigned swizzle;
+   const int idx = _mesa_add_unnamed_constant(prog->Parameters,
+                                              vec->data, vec->count,
+                                              allowSwizzle ? &swizzle : NULL);
 
    param_var->type = at_param;
    param_var->param_binding_type = PROGRAM_CONSTANT;
 
-   if (param_var->param_binding_begin == ~0U)
+   if (param_var->param_binding_begin == ~0U) {
       param_var->param_binding_begin = idx;
+      param_var->param_binding_swizzle = allowSwizzle ? swizzle : SWIZZLE_XYZW;
+   }
    param_var->param_binding_length++;
 
    return idx;
diff --git a/src/mesa/shader/program_parser.h b/src/mesa/shader/program_parser.h
index c170948..69396ca 100644
--- a/src/mesa/shader/program_parser.h
+++ b/src/mesa/shader/program_parser.h
@@ -56,6 +56,12 @@ struct asm_symbol {
     */
    unsigned param_binding_begin;
 
+   /**
+    * Constants put into the parameter list may be swizzled.  This
+    * field contain's the symbol's swizzle. (SWIZZLE_X/Y/Z/W)
+    */
+   unsigned param_binding_swizzle;
+
    /* This is how many entries in the the program_parameter_list we take up
     * with our state tokens or constants. Note that this is _not_ the same as
     * the number of param registers we eventually use.
diff --git a/src/mesa/shader/slang/slang_codegen.c b/src/mesa/shader/slang/slang_codegen.c
index ee5a50c..372a9ac 100644
--- a/src/mesa/shader/slang/slang_codegen.c
+++ b/src/mesa/shader/slang/slang_codegen.c
@@ -3763,6 +3763,14 @@ _slang_gen_var_decl(slang_assemble_ctx *A, slang_variable *var,
 #endif
       }
 
+      if (var->type.qualifier == SLANG_QUAL_UNIFORM &&
+          !A->allow_uniform_initializers) {
+         slang_info_log_error(A->log,
+                              "initializer for uniform %s not allowed",
+                              varName);
+         return NULL;
+      }
+
       /* IR for the variable we're initializing */
       varRef = new_var(A, var);
       if (!varRef) {
@@ -4241,14 +4249,15 @@ _slang_gen_assignment(slang_assemble_ctx * A, slang_operation *oper)
 
    if (oper->children[0].type == SLANG_OPER_IDENTIFIER) {
       /* Check that var is writeable */
+      const char *varName = (char *) oper->children[0].a_id;
       slang_variable *var
          = _slang_variable_locate(oper->children[0].locals,
                                   oper->children[0].a_id, GL_TRUE);
       if (!var) {
-         slang_info_log_error(A->log, "undefined variable '%s'",
-                              (char *) oper->children[0].a_id);
+         slang_info_log_error(A->log, "undefined variable '%s'", varName);
          return NULL;
       }
+
       if (var->type.qualifier == SLANG_QUAL_CONST ||
           var->type.qualifier == SLANG_QUAL_ATTRIBUTE ||
           var->type.qualifier == SLANG_QUAL_UNIFORM ||
@@ -4256,7 +4265,7 @@ _slang_gen_assignment(slang_assemble_ctx * A, slang_operation *oper)
            A->program->Target == GL_FRAGMENT_PROGRAM_ARB)) {
          slang_info_log_error(A->log,
                               "illegal assignment to read-only variable '%s'",
-                              (char *) oper->children[0].a_id);
+                              varName);
          return NULL;
       }
 
diff --git a/src/mesa/shader/slang/slang_codegen.h b/src/mesa/shader/slang/slang_codegen.h
index ee3be55..461633f 100644
--- a/src/mesa/shader/slang/slang_codegen.h
+++ b/src/mesa/shader/slang/slang_codegen.h
@@ -42,6 +42,7 @@ typedef struct slang_assemble_ctx_
    struct gl_sl_pragmas *pragmas;
    slang_var_table *vartable;
    slang_info_log *log;
+   GLboolean allow_uniform_initializers;
 
    /* current loop stack */
    const slang_operation *LoopOperStack[MAX_LOOP_DEPTH];
diff --git a/src/mesa/shader/slang/slang_compile.c b/src/mesa/shader/slang/slang_compile.c
index 499e16e..57e3555 100644
--- a/src/mesa/shader/slang/slang_compile.c
+++ b/src/mesa/shader/slang/slang_compile.c
@@ -2058,6 +2058,7 @@ parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
    if (C->global_scope) {
       slang_assemble_ctx A;
       memset(&A, 0, sizeof(slang_assemble_ctx));
+      A.allow_uniform_initializers = C->version > 110;
       A.atoms = C->atoms;
       A.space.funcs = O->funs;
       A.space.structs = O->structs;
@@ -2077,6 +2078,7 @@ parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
       if (var->initializer != NULL) {
          slang_assemble_ctx A;
          memset(&A, 0, sizeof(slang_assemble_ctx));
+         A.allow_uniform_initializers = C->version > 110;
          A.atoms = C->atoms;
          A.space.funcs = O->funs;
          A.space.structs = O->structs;
@@ -2434,6 +2436,7 @@ parse_code_unit(slang_parse_ctx * C, slang_code_unit * unit,
       A.vartable = o.vartable;
       A.EmitContReturn = ctx->Shader.EmitContReturn;
       A.log = C->L;
+      A.allow_uniform_initializers = C->version > 110;
 
       /* main() takes no parameters */
       if (mainFunc->param_count > 0) {
diff --git a/src/mesa/shader/slang/slang_compile_operation.c b/src/mesa/shader/slang/slang_compile_operation.c
index be73094..3a15d9d 100644
--- a/src/mesa/shader/slang/slang_compile_operation.c
+++ b/src/mesa/shader/slang/slang_compile_operation.c
@@ -46,6 +46,7 @@ slang_operation_construct(slang_operation * oper)
    oper->literal_size = 1;
    oper->array_constructor = GL_FALSE;
    oper->a_id = SLANG_ATOM_NULL;
+   oper->a_obj = SLANG_ATOM_NULL;
    oper->locals = _slang_variable_scope_new(NULL);
    if (oper->locals == NULL)
       return GL_FALSE;
diff --git a/src/mesa/state_tracker/st_cb_bufferobjects.c b/src/mesa/state_tracker/st_cb_bufferobjects.c
index 63196af..0102d8a 100644
--- a/src/mesa/state_tracker/st_cb_bufferobjects.c
+++ b/src/mesa/state_tracker/st_cb_bufferobjects.c
@@ -103,6 +103,17 @@ st_bufferobj_subdata(GLcontext *ctx,
    ASSERT(size >= 0);
    ASSERT(offset + size <= obj->Size);
 
+   if (!size)
+      return;
+
+   /*
+    * According to ARB_vertex_buffer_object specification, if data is null,
+    * then the contents of the buffer object's data store is undefined. We just
+    * ignore, and leave it unchanged.
+    */
+   if (!data)
+      return;
+
    st_cond_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer,
 				   offset, size, data);
 }
@@ -125,6 +136,9 @@ st_bufferobj_get_subdata(GLcontext *ctx,
    ASSERT(size >= 0);
    ASSERT(offset + size <= obj->Size);
 
+   if (!size)
+      return;
+
    st_cond_flush_pipe_buffer_read(st_context(ctx), st_obj->buffer,
 				  offset, size, data);
 }
@@ -170,15 +184,19 @@ st_bufferobj_data(GLcontext *ctx,
 
    pipe_buffer_reference( &st_obj->buffer, NULL );
 
-   st_obj->buffer = pipe_buffer_create( pipe->screen, 32, buffer_usage, size );
+   if (size != 0) {
+      st_obj->buffer = pipe_buffer_create(pipe->screen, 32, buffer_usage, size);
+
+      if (!st_obj->buffer) {
+         return GL_FALSE;
+      }
 
-   if (!st_obj->buffer) {
-      return GL_FALSE;
+      if (data)
+         st_no_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer, 0,
+				       size, data);
+      return GL_TRUE;
    }
 
-   if (data)
-      st_no_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer, 0,
-				    size, data);
    return GL_TRUE;
 }
 
@@ -219,6 +237,13 @@ st_bufferobj_map(GLcontext *ctx, GLenum target, GLenum access,
 
 
 /**
+ * Dummy data whose's pointer is used for zero length ranges.
+ */
+static long
+st_bufferobj_zero_length_range = 0;
+
+
+/**
  * Called via glMapBufferRange().
  */
 static void *
@@ -253,14 +278,26 @@ st_bufferobj_map_range(GLcontext *ctx, GLenum target,
    assert(offset < obj->Size);
    assert(offset + length <= obj->Size);
 
-   obj->Pointer = pipe_buffer_map_range(pipe->screen, st_obj->buffer, offset, length, flags);
+   /*
+    * We go out of way here to hide the degenerate yet valid case of zero
+    * length range from the pipe driver.
+    */
+   if (!length) {
+      obj->Pointer = &st_bufferobj_zero_length_range;
+   }
+   else {
+      obj->Pointer = pipe_buffer_map_range(pipe->screen, st_obj->buffer, offset, length, flags);
+      if (obj->Pointer) {
+         obj->Pointer = (ubyte *) obj->Pointer + offset;
+      }
+   }
+   
    if (obj->Pointer) {
-      obj->Pointer = (ubyte *) obj->Pointer + offset;
       obj->Offset = offset;
       obj->Length = length;
       obj->AccessFlags = access;
    }
-   
+
    return obj->Pointer;
 }
 
@@ -278,6 +315,9 @@ st_bufferobj_flush_mapped_range(GLcontext *ctx, GLenum target,
    assert(length >= 0);
    assert(offset + length <= obj->Length);
    
+   if (!length)
+      return;
+
    pipe_buffer_flush_mapped_range(pipe->screen, st_obj->buffer, 
                                   obj->Offset + offset, length);
 }
@@ -292,7 +332,9 @@ st_bufferobj_unmap(GLcontext *ctx, GLenum target, struct gl_buffer_object *obj)
    struct pipe_context *pipe = st_context(ctx)->pipe;
    struct st_buffer_object *st_obj = st_buffer_object(obj);
 
-   pipe_buffer_unmap(pipe->screen, st_obj->buffer);
+   if(obj->Length)
+      pipe_buffer_unmap(pipe->screen, st_obj->buffer);
+
    obj->Pointer = NULL;
    obj->Offset = 0;
    obj->Length = 0;
@@ -315,6 +357,9 @@ st_copy_buffer_subdata(GLcontext *ctx,
    struct st_buffer_object *dstObj = st_buffer_object(dst);
    ubyte *srcPtr, *dstPtr;
 
+   if(!size)
+      return;
+
    /* buffer should not already be mapped */
    assert(!src->Pointer);
    assert(!dst->Pointer);
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index d4630a5..cb9106c 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -1090,7 +1090,7 @@ st_TexSubimage(GLcontext *ctx, GLint dims, GLenum target, GLint level,
 done:
    _mesa_unmap_teximage_pbo(ctx, packing);
 
-   if (stImage->pt) {
+   if (stImage->pt && texImage->Data) {
       st_texture_image_unmap(ctx->st, stImage);
       texImage->Data = NULL;
    }
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index 02f8005..2785728 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -99,7 +99,8 @@ st_get_format_info(enum pipe_format format, struct pipe_format_info *pinfo)
       if (format == PIPE_FORMAT_A1R5G5B5_UNORM || format == PIPE_FORMAT_R5G6B5_UNORM) {
          pinfo->datatype = GL_UNSIGNED_SHORT;
       }
-      else if (format == PIPE_FORMAT_S8Z24_UNORM) {
+      else if (format == PIPE_FORMAT_S8Z24_UNORM ||
+               format == PIPE_FORMAT_Z24S8_UNORM) {
          pinfo->datatype = GL_UNSIGNED_INT_24_8;
       }
       else {
@@ -291,6 +292,8 @@ st_pipe_format_to_mesa_format(enum pipe_format pipeFormat)
       return MESA_FORMAT_ARGB8888;
    case PIPE_FORMAT_X8R8G8B8_UNORM:
       return MESA_FORMAT_XRGB8888;
+   case PIPE_FORMAT_B8G8R8A8_UNORM:
+      return MESA_FORMAT_ARGB8888_REV;
    case PIPE_FORMAT_A1R5G5B5_UNORM:
       return MESA_FORMAT_ARGB1555;
    case PIPE_FORMAT_A4R4G4B4_UNORM:
diff --git a/src/mesa/state_tracker/st_mesa_to_tgsi.c b/src/mesa/state_tracker/st_mesa_to_tgsi.c
index bd94c9d..0b7786c 100644
--- a/src/mesa/state_tracker/st_mesa_to_tgsi.c
+++ b/src/mesa/state_tracker/st_mesa_to_tgsi.c
@@ -160,13 +160,14 @@ dst_register( struct st_translate *t,
 static struct ureg_src
 src_register( struct st_translate *t,
               gl_register_file file,
-              GLuint index )
+              GLint index )
 {
    switch( file ) {
    case PROGRAM_UNDEFINED:
       return ureg_src_undef();
 
    case PROGRAM_TEMPORARY:
+      ASSERT(index >= 0);
       if (ureg_dst_is_undef(t->temps[index]))
          t->temps[index] = ureg_DECL_temporary( t->ureg );
       return ureg_src(t->temps[index]);
@@ -174,9 +175,15 @@ src_register( struct st_translate *t,
    case PROGRAM_STATE_VAR:
    case PROGRAM_NAMED_PARAM:
    case PROGRAM_ENV_PARAM:
+   case PROGRAM_LOCAL_PARAM:
    case PROGRAM_UNIFORM:
-   case PROGRAM_CONSTANT:       /* ie, immediate */
+      ASSERT(index >= 0);
       return t->constants[index];
+   case PROGRAM_CONSTANT:       /* ie, immediate */
+      if (index < 0)
+         return ureg_DECL_constant( t->ureg, 0 );
+      else
+         return t->constants[index];
 
    case PROGRAM_INPUT:
       return t->inputs[t->inputMapping[index]];
@@ -263,9 +270,14 @@ translate_src( struct st_translate *t,
    if (SrcReg->Abs) 
       src = ureg_abs(src);
 
-   if (SrcReg->RelAddr) 
+   if (SrcReg->RelAddr) {
       src = ureg_src_indirect( src, ureg_src(t->address[0]));
-   
+      /* If SrcReg->Index was negative, it was set to zero in
+       * src_register().  Reassign it now.
+       */
+      src.Index = SrcReg->Index;
+   }
+
    return src;
 }
 
@@ -805,6 +817,7 @@ st_translate_mesa_program(
       for (i = 0; i < program->Parameters->NumParameters; i++) {
          switch (program->Parameters->Parameters[i].Type) {
          case PROGRAM_ENV_PARAM:
+         case PROGRAM_LOCAL_PARAM:
          case PROGRAM_STATE_VAR:
          case PROGRAM_NAMED_PARAM:
          case PROGRAM_UNIFORM:
diff --git a/src/mesa/swrast/s_span.c b/src/mesa/swrast/s_span.c
index d36c813..1a51d4f 100644
--- a/src/mesa/swrast/s_span.c
+++ b/src/mesa/swrast/s_span.c
@@ -1766,9 +1766,7 @@ _swrast_get_row(GLcontext *ctx, struct gl_renderbuffer *rb,
 
 
 /**
- * Get RGBA pixels from the given renderbuffer.  Put the pixel colors into
- * the span's specular color arrays.  The specular color arrays should no
- * longer be needed by time this function is called.
+ * Get RGBA pixels from the given renderbuffer.
  * Used by blending, logicop and masking functions.
  * \return pointer to the colors we read.
  */
@@ -1779,10 +1777,8 @@ _swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
    const GLuint pixelSize = RGBA_PIXEL_SIZE(span->array->ChanType);
    void *rbPixels;
 
-   /*
-    * Point rbPixels to a temporary space (use specular color arrays).
-    */
-   rbPixels = span->array->attribs[FRAG_ATTRIB_COL1];
+   /* Point rbPixels to a temporary space */
+   rbPixels = span->array->attribs[FRAG_ATTRIB_MAX - 1];
 
    /* Get destination values from renderbuffer */
    if (span->arrayMask & SPAN_XY) {
diff --git a/src/mesa/tnl/t_vb_program.c b/src/mesa/tnl/t_vb_program.c
index e69f7d5..a9dae7d 100644
--- a/src/mesa/tnl/t_vb_program.c
+++ b/src/mesa/tnl/t_vb_program.c
@@ -390,6 +390,13 @@ run_vp( GLcontext *ctx, struct tnl_pipeline_stage *stage )
 #endif
          COPY_4V(store->results[attr].data[i], machine.Outputs[attr]);
       }
+
+      /* FOGC is a special case.  Fragment shader expects (f,0,0,1) */
+      if (program->Base.OutputsWritten & BITFIELD64_BIT(VERT_RESULT_FOGC)) {
+         store->results[VERT_RESULT_FOGC].data[i][1] = 0.0;
+         store->results[VERT_RESULT_FOGC].data[i][2] = 0.0;
+         store->results[VERT_RESULT_FOGC].data[i][3] = 1.0;
+      }
 #ifdef NAN_CHECK
       ASSERT(machine.Outputs[0][3] != 0.0F);
 #endif
diff --git a/src/mesa/x86/gen_matypes.c b/src/mesa/x86/gen_matypes.c
index d56b701..771d9df 100644
--- a/src/mesa/x86/gen_matypes.c
+++ b/src/mesa/x86/gen_matypes.c
@@ -61,21 +61,11 @@ do {									\
    printf( "\n" );							\
 } while (0)
 
-#if defined(__BEOS__) || defined(__HAIKU__) || defined(_LP64)
 #define OFFSET( s, t, m )						\
-   printf( "#define %s\t%ld\n", s, offsetof( t, m ) );
-#else
-#define OFFSET( s, t, m )						\
-   printf( "#define %s\t%d\n", s, offsetof( t, m ) );
-#endif
+   printf( "#define %s\t%lu\n", s, (unsigned long) offsetof( t, m ) );
 
-#if defined(__BEOS__) || defined(__HAIKU__) || defined(_LP64)
-#define SIZEOF( s, t )							\
-   printf( "#define %s\t%ld\n", s, sizeof(t) );
-#else
 #define SIZEOF( s, t )							\
-   printf( "#define %s\t%d\n", s, sizeof(t) );
-#endif
+   printf( "#define %s\t%lu\n", s, (unsigned long) sizeof(t) );
 
 #define DEFINE( s, d )							\
    printf( "#define %s\t0x%x\n", s, d );
