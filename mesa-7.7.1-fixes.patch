diff --git a/Makefile b/Makefile
index e927cb9..b10d1fe 100644
--- a/Makefile
+++ b/Makefile
@@ -182,7 +182,7 @@ ultrix-gcc:
 
 # Rules for making release tarballs
 
-VERSION=7.7
+VERSION=7.7.1-devel
 DIRECTORY = Mesa-$(VERSION)
 LIB_NAME = MesaLib-$(VERSION)
 DEMO_NAME = MesaDemos-$(VERSION)
diff --git a/configs/darwin b/configs/darwin
index 824f71c..336b54e 100644
--- a/configs/darwin
+++ b/configs/darwin
@@ -49,7 +49,7 @@ GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X
 APP_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXmu -lXt -lXi -lm
 
 # omit glw lib for now:
-SRC_DIRS = glx/x11 mesa glu glut/glx glew
+SRC_DIRS = glx/x11 mesa gallium glu glut/glx glew
 GLU_DIRS = sgi
 DRIVER_DIRS = osmesa
 #DRIVER_DIRS = dri
diff --git a/configs/default b/configs/default
index 9af816c..c9616bb 100644
--- a/configs/default
+++ b/configs/default
@@ -10,7 +10,7 @@ CONFIG_NAME = default
 # Version info
 MESA_MAJOR=7
 MESA_MINOR=7
-MESA_TINY=0
+MESA_TINY=1
 MESA_VERSION = $(MESA_MAJOR).$(MESA_MINOR).$(MESA_TINY)
 
 # external projects.  This should be useless now that we use libdrm.
diff --git a/docs/envvars.html b/docs/envvars.html
index b2c0e01..bb1c914 100644
--- a/docs/envvars.html
+++ b/docs/envvars.html
@@ -51,5 +51,24 @@ See the <A HREF="xlibdriver.html">Xlib software driver page</A> for details.
 </ul>
 
 
+<p>
+These environment variables are for the Intel i945/i965 drivers:
+</p>
+<ul>
+<li>INTEL_STRICT_CONFORMANCE - if set to 1, enable sw fallbacks to improve
+    OpenGL conformance.  If set to 2, always use software rendering.
+<li>INTEL_NO_BLIT - if set, disable hardware-accelerated glBitmap,
+    glCopyPixels, glDrawPixels.
+</ul>
+
+
+<p>
+These environment variables are for the Radeon R300 driver:
+</p>
+<ul>
+<li>R300_NO_TCL - if set, disable hardware-accelerated Transform/Clip/Lighting.
+</ul>
+
+
 </BODY>
 </HTML>
diff --git a/docs/lists.html b/docs/lists.html
index 5227fbd..9c17a9f 100644
--- a/docs/lists.html
+++ b/docs/lists.html
@@ -13,36 +13,41 @@
 </p>
 
 <ul>
-<li><a href="https://lists.sourceforge.net/lists/listinfo/mesa3d-announce"
-target="_parent">mesa3d-announce</a> - announcements of new Mesa
-versions are sent to this list.
-</li>
-<br>
 <li><a href="https://lists.sourceforge.net/lists/listinfo/mesa3d-users"
-target="_parent">mesa3d-users</a> - intended for users of the Mesa and DRI.
-Newbie questions are appropriate, but please try the general OpenGL
+target="_parent">mesa3d-users</a> - intended for end-users of Mesa and DRI
+drivers.  Newbie questions are OK, but please try the general OpenGL
 resources and Mesa/DRI documentation first.
 </li>
 <br>
 <li><a href="https://lists.sourceforge.net/lists/listinfo/mesa3d-dev"
-target="_parent">mesa3d-dev</a> - for discussion of Mesa and Direct Rendering 
-Infrastructure development. Not for beginners.
+target="_parent">mesa3d-dev</a> - for Mesa, Gallium and DRI development
+discussion.  Not for beginners.
 </li>
 <br>
 <li><a href="http://lists.freedesktop.org/mailman/listinfo/mesa-commit"
 target="_parent">mesa-commit</a> - relays git check-in messages
 (for developers).
+In general, people should not post to this list.
+</li>
 <br>
-Note: the old mesa3d-cvs list is no longer in use.
+<li><a href="https://lists.sourceforge.net/lists/listinfo/mesa3d-announce"
+target="_parent">mesa3d-announce</a> - announcements of new Mesa
+versions are sent to this list.  Very low traffic.
 </li>
 </ul>
 
+<p>
+Follow the links above for list archives.
+</p>
+
 <p>For mailing lists about Direct Rendering Modules (drm) in Linux/BSD 
-kernels, see <a href="http://dri.freedesktop.org/wiki/MailingLists">wiki</a>.
+kernels, see the
+<a href="http://dri.freedesktop.org/wiki/MailingLists" target="_parent">
+DRI wiki</a>.
+</p>
 
 <p>
-<b>Notice</b>: non-member posts to any of these lists will be automatically
-rejected.
+<b>Notice</b>: You must subscribe to these lists in order to post to them.
 </p>
 
 
diff --git a/docs/news.html b/docs/news.html
index 2abec2e..0a0be71 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -10,11 +10,15 @@
 
 <H1>News</H1>
 
-<h2>November XX, 2009</h2>
+<h2>December 21, 2009</h2>
 <p>
 <a href="relnotes-7.6.1.html">Mesa 7.6.1</a> is released.  This is a bug-fix
 release fixing issues found in the 7.6 release.
 </p>
+<p>
+Also, <a href="relnotes-7.7.html">Mesa 7.7</a> is released.  This is a new
+development release.
+</p>
 
 
 <h2>September 28, 2009</h2>
diff --git a/docs/relnotes-7.6.1.html b/docs/relnotes-7.6.1.html
index a41bcee..1d0ecd2 100644
--- a/docs/relnotes-7.6.1.html
+++ b/docs/relnotes-7.6.1.html
@@ -8,7 +8,7 @@
 
 <body bgcolor="#eeeeee">
 
-<H1>Mesa 7.6.1 Release Notes, (date tbd)</H1>
+<H1>Mesa 7.6.1 Release Notes, 21 December 2009</H1>
 
 <p>
 Mesa 7.6.1 is a bug-fix release fixing issues since version 7.6.
@@ -26,7 +26,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+e80fabad2e3eb7990adae773d6aeacba  MesaLib-7.6.1.tar.gz
+7db4617e9e10ad3aca1b64339fd71b7d  MesaLib-7.6.1.tar.bz2
+dd3275dbf9833480d2e92d0c69b22abd  MesaLib-7.6.1.zip
+f7fdcfe3c0f363e571c60f02f74368fb  MesaDemos-7.6.1.tar.gz
+a4226f06732a02556fcf6be290b86dff  MesaDemos-7.6.1.tar.bz2
+849425f356bd940726cebedfa79de176  MesaDemos-7.6.1.zip
+d40cc7c5e337a85b674e27a8e494f52f  MesaGLUT-7.6.1.tar.gz
+ca9aecb91f05b1da9fd7d5eeb19d47d7  MesaGLUT-7.6.1.tar.bz2
+23fad8398004c977a1d8953079b72ca6  MesaGLUT-7.6.1.zip
 </pre>
 
 
diff --git a/docs/relnotes-7.7.1.html b/docs/relnotes-7.7.1.html
new file mode 100644
index 0000000..b20c8a7
--- /dev/null
+++ b/docs/relnotes-7.7.1.html
@@ -0,0 +1,50 @@
+<HTML>
+
+<TITLE>Mesa Release Notes</TITLE>
+
+<head><link rel="stylesheet" type="text/css" href="mesa.css"></head>
+
+<BODY>
+
+<body bgcolor="#eeeeee">
+
+<H1>Mesa 7.7.1 Release Notes / date tbd</H1>
+
+<p>
+Mesa 7.7.1 is a bug-fix release.
+</p>
+<p>
+Mesa 7.7.1 implements the OpenGL 2.1 API, but the version reported by
+glGetString(GL_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 2.1.
+</p>
+<p>
+See the <a href="install.html">Compiling/Installing page</a> for prerequisites
+for DRI hardware acceleration.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+tbd
+</pre>
+
+
+<h2>New features</h2>
+<ul>
+<li>tbd
+</ul>
+
+
+<h2>Bug fixes</h2>
+<ul>
+<li>Assorted fixes to VMware SVGA gallium driver.
+<li>Fixed broken blending to multiple color buffers in swrast driver.
+<li>Allocate constants more tightly in GL_ARB_vertex/fragment parser.
+<li>Fixed mipmap generation bug caused by invalid viewport state.
+<li>Gallium SSE codegen for XPD didn't always work.
+</ul>
+
+
+</body>
+</html>
diff --git a/docs/relnotes-7.7.html b/docs/relnotes-7.7.html
index 8c8f763..c1ed654 100644
--- a/docs/relnotes-7.7.html
+++ b/docs/relnotes-7.7.html
@@ -8,7 +8,7 @@
 
 <body bgcolor="#eeeeee">
 
-<H1>Mesa 7.7 Release Notes / date TBD</H1>
+<H1>Mesa 7.7 Release Notes / 21 December 2009</H1>
 
 <p>
 Mesa 7.7 is a new development release.
@@ -28,7 +28,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+395c9516edf1ad54b0934d8db15557bf  MesaLib-7.7.tar.gz
+e3fa64a1508bc23dd9de9dd2cea7cfb1  MesaLib-7.7.tar.bz2
+e54903eb5e49c3969821fa16b32da245  MesaLib-7.7.zip
+53b5b6f78e55de170d43c98cb6aaab7e  MesaDemos-7.7.tar.gz
+6fd616b27b9826d0faa23e08e05d9435  MesaDemos-7.7.tar.bz2
+240fe06159ad73d5e22c27033b66c80a  MesaDemos-7.7.zip
+9fe11a904b2a9d8cd06cc52bc330b716  MesaGLUT-7.7.tar.gz
+e8dceed05a59a2d3c2619d7d734587e3  MesaGLUT-7.7.tar.bz2
+96af041d435349ee23ead4667ec36363  MesaGLUT-7.7.zip
 </pre>
 
 
diff --git a/docs/relnotes.html b/docs/relnotes.html
index b301ee0..b06548a 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -13,6 +13,7 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <UL>
+<LI><A HREF="relnotes-7.7.1.html">7.7.1 release notes</A>
 <LI><A HREF="relnotes-7.7.html">7.7 release notes</A>
 <LI><A HREF="relnotes-7.6.1.html">7.6.1 release notes</A>
 <LI><A HREF="relnotes-7.6.html">7.6 release notes</A>
diff --git a/include/GL/gl_mangle.h b/include/GL/gl_mangle.h
index 59f6149..b292840 100644
--- a/include/GL/gl_mangle.h
+++ b/include/GL/gl_mangle.h
@@ -30,6 +30,7 @@
 /*REGENERATE_TO_END-----------ALL LINES BELOW HERE GET REPLACED ON REGENERATION */
 
 #define glAccum		MANGLE(Accum)
+#define glActiveProgramEXT		MANGLE(ActiveProgramEXT)
 #define glActiveStencilFaceEXT		MANGLE(ActiveStencilFaceEXT)
 #define glActiveTextureARB		MANGLE(ActiveTextureARB)
 #define glActiveTexture		MANGLE(ActiveTexture)
@@ -60,6 +61,7 @@
 #define glBeginTransformFeedback		MANGLE(BeginTransformFeedback)
 #define glBeginTransformFeedbackNV		MANGLE(BeginTransformFeedbackNV)
 #define glBeginVertexShaderEXT		MANGLE(BeginVertexShaderEXT)
+#define glBeginVideoCaptureNV		MANGLE(BeginVideoCaptureNV)
 #define glBindAttribLocationARB		MANGLE(BindAttribLocationARB)
 #define glBindAttribLocation		MANGLE(BindAttribLocation)
 #define glBindBufferARB		MANGLE(BindBufferARB)
@@ -93,6 +95,8 @@
 #define glBindVertexArrayAPPLE		MANGLE(BindVertexArrayAPPLE)
 #define glBindVertexArray		MANGLE(BindVertexArray)
 #define glBindVertexShaderEXT		MANGLE(BindVertexShaderEXT)
+#define glBindVideoCaptureStreamBufferNV		MANGLE(BindVideoCaptureStreamBufferNV)
+#define glBindVideoCaptureStreamTextureNV		MANGLE(BindVideoCaptureStreamTextureNV)
 #define glBinormal3bEXT		MANGLE(Binormal3bEXT)
 #define glBinormal3bvEXT		MANGLE(Binormal3bvEXT)
 #define glBinormal3dEXT		MANGLE(Binormal3dEXT)
@@ -126,6 +130,7 @@
 #define glBlendFuncSeparate		MANGLE(BlendFuncSeparate)
 #define glBlitFramebufferEXT		MANGLE(BlitFramebufferEXT)
 #define glBlitFramebuffer		MANGLE(BlitFramebuffer)
+#define glBufferAddressRangeNV		MANGLE(BufferAddressRangeNV)
 #define glBufferDataARB		MANGLE(BufferDataARB)
 #define glBufferData		MANGLE(BufferData)
 #define glBufferParameteriAPPLE		MANGLE(BufferParameteriAPPLE)
@@ -202,6 +207,7 @@
 #define glColor4uiv		MANGLE(Color4uiv)
 #define glColor4us		MANGLE(Color4us)
 #define glColor4usv		MANGLE(Color4usv)
+#define glColorFormatNV		MANGLE(ColorFormatNV)
 #define glColorFragmentOp1ATI		MANGLE(ColorFragmentOp1ATI)
 #define glColorFragmentOp2ATI		MANGLE(ColorFragmentOp2ATI)
 #define glColorFragmentOp3ATI		MANGLE(ColorFragmentOp3ATI)
@@ -276,6 +282,7 @@
 #define glCopyConvolutionFilter1D		MANGLE(CopyConvolutionFilter1D)
 #define glCopyConvolutionFilter2DEXT		MANGLE(CopyConvolutionFilter2DEXT)
 #define glCopyConvolutionFilter2D		MANGLE(CopyConvolutionFilter2D)
+#define glCopyImageSubDataNV		MANGLE(CopyImageSubDataNV)
 #define glCopyMultiTexImage1DEXT		MANGLE(CopyMultiTexImage1DEXT)
 #define glCopyMultiTexImage2DEXT		MANGLE(CopyMultiTexImage2DEXT)
 #define glCopyMultiTexSubImage1DEXT		MANGLE(CopyMultiTexSubImage1DEXT)
@@ -302,6 +309,7 @@
 #define glCreateProgramObjectARB		MANGLE(CreateProgramObjectARB)
 #define glCreateShader		MANGLE(CreateShader)
 #define glCreateShaderObjectARB		MANGLE(CreateShaderObjectARB)
+#define glCreateShaderProgramEXT		MANGLE(CreateShaderProgramEXT)
 #define glCullFace		MANGLE(CullFace)
 #define glCullParameterdvEXT		MANGLE(CullParameterdvEXT)
 #define glCullParameterfvEXT		MANGLE(CullParameterfvEXT)
@@ -379,6 +387,7 @@
 #define glDrawRangeElementsEXT		MANGLE(DrawRangeElementsEXT)
 #define glDrawRangeElements		MANGLE(DrawRangeElements)
 #define glDrawTransformFeedbackNV		MANGLE(DrawTransformFeedbackNV)
+#define glEdgeFlagFormatNV		MANGLE(EdgeFlagFormatNV)
 #define glEdgeFlag		MANGLE(EdgeFlag)
 #define glEdgeFlagPointerEXT		MANGLE(EdgeFlagPointerEXT)
 #define glEdgeFlagPointerListIBM		MANGLE(EdgeFlagPointerListIBM)
@@ -408,6 +417,7 @@
 #define glEndTransformFeedback		MANGLE(EndTransformFeedback)
 #define glEndTransformFeedbackNV		MANGLE(EndTransformFeedbackNV)
 #define glEndVertexShaderEXT		MANGLE(EndVertexShaderEXT)
+#define glEndVideoCaptureNV		MANGLE(EndVideoCaptureNV)
 #define glEvalCoord1d		MANGLE(EvalCoord1d)
 #define glEvalCoord1dv		MANGLE(EvalCoord1dv)
 #define glEvalCoord1f		MANGLE(EvalCoord1f)
@@ -445,6 +455,7 @@
 #define glFogCoorddv		MANGLE(FogCoorddv)
 #define glFogCoordfEXT		MANGLE(FogCoordfEXT)
 #define glFogCoordf		MANGLE(FogCoordf)
+#define glFogCoordFormatNV		MANGLE(FogCoordFormatNV)
 #define glFogCoordfvEXT		MANGLE(FogCoordfvEXT)
 #define glFogCoordfv		MANGLE(FogCoordfv)
 #define glFogCoordhNV		MANGLE(FogCoordhNV)
@@ -544,6 +555,7 @@
 #define glGetBufferParameteri64v		MANGLE(GetBufferParameteri64v)
 #define glGetBufferParameterivARB		MANGLE(GetBufferParameterivARB)
 #define glGetBufferParameteriv		MANGLE(GetBufferParameteriv)
+#define glGetBufferParameterui64vNV		MANGLE(GetBufferParameterui64vNV)
 #define glGetBufferPointervARB		MANGLE(GetBufferPointervARB)
 #define glGetBufferPointerv		MANGLE(GetBufferPointerv)
 #define glGetBufferSubDataARB		MANGLE(GetBufferSubDataARB)
@@ -609,6 +621,8 @@
 #define glGetInteger64v		MANGLE(GetInteger64v)
 #define glGetIntegerIndexedvEXT		MANGLE(GetIntegerIndexedvEXT)
 #define glGetIntegeri_v		MANGLE(GetIntegeri_v)
+#define glGetIntegerui64i_vNV		MANGLE(GetIntegerui64i_vNV)
+#define glGetIntegerui64vNV		MANGLE(GetIntegerui64vNV)
 #define glGetIntegerv		MANGLE(GetIntegerv)
 #define glGetInvariantBooleanvEXT		MANGLE(GetInvariantBooleanvEXT)
 #define glGetInvariantFloatvEXT		MANGLE(GetInvariantFloatvEXT)
@@ -651,6 +665,7 @@
 #define glGetMultiTexParameterIuivEXT		MANGLE(GetMultiTexParameterIuivEXT)
 #define glGetMultiTexParameterivEXT		MANGLE(GetMultiTexParameterivEXT)
 #define glGetNamedBufferParameterivEXT		MANGLE(GetNamedBufferParameterivEXT)
+#define glGetNamedBufferParameterui64vNV		MANGLE(GetNamedBufferParameterui64vNV)
 #define glGetNamedBufferPointervEXT		MANGLE(GetNamedBufferPointervEXT)
 #define glGetNamedBufferSubDataEXT		MANGLE(GetNamedBufferSubDataEXT)
 #define glGetNamedFramebufferAttachmentParameterivEXT		MANGLE(GetNamedFramebufferAttachmentParameterivEXT)
@@ -761,6 +776,7 @@
 #define glGetUniformLocationARB		MANGLE(GetUniformLocationARB)
 #define glGetUniformLocation		MANGLE(GetUniformLocation)
 #define glGetUniformOffsetEXT		MANGLE(GetUniformOffsetEXT)
+#define glGetUniformui64vNV		MANGLE(GetUniformui64vNV)
 #define glGetUniformuivEXT		MANGLE(GetUniformuivEXT)
 #define glGetUniformuiv		MANGLE(GetUniformuiv)
 #define glGetVariantArrayObjectfvATI		MANGLE(GetVariantArrayObjectfvATI)
@@ -788,6 +804,10 @@
 #define glGetVertexAttribPointervARB		MANGLE(GetVertexAttribPointervARB)
 #define glGetVertexAttribPointerv		MANGLE(GetVertexAttribPointerv)
 #define glGetVertexAttribPointervNV		MANGLE(GetVertexAttribPointervNV)
+#define glGetVideoCaptureivNV		MANGLE(GetVideoCaptureivNV)
+#define glGetVideoCaptureStreamdvNV		MANGLE(GetVideoCaptureStreamdvNV)
+#define glGetVideoCaptureStreamfvNV		MANGLE(GetVideoCaptureStreamfvNV)
+#define glGetVideoCaptureStreamivNV		MANGLE(GetVideoCaptureStreamivNV)
 #define glGetVideoi64vNV		MANGLE(GetVideoi64vNV)
 #define glGetVideoivNV		MANGLE(GetVideoivNV)
 #define glGetVideoui64vNV		MANGLE(GetVideoui64vNV)
@@ -812,6 +832,7 @@
 #define glIndexd		MANGLE(Indexd)
 #define glIndexdv		MANGLE(Indexdv)
 #define glIndexf		MANGLE(Indexf)
+#define glIndexFormatNV		MANGLE(IndexFormatNV)
 #define glIndexFuncEXT		MANGLE(IndexFuncEXT)
 #define glIndexfv		MANGLE(Indexfv)
 #define glIndexi		MANGLE(Indexi)
@@ -832,6 +853,7 @@
 #define glIsAsyncMarkerSGIX		MANGLE(IsAsyncMarkerSGIX)
 #define glIsBufferARB		MANGLE(IsBufferARB)
 #define glIsBuffer		MANGLE(IsBuffer)
+#define glIsBufferResidentNV		MANGLE(IsBufferResidentNV)
 #define glIsEnabledi		MANGLE(IsEnabledi)
 #define glIsEnabledIndexedEXT		MANGLE(IsEnabledIndexedEXT)
 #define glIsEnabled		MANGLE(IsEnabled)
@@ -840,6 +862,7 @@
 #define glIsFramebufferEXT		MANGLE(IsFramebufferEXT)
 #define glIsFramebuffer		MANGLE(IsFramebuffer)
 #define glIsList		MANGLE(IsList)
+#define glIsNamedBufferResidentNV		MANGLE(IsNamedBufferResidentNV)
 #define glIsObjectBufferATI		MANGLE(IsObjectBufferATI)
 #define glIsOcclusionQueryNV		MANGLE(IsOcclusionQueryNV)
 #define glIsProgramARB		MANGLE(IsProgramARB)
@@ -888,6 +911,8 @@
 #define glLoadTransposeMatrixf		MANGLE(LoadTransposeMatrixf)
 #define glLockArraysEXT		MANGLE(LockArraysEXT)
 #define glLogicOp		MANGLE(LogicOp)
+#define glMakeBufferNonResidentNV		MANGLE(MakeBufferNonResidentNV)
+#define glMakeBufferResidentNV		MANGLE(MakeBufferResidentNV)
 #define glMap1d		MANGLE(Map1d)
 #define glMap1f		MANGLE(Map1f)
 #define glMap2d		MANGLE(Map2d)
@@ -1060,6 +1085,8 @@
 #define glNamedFramebufferTextureEXT		MANGLE(NamedFramebufferTextureEXT)
 #define glNamedFramebufferTextureFaceEXT		MANGLE(NamedFramebufferTextureFaceEXT)
 #define glNamedFramebufferTextureLayerEXT		MANGLE(NamedFramebufferTextureLayerEXT)
+#define glNamedMakeBufferNonResidentNV		MANGLE(NamedMakeBufferNonResidentNV)
+#define glNamedMakeBufferResidentNV		MANGLE(NamedMakeBufferResidentNV)
 #define glNamedProgramLocalParameter4dEXT		MANGLE(NamedProgramLocalParameter4dEXT)
 #define glNamedProgramLocalParameter4dvEXT		MANGLE(NamedProgramLocalParameter4dvEXT)
 #define glNamedProgramLocalParameter4fEXT		MANGLE(NamedProgramLocalParameter4fEXT)
@@ -1091,6 +1118,7 @@
 #define glNormal3iv		MANGLE(Normal3iv)
 #define glNormal3s		MANGLE(Normal3s)
 #define glNormal3sv		MANGLE(Normal3sv)
+#define glNormalFormatNV		MANGLE(NormalFormatNV)
 #define glNormalPointerEXT		MANGLE(NormalPointerEXT)
 #define glNormalPointerListIBM		MANGLE(NormalPointerListIBM)
 #define glNormalPointer		MANGLE(NormalPointer)
@@ -1234,6 +1262,8 @@
 #define glProgramUniformMatrix4fvEXT		MANGLE(ProgramUniformMatrix4fvEXT)
 #define glProgramUniformMatrix4x2fvEXT		MANGLE(ProgramUniformMatrix4x2fvEXT)
 #define glProgramUniformMatrix4x3fvEXT		MANGLE(ProgramUniformMatrix4x3fvEXT)
+#define glProgramUniformui64NV		MANGLE(ProgramUniformui64NV)
+#define glProgramUniformui64vNV		MANGLE(ProgramUniformui64vNV)
 #define glProgramVertexLimitNV		MANGLE(ProgramVertexLimitNV)
 #define glProvokingVertexEXT		MANGLE(ProvokingVertexEXT)
 #define glProvokingVertex		MANGLE(ProvokingVertex)
@@ -1362,6 +1392,7 @@
 #define glSecondaryColor3us		MANGLE(SecondaryColor3us)
 #define glSecondaryColor3usvEXT		MANGLE(SecondaryColor3usvEXT)
 #define glSecondaryColor3usv		MANGLE(SecondaryColor3usv)
+#define glSecondaryColorFormatNV		MANGLE(SecondaryColorFormatNV)
 #define glSecondaryColorPointerEXT		MANGLE(SecondaryColorPointerEXT)
 #define glSecondaryColorPointerListIBM		MANGLE(SecondaryColorPointerListIBM)
 #define glSecondaryColorPointer		MANGLE(SecondaryColorPointer)
@@ -1475,6 +1506,7 @@
 #define glTexCoord4iv		MANGLE(TexCoord4iv)
 #define glTexCoord4s		MANGLE(TexCoord4s)
 #define glTexCoord4sv		MANGLE(TexCoord4sv)
+#define glTexCoordFormatNV		MANGLE(TexCoordFormatNV)
 #define glTexCoordPointerEXT		MANGLE(TexCoordPointerEXT)
 #define glTexCoordPointerListIBM		MANGLE(TexCoordPointerListIBM)
 #define glTexCoordPointer		MANGLE(TexCoordPointer)
@@ -1513,6 +1545,7 @@
 #define glTexSubImage3DEXT		MANGLE(TexSubImage3DEXT)
 #define glTexSubImage3D		MANGLE(TexSubImage3D)
 #define glTexSubImage4DSGIS		MANGLE(TexSubImage4DSGIS)
+#define glTextureBarrierNV		MANGLE(TextureBarrierNV)
 #define glTextureBufferEXT		MANGLE(TextureBufferEXT)
 #define glTextureColorMaskSGIS		MANGLE(TextureColorMaskSGIS)
 #define glTextureImage1DEXT		MANGLE(TextureImage1DEXT)
@@ -1601,6 +1634,8 @@
 #define glUniformMatrix4fv		MANGLE(UniformMatrix4fv)
 #define glUniformMatrix4x2fv		MANGLE(UniformMatrix4x2fv)
 #define glUniformMatrix4x3fv		MANGLE(UniformMatrix4x3fv)
+#define glUniformui64NV		MANGLE(Uniformui64NV)
+#define glUniformui64vNV		MANGLE(Uniformui64vNV)
 #define glUnlockArraysEXT		MANGLE(UnlockArraysEXT)
 #define glUnmapBufferARB		MANGLE(UnmapBufferARB)
 #define glUnmapBuffer		MANGLE(UnmapBuffer)
@@ -1609,6 +1644,7 @@
 #define glUpdateObjectBufferATI		MANGLE(UpdateObjectBufferATI)
 #define glUseProgram		MANGLE(UseProgram)
 #define glUseProgramObjectARB		MANGLE(UseProgramObjectARB)
+#define glUseShaderProgramEXT		MANGLE(UseShaderProgramEXT)
 #define glValidateProgramARB		MANGLE(ValidateProgramARB)
 #define glValidateProgram		MANGLE(ValidateProgram)
 #define glVariantArrayObjectATI		MANGLE(VariantArrayObjectATI)
@@ -1762,6 +1798,7 @@
 #define glVertexAttrib4usv		MANGLE(VertexAttrib4usv)
 #define glVertexAttribArrayObjectATI		MANGLE(VertexAttribArrayObjectATI)
 #define glVertexAttribDivisorARB		MANGLE(VertexAttribDivisorARB)
+#define glVertexAttribFormatNV		MANGLE(VertexAttribFormatNV)
 #define glVertexAttribI1iEXT		MANGLE(VertexAttribI1iEXT)
 #define glVertexAttribI1i		MANGLE(VertexAttribI1i)
 #define glVertexAttribI1ivEXT		MANGLE(VertexAttribI1ivEXT)
@@ -1802,6 +1839,7 @@
 #define glVertexAttribI4uiv		MANGLE(VertexAttribI4uiv)
 #define glVertexAttribI4usvEXT		MANGLE(VertexAttribI4usvEXT)
 #define glVertexAttribI4usv		MANGLE(VertexAttribI4usv)
+#define glVertexAttribIFormatNV		MANGLE(VertexAttribIFormatNV)
 #define glVertexAttribIPointerEXT		MANGLE(VertexAttribIPointerEXT)
 #define glVertexAttribIPointer		MANGLE(VertexAttribIPointer)
 #define glVertexAttribPointerARB		MANGLE(VertexAttribPointerARB)
@@ -1827,6 +1865,7 @@
 #define glVertexBlendARB		MANGLE(VertexBlendARB)
 #define glVertexBlendEnvfATI		MANGLE(VertexBlendEnvfATI)
 #define glVertexBlendEnviATI		MANGLE(VertexBlendEnviATI)
+#define glVertexFormatNV		MANGLE(VertexFormatNV)
 #define glVertexPointerEXT		MANGLE(VertexPointerEXT)
 #define glVertexPointerListIBM		MANGLE(VertexPointerListIBM)
 #define glVertexPointer		MANGLE(VertexPointer)
@@ -1868,6 +1907,10 @@
 #define glVertexWeighthNV		MANGLE(VertexWeighthNV)
 #define glVertexWeighthvNV		MANGLE(VertexWeighthvNV)
 #define glVertexWeightPointerEXT		MANGLE(VertexWeightPointerEXT)
+#define glVideoCaptureNV		MANGLE(VideoCaptureNV)
+#define glVideoCaptureStreamParameterdvNV		MANGLE(VideoCaptureStreamParameterdvNV)
+#define glVideoCaptureStreamParameterfvNV		MANGLE(VideoCaptureStreamParameterfvNV)
+#define glVideoCaptureStreamParameterivNV		MANGLE(VideoCaptureStreamParameterivNV)
 #define glViewport		MANGLE(Viewport)
 #define glWaitSync		MANGLE(WaitSync)
 #define glWeightbvARB		MANGLE(WeightbvARB)
diff --git a/progs/demos/Makefile b/progs/demos/Makefile
index 65fdbaa..f21d916 100644
--- a/progs/demos/Makefile
+++ b/progs/demos/Makefile
@@ -124,13 +124,6 @@ reflect.o: reflect.c showbuffer.h
 	$(APP_CC) -c -I$(INCDIR) $(CFLAGS) reflect.c
 
 
-shadowtex: shadowtex.o showbuffer.o
-	$(APP_CC) $(CFLAGS) $(LDFLAGS) shadowtex.o showbuffer.o $(LIBS) -o $@
-
-shadowtex.o: shadowtex.c showbuffer.h
-	$(APP_CC) -c -I$(INCDIR) $(CFLAGS) shadowtex.c
-
-
 gloss: gloss.o trackball.o readtex.o
 	$(APP_CC) $(CFLAGS) $(LDFLAGS) gloss.o trackball.o readtex.o $(LIBS) -o $@
 
diff --git a/progs/demos/engine.c b/progs/demos/engine.c
index 3cf311e..838d28c 100644
--- a/progs/demos/engine.c
+++ b/progs/demos/engine.c
@@ -120,7 +120,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    },
    {
       "Inline-4",
@@ -136,7 +140,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    },
    {
       "Boxer-6",
@@ -152,7 +160,11 @@ static Engine Engines[NUM_ENGINES] =
       0.3,  /* CrankJournalRadius */
       0.4,  /* CrankJournalLength */
       1.5,  /* ConnectingRodLength */
-      0.1   /* ConnectingRodThickness */
+      0.1,  /* ConnectingRodThickness */
+      0,    /* CrankList */
+      0,    /* ConnRodList */
+      0,    /* PistonList */
+      0     /* BlockList */
    }
 };
 
diff --git a/progs/demos/fbotexture.c b/progs/demos/fbotexture.c
index 5648266..46bf1c5 100644
--- a/progs/demos/fbotexture.c
+++ b/progs/demos/fbotexture.c
@@ -14,7 +14,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <math.h>
 #include "extfuncs.h"
 
 /* For debug */
diff --git a/progs/demos/fire.c b/progs/demos/fire.c
index dd70f61..475582c 100644
--- a/progs/demos/fire.c
+++ b/progs/demos/fire.c
@@ -6,6 +6,7 @@
  *            Humanware s.r.l.
  */
 
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
@@ -725,8 +726,13 @@ main(int ac, char **av)
 
    maxage = 1.0 / dt;
 
-   if (ac == 2)
+   if (ac == 2) {
       np = atoi(av[1]);
+      if (np <= 0 || np > 1000000) {
+         fprintf(stderr, "Invalid input.\n");
+         exit(-1);
+      }
+   }
 
    if (ac == 4) {
       WIDTH = atoi(av[2]);
@@ -759,7 +765,9 @@ main(int ac, char **av)
    glFogfv(GL_FOG_COLOR, fogcolor);
    glFogf(GL_FOG_DENSITY, 0.1);
 
+   assert(np > 0);
    p = (part *) malloc(sizeof(part) * np);
+   assert(p);
 
    for (i = 0; i < np; i++)
       setnewpart(&p[i]);
diff --git a/progs/demos/geartrain.c b/progs/demos/geartrain.c
index 8fe405e..e6567dd 100644
--- a/progs/demos/geartrain.c
+++ b/progs/demos/geartrain.c
@@ -25,6 +25,7 @@
  */
 
 
+#include <assert.h>
 #include <math.h>
 #include <stdlib.h>
 #include <GL/glut.h>
@@ -129,8 +130,10 @@ Clear_Buffers ()
 static void
 LoadTriplet (TDA A)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s %s %s", Buf1, Buf2, Buf3, Buf4);
+    result = fscanf (mainfile, "%s %s %s %s", Buf1, Buf2, Buf3, Buf4);
+    assert(result != EOF);
     A[0] = atof (Buf2);
     A[1] = atof (Buf3);
     A[2] = atof (Buf4);
@@ -140,8 +143,10 @@ LoadTriplet (TDA A)
 static void
 LoadReal (float *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     *a = atof (Buf2);
 }
 
@@ -149,8 +154,10 @@ LoadReal (float *a)
 static void
 LoadInteger (int *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     *a = atoi (Buf2);
 }
 
@@ -158,8 +165,10 @@ LoadInteger (int *a)
 static void
 LoadText (char *a)
 {
+    int result;
     Clear_Buffers ();
-    fscanf (mainfile, "%s %s", Buf1, Buf2);
+    result = fscanf (mainfile, "%s %s", Buf1, Buf2);
+    assert(result != EOF);
     strcpy (a, Buf2);
 }
 
@@ -177,8 +186,10 @@ getdata (char filename[])
 
     do
     {
+	int result;
 	Clear_Buffers ();
-	fscanf (mainfile, "%s", Buf1);
+	result = fscanf (mainfile, "%s", Buf1);
+	(void) result;
 	if (ferror (mainfile))
 	{
 	    printf ("\nError opening file !\n");
diff --git a/progs/demos/isosurf.c b/progs/demos/isosurf.c
index 2e9dff1..d9e50a3 100644
--- a/progs/demos/isosurf.c
+++ b/progs/demos/isosurf.c
@@ -27,7 +27,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
-#include <string.h>
 #include <math.h>
 #ifdef _WIN32
 #include <windows.h>
@@ -132,9 +131,11 @@ static void read_surface( char *filename )
 
    numverts = 0;
    while (!feof(f) && numverts<maxverts) {
-      fscanf( f, "%f %f %f  %f %f %f",
-	      &data[numverts][0], &data[numverts][1], &data[numverts][2],
-	      &data[numverts][3], &data[numverts][4], &data[numverts][5] );
+      int result;
+      result = fscanf( f, "%f %f %f  %f %f %f",
+	               &data[numverts][0], &data[numverts][1], &data[numverts][2],
+	               &data[numverts][3], &data[numverts][4], &data[numverts][5] );
+      (void) result;
       numverts++;
    }
    numverts--;
diff --git a/progs/demos/morph3d.c b/progs/demos/morph3d.c
index 01a06ab..eab520a 100644
--- a/progs/demos/morph3d.c
+++ b/progs/demos/morph3d.c
@@ -137,7 +137,6 @@ So the angle is:
 #endif
 #include <GL/glut.h>
 #include <math.h>
-#include <string.h>
 
 #define Scale                      0.3
 
diff --git a/progs/demos/shadowtex.c b/progs/demos/shadowtex.c
index dc5a4bb..59d0070 100644
--- a/progs/demos/shadowtex.c
+++ b/progs/demos/shadowtex.c
@@ -38,7 +38,6 @@
 #include <math.h>
 #include <GL/glew.h>
 #include <GL/glut.h>
-#include "showbuffer.h"
 
 #define DEG_TO_RAD (3.14159 / 180.0)
 
diff --git a/progs/demos/terrain.c b/progs/demos/terrain.c
index be78ea4..9ba7b61 100644
--- a/progs/demos/terrain.c
+++ b/progs/demos/terrain.c
@@ -8,6 +8,7 @@
  * based on a Mikael SkiZoWalker's (MoDEL) / France (Skizo@Hol.Fr) demo
  */
 
+#include <assert.h>
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
@@ -559,12 +560,14 @@ loadpic(void)
    FILE *FilePic;
    int i, tmp;
    GLenum gluerr;
+   size_t result;
 
    if ((FilePic = fopen("terrain.dat", "r")) == NULL) {
       fprintf(stderr, "Error loading terrain.dat\n");
       exit(-1);
    }
-   fread(bufferter, 256 * 256, 1, FilePic);
+   result = fread(bufferter, 256 * 256, 1, FilePic);
+   assert(result == 1);
    fclose(FilePic);
 
    for (i = 0; i < (256 * 256); i++) {
diff --git a/progs/glsl/convolutions.c b/progs/glsl/convolutions.c
index 350e61b..fdfaf56 100644
--- a/progs/glsl/convolutions.c
+++ b/progs/glsl/convolutions.c
@@ -182,7 +182,7 @@ static void fillConvolution(GLint *k,
 static void setupConvolution()
 {
    GLint *kernel = (GLint*)malloc(sizeof(GLint) * 9);
-   GLfloat scale;
+   GLfloat scale = 0.0;
    GLfloat *vecKer = (GLfloat*)malloc(sizeof(GLfloat) * 9 * 4);
    GLuint loc;
    GLuint i;
diff --git a/progs/glsl/shtest.c b/progs/glsl/shtest.c
index 88315d7..520eccf 100644
--- a/progs/glsl/shtest.c
+++ b/progs/glsl/shtest.c
@@ -29,7 +29,6 @@
 
 
 #include <assert.h>
-#include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -492,9 +491,8 @@ ReadConfigFile(const char *filename, struct config_file *conf)
    conf->num_uniforms = 0;
 
    /* ugly but functional parser */
-   while (!feof(f)) {
-      fgets(line, sizeof(line), f);
-      if (!feof(f) && line[0]) {
+   while (fgets(line, sizeof(line), f) != NULL) {
+      if (line[0]) {
          if (strncmp(line, "vs ", 3) == 0) {
             VertShaderFile = strdup(line + 3);
             VertShaderFile[strlen(VertShaderFile) - 1] = 0;
@@ -550,6 +548,10 @@ ReadConfigFile(const char *filename, struct config_file *conf)
 
             type = TypeFromName(typeName);
 
+            if (strlen(name) + 1 > sizeof(conf->uniforms[conf->num_uniforms].name)) {
+               fprintf(stderr, "string overflow\n");
+               exit(1);
+            }
             strcpy(conf->uniforms[conf->num_uniforms].name, name);
             conf->uniforms[conf->num_uniforms].value[0] = v1;
             conf->uniforms[conf->num_uniforms].value[1] = v2;
diff --git a/progs/glsl/vert-tex.c b/progs/glsl/vert-tex.c
index 4c8bfa5..2b93c78 100644
--- a/progs/glsl/vert-tex.c
+++ b/progs/glsl/vert-tex.c
@@ -40,15 +40,6 @@ static GLboolean Anim = GL_TRUE;
 static GLboolean WireFrame = GL_TRUE;
 static GLfloat xRot = -70.0f, yRot = 0.0f, zRot = 0.0f;
 
-
-/* value[0] = tex unit */
-static struct uniform_info Uniforms[] = {
-   { "tex1",  1, GL_SAMPLER_2D, { 0, 0, 0, 0 }, -1 },
-   END_OF_UNIFORMS
-};
-
-
-
 static void
 Idle(void)
 {
diff --git a/progs/redbook/aapoly.c b/progs/redbook/aapoly.c
index b7b2b27..64d06b7 100644
--- a/progs/redbook/aapoly.c
+++ b/progs/redbook/aapoly.c
@@ -45,7 +45,6 @@
 #include <GL/glut.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include <string.h>
 
 GLboolean polySmooth = GL_TRUE;
 
diff --git a/progs/samples/olympic.c b/progs/samples/olympic.c
index 5385e48..209a8c1 100644
--- a/progs/samples/olympic.c
+++ b/progs/samples/olympic.c
@@ -74,7 +74,7 @@ int iters[RINGS];
 GLuint theTorus;
 
 
-void FillTorus(float rc, int numc, float rt, int numt)
+static void FillTorus(float rc, int numc, float rt, int numt)
 {
     int i, j, k;
     double s, t;
@@ -106,7 +106,7 @@ void FillTorus(float rc, int numc, float rt, int numt)
     }
 }
 
-float Clamp(int iters_left, float t)
+static float Clamp(int iters_left, float t)
 {
     if (iters_left < 3) {
 	return 0.0;
@@ -114,7 +114,7 @@ float Clamp(int iters_left, float t)
     return (iters_left-2)*t/iters_left;
 }
 
-void DrawScene(void)
+static void DrawScene(void)
 {
     int i, j;
     GLboolean goIdle;
@@ -172,7 +172,7 @@ void DrawScene(void)
     }
 }
 
-float MyRand(void)
+static float MyRand(void)
 {
    return 10.0 * ( (float) rand() / (float) RAND_MAX - 0.5 );
 }
@@ -181,12 +181,12 @@ float MyRand(void)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
 
-void ReInit(void)
+static void ReInit(void)
 {
     int i;
     float deviation;
@@ -206,7 +206,7 @@ void ReInit(void)
     glutIdleFunc(glut_post_redisplay_p);
 }
 
-void Init(void)
+static void Init(void)
 {
     float base, height;
     float aspect, x, y;
@@ -312,13 +312,13 @@ void Init(void)
     glMatrixMode(GL_MODELVIEW);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     glViewport(0, 0, width, height);
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -330,7 +330,7 @@ void Key(unsigned char key, int x, int y)
     }
 }
 
-GLenum Args(int argc, char **argv)
+static GLenum Args(int argc, char **argv)
 {
     GLint i;
 
diff --git a/progs/samples/overlay.c b/progs/samples/overlay.c
index 23b5a47..6087cef 100644
--- a/progs/samples/overlay.c
+++ b/progs/samples/overlay.c
@@ -69,19 +69,19 @@ starRec stars[MAXSTARS];
 float sinTable[MAXANGLES];
 
 
-float Sin(float angle)
+static float Sin(float angle)
 {
 
     return (sinTable[(GLint)angle]);
 }
 
-float Cos(float angle)
+static float Cos(float angle)
 {
 
     return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]);
 }
 
-void NewStar(GLint n, GLint d)
+static void NewStar(GLint n, GLint d)
 {
 
     if (rand()%4 == 0) {
@@ -103,7 +103,7 @@ void NewStar(GLint n, GLint d)
     }
 }
 
-void RotatePoint(float *x, float *y, float rotation)
+static void RotatePoint(float *x, float *y, float rotation)
 {
     float tmpX, tmpY;
 
@@ -113,7 +113,7 @@ void RotatePoint(float *x, float *y, float rotation)
     *y = tmpY;
 }
 
-void MoveStars(void)
+static void MoveStars(void)
 {
     float offset;
     GLint n;
@@ -134,7 +134,7 @@ void MoveStars(void)
     }
 }
 
-GLenum StarPoint(GLint n)
+static GLenum StarPoint(GLint n)
 {
     float x0, y0, x1, y1, width;
     GLint i;
@@ -182,7 +182,7 @@ GLenum StarPoint(GLint n)
     }
 }
 
-void ShowStars(void)
+static void ShowStars(void)
 {
     GLint n;
 
@@ -221,7 +221,7 @@ static void Init(void)
     glDisable(GL_DITHER);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     windW = (GLint)width;
@@ -262,7 +262,7 @@ static void Key(unsigned char key, int x, int y)
     }
 }
 
-void Idle(void)
+static void Idle(void)
 {
 
     if (overlayInit == GL_FALSE) {
diff --git a/progs/samples/rgbtoppm.c b/progs/samples/rgbtoppm.c
index dcb7422..403578e 100644
--- a/progs/samples/rgbtoppm.c
+++ b/progs/samples/rgbtoppm.c
@@ -3,6 +3,7 @@
 
 /* texload is a simplistic routine for reading an SGI .rgb image file. */
 
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h> 
 #include <string.h>
@@ -25,7 +26,7 @@ typedef struct _ImageRec {
     int *rowSize;
 } ImageRec;
 
-void
+static void
 rgbtorgb(unsigned char *r,unsigned char *g,unsigned char *b,unsigned char *l,int n) {
     while(n--) {
         l[0] = r[0];
@@ -72,6 +73,7 @@ static ImageRec *ImageOpen(char *fileName)
     ImageRec *image;
     int swapFlag;
     int x;
+    int result;
 
     endianTest.testWord = 1;
     if (endianTest.testByte[0] == 1) {
@@ -90,7 +92,8 @@ static ImageRec *ImageOpen(char *fileName)
         return NULL;
     }
 
-    fread(image, 1, 12, image->file);
+    result = fread(image, 1, 12, image->file);
+    assert(result == 12);
 
     if (swapFlag) {
         ConvertShort(&image->imagic, 1);
@@ -117,8 +120,10 @@ static ImageRec *ImageOpen(char *fileName)
         }
         image->rleEnd = 512 + (2 * x);
         fseek(image->file, 512, SEEK_SET);
-        fread(image->rowStart, 1, x, image->file);
-        fread(image->rowSize, 1, x, image->file);
+        result = fread(image->rowStart, 1, x, image->file);
+        assert(result == x);
+        result = fread(image->rowSize, 1, x, image->file);
+        assert(result == x);
         if (swapFlag) {
             ConvertUint(image->rowStart, x/(int) sizeof(unsigned));
             ConvertUint((unsigned *)image->rowSize, x/(int) sizeof(int));
@@ -138,11 +143,13 @@ static void
 ImageGetRow(ImageRec *image, unsigned char *buf, int y, int z) {
     unsigned char *iPtr, *oPtr, pixel;
     int count;
+    int result;
 
     if ((image->type & 0xFF00) == 0x0100) {
         fseek(image->file, (long) image->rowStart[y+z*image->ysize], SEEK_SET);
-        fread(image->tmp, 1, (unsigned int)image->rowSize[y+z*image->ysize],
-              image->file);
+        result = fread(image->tmp, 1, (unsigned int)image->rowSize[y+z*image->ysize],
+                       image->file);
+        assert(result == (unsigned int)image->rowSize[y+z*image->ysize]);
 
         iPtr = image->tmp;
         oPtr = buf;
@@ -166,11 +173,13 @@ ImageGetRow(ImageRec *image, unsigned char *buf, int y, int z) {
     } else {
         fseek(image->file, 512+(y*image->xsize)+(z*image->xsize*image->ysize),
               SEEK_SET);
-        fread(buf, 1, image->xsize, image->file);
+        result = fread(buf, 1, image->xsize, image->file);
+        assert(result == image->xsize);
     }
 }
 
-GLubyte *
+#if 0
+static GLubyte *
 read_alpha_texture(char *name, int *width, int *height)
 {
     unsigned char *base, *lptr;
@@ -199,8 +208,9 @@ read_alpha_texture(char *name, int *width, int *height)
 
     return (unsigned char *) base;
 }
+#endif
 
-GLubyte *
+static GLubyte *
 read_rgb_texture(char *name, int *width, int *height)
 {
     unsigned char *base, *ptr;
@@ -261,7 +271,8 @@ read_rgb_texture(char *name, int *width, int *height)
 
 int main(int argc, char **argv)
 {
-	int width, height;
+	int width = 0;
+	int height = 0;
 	GLubyte *data;
         char buff[32];
         int n;
diff --git a/progs/samples/sphere.c b/progs/samples/sphere.c
index 7d0508d..23d4fe3 100644
--- a/progs/samples/sphere.c
+++ b/progs/samples/sphere.c
@@ -445,7 +445,7 @@ GLfloat identity[16] = {
 };
 
 
-void BuildCylinder(int numEdges)
+static void BuildCylinder(int numEdges)
 {
     int i, top = 1.0, bottom = -1.0;
     float x[100], y[100], angle;
@@ -481,7 +481,7 @@ void BuildCylinder(int numEdges)
     glEndList();
 }
 
-void BuildTorus(float rc, int numc, float rt, int numt)
+static void BuildTorus(float rc, int numc, float rt, int numt)
 {
     int i, j, k;
     double s, t;
@@ -515,7 +515,7 @@ void BuildTorus(float rc, int numc, float rt, int numt)
     glEndList();
 }
 
-void BuildCage(void)
+static void BuildCage(void)
 {
     int i;
     float inc;
@@ -609,7 +609,7 @@ void BuildCage(void)
     glEndList();
 }
 
-void BuildCube(void)
+static void BuildCube(void)
 {
     int i, j;
 
@@ -628,7 +628,7 @@ void BuildCube(void)
     glEndList();
 }
 
-void BuildLists(void)
+static void BuildLists(void)
 {
 
     cube = glGenLists(1);
@@ -646,7 +646,7 @@ void BuildLists(void)
     genericObject = torus;
 }
 
-void SetDefaultSettings(void)
+static void SetDefaultSettings(void)
 {
 
     magFilter = nnearest;
@@ -657,7 +657,7 @@ void SetDefaultSettings(void)
     autoRotate = GL_TRUE;
 }
 
-unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
+static unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
 {
     unsigned char *outData, *out_ptr, *in_ptr;
     int i;
@@ -677,7 +677,7 @@ unsigned char *AlphaPadImage(int bufSize, unsigned char *inData, int alpha)
     return outData;
 }
 
-void Init(void)
+static void Init(void)
 {
     float ambient[] = {0.0, 0.0, 0.0, 1.0};
     float diffuse[] = {1.0, 1.0, 1.0, 1.0};
@@ -753,7 +753,7 @@ void Init(void)
     BuildLists();
 }
 
-void ReInit(void)
+static void ReInit(void)
 {
     if (genericObject == torus) {
 	glEnable(GL_DEPTH_TEST);
@@ -773,7 +773,7 @@ void ReInit(void)
     glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, textureEnvironment);
 }
 
-void Draw(void)
+static void Draw(void)
 {
     glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
 
@@ -806,7 +806,7 @@ void Draw(void)
     glutSwapBuffers();
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
     W = width;
     H = height;
@@ -818,7 +818,7 @@ void Reshape(int width, int height)
     glMatrixMode(GL_MODELVIEW);
 }
 
-void Idle(void)
+static void Idle(void)
 {
    static double t0 = -1.;
    double t, dt;
@@ -833,7 +833,7 @@ void Idle(void)
    glutPostRedisplay();
 }
 
-void Key2(int key, int x, int y)
+static void Key2(int key, int x, int y)
 {
 
     switch (key) {
@@ -863,7 +863,7 @@ void Key2(int key, int x, int y)
     glutPostRedisplay();
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -950,7 +950,7 @@ void Key(unsigned char key, int x, int y)
     glutPostRedisplay();
 }
 
-GLenum Args(int argc, char **argv)
+static GLenum Args(int argc, char **argv)
 {
     GLint i;
 
diff --git a/progs/samples/star.c b/progs/samples/star.c
index 2cf470e..2c44ebf 100644
--- a/progs/samples/star.c
+++ b/progs/samples/star.c
@@ -67,19 +67,19 @@ starRec stars[MAXSTARS];
 float sinTable[MAXANGLES];
 
 
-float Sin(float angle)
+static float Sin(float angle)
 {
 
     return (sinTable[(GLint)angle]);
 }
 
-float Cos(float angle)
+static float Cos(float angle)
 {
 
     return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]);
 }
 
-void NewStar(GLint n, GLint d)
+static void NewStar(GLint n, GLint d)
 {
 
     if (rand()%4 == 0) {
@@ -101,7 +101,7 @@ void NewStar(GLint n, GLint d)
     }
 }
 
-void RotatePoint(float *x, float *y, float rotation)
+static void RotatePoint(float *x, float *y, float rotation)
 {
     float tmpX, tmpY;
 
@@ -111,7 +111,7 @@ void RotatePoint(float *x, float *y, float rotation)
     *y = tmpY;
 }
 
-void MoveStars(void)
+static void MoveStars(void)
 {
     float offset;
     GLint n;
@@ -142,7 +142,7 @@ void MoveStars(void)
     }
 }
 
-GLenum StarPoint(GLint n)
+static GLenum StarPoint(GLint n)
 {
     float x0, y0, x1, y1, width;
     GLint i;
@@ -190,7 +190,7 @@ GLenum StarPoint(GLint n)
     }
 }
 
-void ShowStars(void)
+static void ShowStars(void)
 {
     GLint n;
 
@@ -229,7 +229,7 @@ static void Init(void)
     glDisable(GL_DITHER);
 }
 
-void Reshape(int width, int height)
+static void Reshape(int width, int height)
 {
 
     windW = (GLint)width;
@@ -260,7 +260,7 @@ static void Key(unsigned char key, int x, int y)
     }
 }
 
-void Draw(void)
+static void Draw(void)
 {
 
     MoveStars();
@@ -307,7 +307,7 @@ static GLenum Args(int argc, char **argv)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
diff --git a/progs/samples/stretch.c b/progs/samples/stretch.c
index 1fd015d..11201dc 100644
--- a/progs/samples/stretch.c
+++ b/progs/samples/stretch.c
@@ -67,7 +67,7 @@ int cCount, cIndex[2], cStep;
 GLenum op = OP_NOOP;
 
 
-void DrawImage(void)
+static void DrawImage(void)
 {
 
     glRasterPos2i(0, 0);
@@ -84,7 +84,7 @@ void DrawImage(void)
 		 image->data);
 }
 
-void DrawPoint(void)
+static void DrawPoint(void)
 {
     int i;
 
@@ -102,7 +102,7 @@ void DrawPoint(void)
     }
 }
 
-void InitVList(void)
+static void InitVList(void)
 {
 
     vList[0].x = 0.0;
@@ -141,7 +141,7 @@ void InitVList(void)
     vList[4].tY = cList[0].y / (float)imageSizeY;
 }
 
-void ScaleImage(int sizeX, int sizeY)
+static void ScaleImage(int sizeX, int sizeY)
 {
     GLubyte *buf;
 
@@ -154,7 +154,7 @@ void ScaleImage(int sizeX, int sizeY)
     image->sizeY = sizeY;
 }
 
-void SetPoint(int x, int y)
+static void SetPoint(int x, int y)
 {
 
     cList[cCount].x = (float)x;
@@ -162,7 +162,7 @@ void SetPoint(int x, int y)
     cCount++;
 }
 
-void Stretch(void)
+static void Stretch(void)
 {
 
     glBegin(GL_TRIANGLES);
@@ -221,7 +221,7 @@ void Stretch(void)
     }
 }
 
-void Key(unsigned char key, int x, int y)
+static void Key(unsigned char key, int x, int y)
 {
 
     switch (key) {
@@ -245,7 +245,7 @@ void Key(unsigned char key, int x, int y)
     glutPostRedisplay();
 }
 
-void Mouse(int button, int state, int mouseX, int mouseY)
+static void Mouse(int button, int state, int mouseX, int mouseY)
 {
 
     if (state != GLUT_DOWN)
@@ -263,7 +263,7 @@ void Mouse(int button, int state, int mouseX, int mouseY)
     glutPostRedisplay();
 }
 
-void Animate(void)
+static void Animate(void)
 {
     static double t0 = -1.;
     double t, dt;
@@ -322,7 +322,7 @@ static GLenum Args(int argc, char **argv)
 #define GLUTCALLBACK
 #endif
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
       glutPostRedisplay();
 }
diff --git a/progs/samples/wave.c b/progs/samples/wave.c
index d3c4687..396a694 100644
--- a/progs/samples/wave.c
+++ b/progs/samples/wave.c
@@ -92,7 +92,7 @@ GLubyte contourTexture2[] = {
 #endif
 
 
-void GLUTCALLBACK glut_post_redisplay_p(void)
+static void GLUTCALLBACK glut_post_redisplay_p(void)
 {
     static double t0 = -1.;
     double t, dt;
diff --git a/progs/util/readtex.c b/progs/util/readtex.c
index d1c50a4..f6f5114 100644
--- a/progs/util/readtex.c
+++ b/progs/util/readtex.c
@@ -9,6 +9,7 @@
 
 #include <GL/gl.h>
 #include <GL/glu.h>
+#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h> 
 #include <string.h>
@@ -89,6 +90,7 @@ static rawImageRec *RawImageOpen(const char *fileName)
    rawImageRec *raw;
    GLenum swapFlag;
    int x;
+   size_t result;
 
    endianTest.testWord = 1;
    if (endianTest.testByte[0] == 1) {
@@ -114,7 +116,8 @@ static rawImageRec *RawImageOpen(const char *fileName)
       }
    }
 
-   fread(raw, 1, 12, raw->file);
+   result = fread(raw, 1, 12, raw->file);
+   assert(result == 12);
 
    if (swapFlag) {
       ConvertShort(&raw->imagic, 1);
@@ -162,8 +165,10 @@ static rawImageRec *RawImageOpen(const char *fileName)
       }
       raw->rleEnd = 512 + (2 * x);
       fseek(raw->file, 512, SEEK_SET);
-      fread(raw->rowStart, 1, x, raw->file);
-      fread(raw->rowSize, 1, x, raw->file);
+      result = fread(raw->rowStart, 1, x, raw->file);
+      assert(result == x);
+      result = fread(raw->rowSize, 1, x, raw->file);
+      assert(result == x);
       if (swapFlag) {
          ConvertLong(raw->rowStart, (long) (x/sizeof(GLuint)));
          ConvertLong((GLuint *)raw->rowSize, (long) (x/sizeof(GLint)));
@@ -193,11 +198,13 @@ static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
 {
    unsigned char *iPtr, *oPtr, pixel;
    int count, done = 0;
+   size_t result;
 
    if ((raw->type & 0xFF00) == 0x0100) {
       fseek(raw->file, (long) raw->rowStart[y+z*raw->sizeY], SEEK_SET);
-      fread(raw->tmp, 1, (unsigned int)raw->rowSize[y+z*raw->sizeY],
-            raw->file);
+      result = fread(raw->tmp, 1, (unsigned int)raw->rowSize[y+z*raw->sizeY],
+                     raw->file);
+      assert(result == (unsigned int)raw->rowSize[y+z*raw->sizeY]);
       
       iPtr = raw->tmp;
       oPtr = buf;
@@ -222,7 +229,8 @@ static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
    } else {
       fseek(raw->file, 512+(y*raw->sizeX)+(z*raw->sizeX*raw->sizeY),
             SEEK_SET);
-      fread(buf, 1, raw->sizeX, raw->file);
+      result = fread(buf, 1, raw->sizeX, raw->file);
+      assert(result == raw->sizeX);
    }
 }
 
diff --git a/progs/xdemos/corender.c b/progs/xdemos/corender.c
index 640c902..e706f4b 100644
--- a/progs/xdemos/corender.c
+++ b/progs/xdemos/corender.c
@@ -20,7 +20,6 @@
 #include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <X11/keysym.h>
 #include <unistd.h>
 #include "ipc.h"
diff --git a/progs/xdemos/glsync.c b/progs/xdemos/glsync.c
index da87306..9d4b0f1 100644
--- a/progs/xdemos/glsync.c
+++ b/progs/xdemos/glsync.c
@@ -89,7 +89,7 @@ static char optstr[] = "w:h:s:v";
 enum sync_type {
 	none = 0,
 	sgi_video_sync,
-	buffer_swap,
+	buffer_swap
 };
 
 static void usage(char *name)
diff --git a/progs/xdemos/glxgears.c b/progs/xdemos/glxgears.c
index 088f25a..2993c82 100644
--- a/progs/xdemos/glxgears.c
+++ b/progs/xdemos/glxgears.c
@@ -771,6 +771,7 @@ main(int argc, char *argv[])
    glDeleteLists(gear1, 1);
    glDeleteLists(gear2, 1);
    glDeleteLists(gear3, 1);
+   glXMakeCurrent(dpy, None, NULL);
    glXDestroyContext(dpy, ctx);
    XDestroyWindow(dpy, win);
    XCloseDisplay(dpy);
diff --git a/progs/xdemos/glxheads.c b/progs/xdemos/glxheads.c
index b1a63d3..edae0a3 100644
--- a/progs/xdemos/glxheads.c
+++ b/progs/xdemos/glxheads.c
@@ -145,14 +145,40 @@ AddHead(const char *displayName)
    /* save the info for this head */
    {
       struct head *h = &Heads[NumHeads];
+      const char * tmp;
+
+      if (strlen(displayName) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "displayName string length overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, displayName);
+
       h->Dpy = dpy;
       h->Win = win;
       h->Context = ctx;
       h->Angle = 0.0;
-      strcpy(h->Version, (char *) glGetString(GL_VERSION));
-      strcpy(h->Vendor, (char *) glGetString(GL_VENDOR));
-      strcpy(h->Renderer, (char *) glGetString(GL_RENDERER));
+
+      tmp = (char *) glGetString(GL_VERSION);
+      if (strlen(tmp) + 1 > sizeof(h->Version)) {
+         Error(displayName, "GL_VERSION string length overflow");
+         return NULL;
+      }
+      strcpy(h->Version, tmp);
+
+      tmp = (char *) glGetString(GL_VENDOR);
+      if (strlen(tmp) + 1 > sizeof(h->Vendor)) {
+         Error(displayName, "GL_VENDOR string length overflow");
+         return NULL;
+      }
+      strcpy(h->Vendor, tmp);
+
+      tmp = (char *) glGetString(GL_RENDERER);
+      if (strlen(tmp) + 1 > sizeof(h->Renderer)) {
+         Error(displayName, "GL_RENDERER string length overflow");
+         return NULL;
+      }
+      strcpy(h->Renderer, tmp);
+
       NumHeads++;
       return &Heads[NumHeads-1];
    }
diff --git a/progs/xdemos/manywin.c b/progs/xdemos/manywin.c
index ee357f3..8ad5c4f 100644
--- a/progs/xdemos/manywin.c
+++ b/progs/xdemos/manywin.c
@@ -177,14 +177,40 @@ AddHead(const char *displayName, const char *name)
    /* save the info for this head */
    {
       struct head *h = &Heads[NumHeads];
+      const char * tmp;
+
+      if (strlen(name) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "name string overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, name);
+
       h->Dpy = dpy;
       h->Win = win;
       h->Context = ctx;
       h->Angle = 0.0;
-      strcpy(h->Version, (char *) glGetString(GL_VERSION));
-      strcpy(h->Vendor, (char *) glGetString(GL_VENDOR));
-      strcpy(h->Renderer, (char *) glGetString(GL_RENDERER));
+
+      tmp = (char *) glGetString(GL_VERSION);
+      if (strlen(tmp) + 1 > sizeof(h->Version)) {
+         Error(displayName, "GL_VERSION string overflow");
+         return NULL;
+      }
+      strcpy(h->Version, tmp);
+
+      tmp = (char *) glGetString(GL_VENDOR);
+      if (strlen(tmp) + 1 > sizeof(h->Vendor)) {
+         Error(displayName, "GL_VENDOR string overflow");
+         return NULL;
+      }
+      strcpy(h->Vendor, tmp);
+
+      tmp = (char *) glGetString(GL_RENDERER);
+      if (strlen(tmp) + 1 > sizeof(h->Renderer)) {
+         Error(displayName, "GL_RENDERER string overflow");
+         return NULL;
+      }
+      strcpy(h->Renderer, tmp);
+
       NumHeads++;
       return &Heads[NumHeads-1];
    }
@@ -374,6 +400,8 @@ main(int argc, char *argv[])
       }
       if (n < 1)
          n = 1;
+      if (n > MAX_HEADS)
+         n = MAX_HEADS;
 
       printf("%d windows\n", n);
       for (i = 0; i < n; i++) {
diff --git a/progs/xdemos/sharedtex_mt.c b/progs/xdemos/sharedtex_mt.c
index f924448..a90903a 100644
--- a/progs/xdemos/sharedtex_mt.c
+++ b/progs/xdemos/sharedtex_mt.c
@@ -174,6 +174,10 @@ AddWindow(Display *dpy, const char *displayName, int xpos, int ypos,
    {
       static int id = 0;
       struct window *h = &Windows[NumWindows];
+      if (strlen(displayName) + 1 > sizeof(h->DisplayName)) {
+         Error(displayName, "string overflow");
+         return NULL;
+      }
       strcpy(h->DisplayName, displayName);
       h->Dpy = dpy;
       h->Win = win;
diff --git a/src/gallium/auxiliary/draw/draw_context.c b/src/gallium/auxiliary/draw/draw_context.c
index a4f1fcd..b814ecb 100644
--- a/src/gallium/auxiliary/draw/draw_context.c
+++ b/src/gallium/auxiliary/draw/draw_context.c
@@ -34,10 +34,7 @@
 #include "util/u_memory.h"
 #include "util/u_math.h"
 #include "draw_context.h"
-#include "draw_vbuf.h"
 #include "draw_vs.h"
-#include "draw_pt.h"
-#include "draw_pipe.h"
 
 
 struct draw_context *draw_create( void )
diff --git a/src/gallium/auxiliary/draw/draw_pipe.c b/src/gallium/auxiliary/draw/draw_pipe.c
index 1c6d657..11d6485 100644
--- a/src/gallium/auxiliary/draw/draw_pipe.c
+++ b/src/gallium/auxiliary/draw/draw_pipe.c
@@ -106,10 +106,9 @@ void draw_pipeline_destroy( struct draw_context *draw )
 
 
 
-
-
-
-
+/**
+ * Build primitive to render a point with vertex at v0.
+ */
 static void do_point( struct draw_context *draw,
 		      const char *v0 )
 {
@@ -123,6 +122,10 @@ static void do_point( struct draw_context *draw,
 }
 
 
+/**
+ * Build primitive to render a line with vertices at v0, v1.
+ * \param flags  bitmask of DRAW_PIPE_EDGE_x, DRAW_PIPE_RESET_STIPPLE
+ */
 static void do_line( struct draw_context *draw,
                      ushort flags,
 		     const char *v0,
@@ -139,6 +142,10 @@ static void do_line( struct draw_context *draw,
 }
 
 
+/**
+ * Build primitive to render a triangle with vertices at v0, v1, v2.
+ * \param flags  bitmask of DRAW_PIPE_EDGE_x, DRAW_PIPE_RESET_STIPPLE
+ */
 static void do_triangle( struct draw_context *draw,
                          ushort flags,
 			 char *v0,
@@ -157,7 +164,10 @@ static void do_triangle( struct draw_context *draw,
 }
 
 
-
+/*
+ * Set up macros for draw_pt_decompose.h template code.
+ * This code uses vertex indexes / elements.
+ */
 #define QUAD(i0,i1,i2,i3)                       \
    do_triangle( draw,                           \
                 ( DRAW_PIPE_RESET_STIPPLE |     \
@@ -175,16 +185,16 @@ static void do_triangle( struct draw_context *draw,
 
 #define TRIANGLE(flags,i0,i1,i2)                                        \
    do_triangle( draw,                                                   \
-                elts[i0],  /* flags */                          \
+                elts[i0],  /* flags */                                  \
                 verts + stride * (elts[i0] & ~DRAW_PIPE_FLAG_MASK),     \
-                verts + stride * elts[i1],                              \
-                verts + stride * elts[i2])
+                verts + stride * (elts[i1] & ~DRAW_PIPE_FLAG_MASK),     \
+                verts + stride * (elts[i2] & ~DRAW_PIPE_FLAG_MASK) );
 
 #define LINE(flags,i0,i1)                                       \
    do_line( draw,                                               \
-            elts[i0],                                   \
+            elts[i0],                                           \
             verts + stride * (elts[i0] & ~DRAW_PIPE_FLAG_MASK), \
-            verts + stride * elts[i1])
+            verts + stride * (elts[i1] & ~DRAW_PIPE_FLAG_MASK) );
 
 #define POINT(i0)                               \
    do_point( draw,                              \
@@ -213,7 +223,9 @@ static void do_triangle( struct draw_context *draw,
 
 
 
-/* Code to run the pipeline on a fairly arbitary collection of vertices.
+/**
+ * Code to run the pipeline on a fairly arbitary collection of vertices.
+ * For drawing indexed primitives.
  *
  * Vertex headers must be pre-initialized with the
  * UNDEFINED_VERTEX_ID, this code will cause that id to become
@@ -243,6 +255,12 @@ void draw_pipeline_run( struct draw_context *draw,
    draw->pipeline.vertex_count = 0;
 }
 
+
+
+/*
+ * Set up macros for draw_pt_decompose.h template code.
+ * This code is for non-indexed rendering (no elts).
+ */
 #define QUAD(i0,i1,i2,i3)                                        \
    do_triangle( draw,                                            \
                 ( DRAW_PIPE_RESET_STIPPLE |                      \
@@ -293,6 +311,10 @@ void draw_pipeline_run( struct draw_context *draw,
 
 #include "draw_pt_decompose.h"
 
+
+/*
+ * For drawing non-indexed primitives.
+ */
 void draw_pipeline_run_linear( struct draw_context *draw,
                                unsigned prim,
                                struct vertex_header *vertices,
diff --git a/src/gallium/auxiliary/draw/draw_pt.c b/src/gallium/auxiliary/draw/draw_pt.c
index 4865a2d..ae9ee53 100644
--- a/src/gallium/auxiliary/draw/draw_pt.c
+++ b/src/gallium/auxiliary/draw/draw_pt.c
@@ -33,7 +33,6 @@
 #include "draw/draw_context.h"
 #include "draw/draw_private.h"
 #include "draw/draw_pt.h"
-#include "draw/draw_vs.h"
 #include "tgsi/tgsi_dump.h"
 #include "util/u_math.h"
 #include "util/u_prim.h"
diff --git a/src/gallium/auxiliary/draw/draw_pt_fetch.c b/src/gallium/auxiliary/draw/draw_pt_fetch.c
index 65c3a34..2bd88a2 100644
--- a/src/gallium/auxiliary/draw/draw_pt_fetch.c
+++ b/src/gallium/auxiliary/draw/draw_pt_fetch.c
@@ -30,7 +30,6 @@
 #include "draw/draw_context.h"
 #include "draw/draw_private.h"
 #include "draw/draw_vbuf.h"
-#include "draw/draw_vertex.h"
 #include "draw/draw_pt.h"
 #include "translate/translate.h"
 #include "translate/translate_cache.h"
diff --git a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
index 734c05f..c5dfbcf 100644
--- a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
+++ b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
@@ -40,7 +40,6 @@
 #include "draw/draw_pt.h"
 #include "draw/draw_vs.h"
 
-#include "translate/translate.h"
 
 struct fetch_shade_emit;
 
diff --git a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline.c b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline.c
index df6c265..18483ac 100644
--- a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline.c
+++ b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline.c
@@ -32,7 +32,6 @@
 #include "draw/draw_vertex.h"
 #include "draw/draw_pt.h"
 #include "draw/draw_vs.h"
-#include "translate/translate.h"
 
 
 struct fetch_pipeline_middle_end {
diff --git a/src/gallium/auxiliary/draw/draw_pt_post_vs.c b/src/gallium/auxiliary/draw/draw_pt_post_vs.c
index 6c1cb48..360eb86 100644
--- a/src/gallium/auxiliary/draw/draw_pt_post_vs.c
+++ b/src/gallium/auxiliary/draw/draw_pt_post_vs.c
@@ -30,7 +30,6 @@
 #include "draw/draw_context.h"
 #include "draw/draw_private.h"
 #include "draw/draw_vbuf.h"
-#include "draw/draw_vertex.h"
 #include "draw/draw_pt.h"
 
 struct pt_post_vs {
diff --git a/src/gallium/auxiliary/draw/draw_vs_varient.c b/src/gallium/auxiliary/draw/draw_vs_varient.c
index 7ee567d..7ae043f 100644
--- a/src/gallium/auxiliary/draw/draw_vs_varient.c
+++ b/src/gallium/auxiliary/draw/draw_vs_varient.c
@@ -38,7 +38,6 @@
 #include "draw/draw_vertex.h"
 #include "draw/draw_vs.h"
 #include "translate/translate.h"
-#include "translate/translate_cache.h"
 
 /* A first pass at incorporating vertex fetch/emit functionality into 
  */
diff --git a/src/gallium/auxiliary/pipebuffer/Makefile b/src/gallium/auxiliary/pipebuffer/Makefile
index 1c00ba8..21d25d2 100644
--- a/src/gallium/auxiliary/pipebuffer/Makefile
+++ b/src/gallium/auxiliary/pipebuffer/Makefile
@@ -9,7 +9,6 @@ C_SOURCES = \
 	pb_bufmgr_alt.c \
 	pb_bufmgr_cache.c \
 	pb_bufmgr_debug.c \
-	pb_bufmgr_fenced.c \
 	pb_bufmgr_mm.c \
 	pb_bufmgr_ondemand.c \
 	pb_bufmgr_pool.c \
diff --git a/src/gallium/auxiliary/pipebuffer/SConscript b/src/gallium/auxiliary/pipebuffer/SConscript
index 8e9f06a..a074a55 100644
--- a/src/gallium/auxiliary/pipebuffer/SConscript
+++ b/src/gallium/auxiliary/pipebuffer/SConscript
@@ -8,7 +8,6 @@ pipebuffer = env.ConvenienceLibrary(
 		'pb_bufmgr_alt.c',
 		'pb_bufmgr_cache.c',
 		'pb_bufmgr_debug.c',
-		'pb_bufmgr_fenced.c',
 		'pb_bufmgr_mm.c',
 		'pb_bufmgr_ondemand.c',
 		'pb_bufmgr_pool.c',
diff --git a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
index 2ef4293..ba087ac 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
+++ b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
@@ -1,6 +1,6 @@
 /**************************************************************************
  *
- * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * Copyright 2007-2010 VMware, Inc.
  * All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -18,7 +18,7 @@
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@@ -28,9 +28,9 @@
 /**
  * \file
  * Implementation of fenced buffers.
- * 
- * \author Jose Fonseca <jrfonseca-at-tungstengraphics-dot-com>
- * \author Thomas Hellström <thomas-at-tungstengraphics-dot-com>
+ *
+ * \author Jose Fonseca <jfonseca-at-vmware-dot-com>
+ * \author Thomas Hellström <thellstrom-at-vmware-dot-com>
  */
 
 
@@ -50,6 +50,7 @@
 
 #include "pb_buffer.h"
 #include "pb_buffer_fenced.h"
+#include "pb_bufmgr.h"
 
 
 
@@ -59,32 +60,79 @@
 #define SUPER(__derived) (&(__derived)->base)
 
 
-struct fenced_buffer_list
+struct fenced_manager
 {
-   pipe_mutex mutex;
-   
+   struct pb_manager base;
+   struct pb_manager *provider;
    struct pb_fence_ops *ops;
-   
-   pb_size numDelayed;
-   struct list_head delayed;
-   
-#ifdef DEBUG
-   pb_size numUnfenced;
+
+   /**
+    * Maximum buffer size that can be safely allocated.
+    */
+   pb_size max_buffer_size;
+
+   /**
+    * Maximum cpu memory we can allocate before we start waiting for the
+    * GPU to idle.
+    */
+   pb_size max_cpu_total_size;
+
+   /**
+    * Following members are mutable and protected by this mutex.
+    */
+   pipe_mutex mutex;
+
+   /**
+    * Fenced buffer list.
+    *
+    * All fenced buffers are placed in this listed, ordered from the oldest
+    * fence to the newest fence.
+    */
+   struct list_head fenced;
+   pb_size num_fenced;
+
    struct list_head unfenced;
-#endif
+   pb_size num_unfenced;
+
+   /**
+    * How much temporary CPU memory is being used to hold unvalidated buffers.
+    */
+   pb_size cpu_total_size;
 };
 
 
 /**
+ * Fenced buffer.
+ *
  * Wrapper around a pipe buffer which adds fencing and reference counting.
  */
 struct fenced_buffer
 {
+   /*
+    * Immutable members.
+    */
+
    struct pb_buffer base;
-   
+   struct fenced_manager *mgr;
+
+   /*
+    * Following members are mutable and protected by fenced_manager::mutex.
+    */
+
+   struct list_head head;
+
+   /**
+    * Buffer with storage.
+    */
    struct pb_buffer *buffer;
+   pb_size size;
+   struct pb_desc desc;
 
-   /* FIXME: protect access with mutex */
+   /**
+    * Temporary CPU storage data. Used when there isn't enough GPU memory to
+    * store the buffer.
+    */
+   void *data;
 
    /**
     * A bitmask of PIPE_BUFFER_USAGE_CPU/GPU_READ/WRITE describing the current
@@ -93,15 +141,22 @@ struct fenced_buffer
    unsigned flags;
 
    unsigned mapcount;
+
    struct pb_validate *vl;
    unsigned validation_flags;
-   struct pipe_fence_handle *fence;
 
-   struct list_head head;
-   struct fenced_buffer_list *list;
+   struct pipe_fence_handle *fence;
 };
 
 
+static INLINE struct fenced_manager *
+fenced_manager(struct pb_manager *mgr)
+{
+   assert(mgr);
+   return (struct fenced_manager *)mgr;
+}
+
+
 static INLINE struct fenced_buffer *
 fenced_buffer(struct pb_buffer *buf)
 {
@@ -110,220 +165,568 @@ fenced_buffer(struct pb_buffer *buf)
 }
 
 
-static INLINE void
-_fenced_buffer_add(struct fenced_buffer *fenced_buf)
-{
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
+static void
+fenced_buffer_destroy_cpu_storage_locked(struct fenced_buffer *fenced_buf);
 
-   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
-   assert(fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE);
-   assert(fenced_buf->fence);
+static enum pipe_error
+fenced_buffer_create_cpu_storage_locked(struct fenced_manager *fenced_mgr,
+                                        struct fenced_buffer *fenced_buf);
 
+static void
+fenced_buffer_destroy_gpu_storage_locked(struct fenced_buffer *fenced_buf);
+
+static enum pipe_error
+fenced_buffer_create_gpu_storage_locked(struct fenced_manager *fenced_mgr,
+                                        struct fenced_buffer *fenced_buf,
+                                        boolean wait);
+
+static enum pipe_error
+fenced_buffer_copy_storage_to_gpu_locked(struct fenced_buffer *fenced_buf);
+
+static enum pipe_error
+fenced_buffer_copy_storage_to_cpu_locked(struct fenced_buffer *fenced_buf);
+
+
+/**
+ * Dump the fenced buffer list.
+ *
+ * Useful to understand failures to allocate buffers.
+ */
+static void
+fenced_manager_dump_locked(struct fenced_manager *fenced_mgr)
+{
 #ifdef DEBUG
-   LIST_DEL(&fenced_buf->head);
-   assert(fenced_list->numUnfenced);
-   --fenced_list->numUnfenced;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
+   struct list_head *curr, *next;
+   struct fenced_buffer *fenced_buf;
+
+   debug_printf("%10s %7s %8s %7s %10s %s\n",
+                "buffer", "size", "refcount", "storage", "fence", "signalled");
+
+   curr = fenced_mgr->unfenced.next;
+   next = curr->next;
+   while(curr != &fenced_mgr->unfenced) {
+      fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
+      assert(!fenced_buf->fence);
+      debug_printf("%10p %7u %8u %7s\n",
+                   (void *) fenced_buf,
+                   fenced_buf->base.base.size,
+                   p_atomic_read(&fenced_buf->base.base.reference.count),
+                   fenced_buf->buffer ? "gpu" : (fenced_buf->data ? "cpu" : "none"));
+      curr = next;
+      next = curr->next;
+   }
+
+   curr = fenced_mgr->fenced.next;
+   next = curr->next;
+   while(curr != &fenced_mgr->fenced) {
+      int signaled;
+      fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
+      assert(fenced_buf->buffer);
+      signaled = ops->fence_signalled(ops, fenced_buf->fence, 0);
+      debug_printf("%10p %7u %8u %7s %10p %s\n",
+                   (void *) fenced_buf,
+                   fenced_buf->base.base.size,
+                   p_atomic_read(&fenced_buf->base.base.reference.count),
+                   "gpu",
+                   (void *) fenced_buf->fence,
+                   signaled == 0 ? "y" : "n");
+      curr = next;
+      next = curr->next;
+   }
+#else
+   (void)fenced_mgr;
 #endif
-   LIST_ADDTAIL(&fenced_buf->head, &fenced_list->delayed);
-   ++fenced_list->numDelayed;
 }
 
 
-/**
- * Actually destroy the buffer.
- */
 static INLINE void
-_fenced_buffer_destroy(struct fenced_buffer *fenced_buf)
+fenced_buffer_destroy_locked(struct fenced_manager *fenced_mgr,
+                             struct fenced_buffer *fenced_buf)
 {
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
-   
    assert(!pipe_is_referenced(&fenced_buf->base.base.reference));
+
    assert(!fenced_buf->fence);
-#ifdef DEBUG
    assert(fenced_buf->head.prev);
    assert(fenced_buf->head.next);
    LIST_DEL(&fenced_buf->head);
-   assert(fenced_list->numUnfenced);
-   --fenced_list->numUnfenced;
-#else
-   (void)fenced_list;
-#endif
-   pb_reference(&fenced_buf->buffer, NULL);
+   assert(fenced_mgr->num_unfenced);
+   --fenced_mgr->num_unfenced;
+
+   fenced_buffer_destroy_gpu_storage_locked(fenced_buf);
+   fenced_buffer_destroy_cpu_storage_locked(fenced_buf);
+
    FREE(fenced_buf);
 }
 
 
+/**
+ * Add the buffer to the fenced list.
+ *
+ * Reference count should be incremented before calling this function.
+ */
 static INLINE void
-_fenced_buffer_remove(struct fenced_buffer_list *fenced_list,
-                      struct fenced_buffer *fenced_buf)
+fenced_buffer_add_locked(struct fenced_manager *fenced_mgr,
+                         struct fenced_buffer *fenced_buf)
+{
+   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+   assert(fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE);
+   assert(fenced_buf->fence);
+
+   p_atomic_inc(&fenced_buf->base.base.reference.count);
+
+   LIST_DEL(&fenced_buf->head);
+   assert(fenced_mgr->num_unfenced);
+   --fenced_mgr->num_unfenced;
+   LIST_ADDTAIL(&fenced_buf->head, &fenced_mgr->fenced);
+   ++fenced_mgr->num_fenced;
+}
+
+
+/**
+ * Remove the buffer from the fenced list, and potentially destroy the buffer
+ * if the reference count reaches zero.
+ *
+ * Returns TRUE if the buffer was detroyed.
+ */
+static INLINE boolean
+fenced_buffer_remove_locked(struct fenced_manager *fenced_mgr,
+                            struct fenced_buffer *fenced_buf)
 {
-   struct pb_fence_ops *ops = fenced_list->ops;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
 
    assert(fenced_buf->fence);
-   assert(fenced_buf->list == fenced_list);
-   
+   assert(fenced_buf->mgr == fenced_mgr);
+
    ops->fence_reference(ops, &fenced_buf->fence, NULL);
    fenced_buf->flags &= ~PIPE_BUFFER_USAGE_GPU_READ_WRITE;
-   
+
    assert(fenced_buf->head.prev);
    assert(fenced_buf->head.next);
-   
+
    LIST_DEL(&fenced_buf->head);
-   assert(fenced_list->numDelayed);
-   --fenced_list->numDelayed;
-   
-#ifdef DEBUG
-   LIST_ADDTAIL(&fenced_buf->head, &fenced_list->unfenced);
-   ++fenced_list->numUnfenced;
-#endif
-   
-   /**
-    * FIXME!!!
-    */
+   assert(fenced_mgr->num_fenced);
+   --fenced_mgr->num_fenced;
+
+   LIST_ADDTAIL(&fenced_buf->head, &fenced_mgr->unfenced);
+   ++fenced_mgr->num_unfenced;
+
+   if (p_atomic_dec_zero(&fenced_buf->base.base.reference.count)) {
+      fenced_buffer_destroy_locked(fenced_mgr, fenced_buf);
+      return TRUE;
+   }
 
-   if(!pipe_is_referenced(&fenced_buf->base.base.reference))
-      _fenced_buffer_destroy(fenced_buf);
+   return FALSE;
 }
 
 
+/**
+ * Wait for the fence to expire, and remove it from the fenced list.
+ *
+ * This function will release and re-aquire the mutex, so any copy of mutable
+ * state must be discarded after calling it.
+ */
 static INLINE enum pipe_error
-_fenced_buffer_finish(struct fenced_buffer *fenced_buf)
+fenced_buffer_finish_locked(struct fenced_manager *fenced_mgr,
+                            struct fenced_buffer *fenced_buf)
 {
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
-   struct pb_fence_ops *ops = fenced_list->ops;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
+   enum pipe_error ret = PIPE_ERROR;
 
 #if 0
    debug_warning("waiting for GPU");
 #endif
 
+   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
    assert(fenced_buf->fence);
+
    if(fenced_buf->fence) {
-      if(ops->fence_finish(ops, fenced_buf->fence, 0) != 0) {
-	 return PIPE_ERROR;
+      struct pipe_fence_handle *fence = NULL;
+      int finished;
+      boolean proceed;
+
+      ops->fence_reference(ops, &fence, fenced_buf->fence);
+
+      pipe_mutex_unlock(fenced_mgr->mutex);
+
+      finished = ops->fence_finish(ops, fenced_buf->fence, 0);
+
+      pipe_mutex_lock(fenced_mgr->mutex);
+
+      assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+
+      /*
+       * Only proceed if the fence object didn't change in the meanwhile.
+       * Otherwise assume the work has been already carried out by another
+       * thread that re-aquired the lock before us.
+       */
+      proceed = fence == fenced_buf->fence ? TRUE : FALSE;
+
+      ops->fence_reference(ops, &fence, NULL);
+
+      if(proceed && finished == 0) {
+         /*
+          * Remove from the fenced list
+          */
+
+         boolean destroyed;
+
+         destroyed = fenced_buffer_remove_locked(fenced_mgr, fenced_buf);
+
+         /* TODO: remove consequents buffers with the same fence? */
+
+         assert(!destroyed);
+
+         fenced_buf->flags &= ~PIPE_BUFFER_USAGE_GPU_READ_WRITE;
+
+         ret = PIPE_OK;
       }
-      /* Remove from the fenced list */
-      /* TODO: remove consequents */
-      _fenced_buffer_remove(fenced_list, fenced_buf);
    }
 
-   fenced_buf->flags &= ~PIPE_BUFFER_USAGE_GPU_READ_WRITE;
-   return PIPE_OK;
+   return ret;
 }
 
 
 /**
- * Free as many fenced buffers from the list head as possible. 
+ * Remove as many fenced buffers from the fenced list as possible.
+ *
+ * Returns TRUE if at least one buffer was removed.
  */
-static void
-_fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list, 
-                               int wait)
+static boolean
+fenced_manager_check_signalled_locked(struct fenced_manager *fenced_mgr,
+                                      boolean wait)
 {
-   struct pb_fence_ops *ops = fenced_list->ops;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
    struct list_head *curr, *next;
    struct fenced_buffer *fenced_buf;
    struct pipe_fence_handle *prev_fence = NULL;
+   boolean ret = FALSE;
 
-   curr = fenced_list->delayed.next;
+   curr = fenced_mgr->fenced.next;
    next = curr->next;
-   while(curr != &fenced_list->delayed) {
+   while(curr != &fenced_mgr->fenced) {
       fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
 
       if(fenced_buf->fence != prev_fence) {
 	 int signaled;
-	 if (wait)
+
+	 if (wait) {
 	    signaled = ops->fence_finish(ops, fenced_buf->fence, 0);
-	 else
+
+	    /*
+	     * Don't return just now. Instead preemptively check if the
+	     * following buffers' fences already expired, without further waits.
+	     */
+	    wait = FALSE;
+	 }
+	 else {
 	    signaled = ops->fence_signalled(ops, fenced_buf->fence, 0);
-	 if (signaled != 0)
-	    break;
+	 }
+
+	 if (signaled != 0) {
+	    return ret;
+         }
+
 	 prev_fence = fenced_buf->fence;
       }
       else {
+         /* This buffer's fence object is identical to the previous buffer's
+          * fence object, so no need to check the fence again.
+          */
 	 assert(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0);
       }
 
-      _fenced_buffer_remove(fenced_list, fenced_buf);
+      fenced_buffer_remove_locked(fenced_mgr, fenced_buf);
+
+      ret = TRUE;
+
+      curr = next;
+      next = curr->next;
+   }
+
+   return ret;
+}
+
+
+/**
+ * Try to free some GPU memory by backing it up into CPU memory.
+ *
+ * Returns TRUE if at least one buffer was freed.
+ */
+static boolean
+fenced_manager_free_gpu_storage_locked(struct fenced_manager *fenced_mgr)
+{
+   struct list_head *curr, *next;
+   struct fenced_buffer *fenced_buf;
 
-      curr = next; 
+   curr = fenced_mgr->unfenced.next;
+   next = curr->next;
+   while(curr != &fenced_mgr->unfenced) {
+      fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
+
+      /*
+       * We can only move storage if the buffer is not mapped and not
+       * validated.
+       */
+      if(fenced_buf->buffer &&
+         !fenced_buf->mapcount &&
+         !fenced_buf->vl) {
+         enum pipe_error ret;
+
+         ret = fenced_buffer_create_cpu_storage_locked(fenced_mgr, fenced_buf);
+         if(ret == PIPE_OK) {
+            ret = fenced_buffer_copy_storage_to_cpu_locked(fenced_buf);
+            if(ret == PIPE_OK) {
+               fenced_buffer_destroy_gpu_storage_locked(fenced_buf);
+               return TRUE;
+            }
+            fenced_buffer_destroy_cpu_storage_locked(fenced_buf);
+         }
+      }
+
+      curr = next;
       next = curr->next;
    }
+
+   return FALSE;
 }
 
 
+/**
+ * Destroy CPU storage for this buffer.
+ */
 static void
-fenced_buffer_destroy(struct pb_buffer *buf)
+fenced_buffer_destroy_cpu_storage_locked(struct fenced_buffer *fenced_buf)
 {
-   struct fenced_buffer *fenced_buf = fenced_buffer(buf);   
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
+   if(fenced_buf->data) {
+      align_free(fenced_buf->data);
+      fenced_buf->data = NULL;
+      assert(fenced_buf->mgr->cpu_total_size >= fenced_buf->size);
+      fenced_buf->mgr->cpu_total_size -= fenced_buf->size;
+   }
+}
 
-   pipe_mutex_lock(fenced_list->mutex);
-   assert(!pipe_is_referenced(&fenced_buf->base.base.reference));
-   if (fenced_buf->fence) {
-      struct pb_fence_ops *ops = fenced_list->ops;
-      if(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0) {
-	 struct list_head *curr, *prev;
-	 curr = &fenced_buf->head;
-	 prev = curr->prev;
-	 do {
-	    fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
-	    assert(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0);
-	    _fenced_buffer_remove(fenced_list, fenced_buf);
-	    curr = prev;
-	    prev = curr->prev;
-	 } while (curr != &fenced_list->delayed);
-      }	  
-      else {
-	 /* delay destruction */
+
+/**
+ * Create CPU storage for this buffer.
+ */
+static enum pipe_error
+fenced_buffer_create_cpu_storage_locked(struct fenced_manager *fenced_mgr,
+                                        struct fenced_buffer *fenced_buf)
+{
+   assert(!fenced_buf->data);
+   if(fenced_buf->data)
+      return PIPE_OK;
+
+   if (fenced_mgr->cpu_total_size + fenced_buf->size > fenced_mgr->max_cpu_total_size)
+      return PIPE_ERROR_OUT_OF_MEMORY;
+
+   fenced_buf->data = align_malloc(fenced_buf->size, fenced_buf->desc.alignment);
+   if(!fenced_buf->data)
+      return PIPE_ERROR_OUT_OF_MEMORY;
+
+   fenced_mgr->cpu_total_size += fenced_buf->size;
+
+   return PIPE_OK;
+}
+
+
+/**
+ * Destroy the GPU storage.
+ */
+static void
+fenced_buffer_destroy_gpu_storage_locked(struct fenced_buffer *fenced_buf)
+{
+   if(fenced_buf->buffer) {
+      pb_reference(&fenced_buf->buffer, NULL);
+   }
+}
+
+
+/**
+ * Try to create GPU storage for this buffer.
+ *
+ * This function is a shorthand around pb_manager::create_buffer for
+ * fenced_buffer_create_gpu_storage_locked()'s benefit.
+ */
+static INLINE boolean
+fenced_buffer_try_create_gpu_storage_locked(struct fenced_manager *fenced_mgr,
+                                            struct fenced_buffer *fenced_buf)
+{
+   struct pb_manager *provider = fenced_mgr->provider;
+
+   assert(!fenced_buf->buffer);
+
+   fenced_buf->buffer = provider->create_buffer(fenced_mgr->provider,
+                                                fenced_buf->size,
+                                                &fenced_buf->desc);
+   return fenced_buf->buffer ? TRUE : FALSE;
+}
+
+
+/**
+ * Create GPU storage for this buffer.
+ */
+static enum pipe_error
+fenced_buffer_create_gpu_storage_locked(struct fenced_manager *fenced_mgr,
+                                        struct fenced_buffer *fenced_buf,
+                                        boolean wait)
+{
+   assert(!fenced_buf->buffer);
+
+   /*
+    * Check for signaled buffers before trying to allocate.
+    */
+   fenced_manager_check_signalled_locked(fenced_mgr, FALSE);
+
+   fenced_buffer_try_create_gpu_storage_locked(fenced_mgr, fenced_buf);
+
+   /*
+    * Keep trying while there is some sort of progress:
+    * - fences are expiring,
+    * - or buffers are being being swapped out from GPU memory into CPU memory.
+    */
+   while(!fenced_buf->buffer &&
+         (fenced_manager_check_signalled_locked(fenced_mgr, FALSE) ||
+          fenced_manager_free_gpu_storage_locked(fenced_mgr))) {
+      fenced_buffer_try_create_gpu_storage_locked(fenced_mgr, fenced_buf);
+   }
+
+   if(!fenced_buf->buffer && wait) {
+      /*
+       * Same as before, but this time around, wait to free buffers if
+       * necessary.
+       */
+      while(!fenced_buf->buffer &&
+            (fenced_manager_check_signalled_locked(fenced_mgr, TRUE) ||
+             fenced_manager_free_gpu_storage_locked(fenced_mgr))) {
+         fenced_buffer_try_create_gpu_storage_locked(fenced_mgr, fenced_buf);
       }
    }
-   else {
-      _fenced_buffer_destroy(fenced_buf);
+
+   if(!fenced_buf->buffer) {
+      if(0)
+         fenced_manager_dump_locked(fenced_mgr);
+
+      /* give up */
+      return PIPE_ERROR_OUT_OF_MEMORY;
    }
-   pipe_mutex_unlock(fenced_list->mutex);
+
+   return PIPE_OK;
+}
+
+
+static enum pipe_error
+fenced_buffer_copy_storage_to_gpu_locked(struct fenced_buffer *fenced_buf)
+{
+   uint8_t *map;
+
+   assert(fenced_buf->data);
+   assert(fenced_buf->buffer);
+
+   map = pb_map(fenced_buf->buffer, PIPE_BUFFER_USAGE_CPU_WRITE);
+   if(!map)
+      return PIPE_ERROR;
+
+   memcpy(map, fenced_buf->data, fenced_buf->size);
+
+   pb_unmap(fenced_buf->buffer);
+
+   return PIPE_OK;
+}
+
+
+static enum pipe_error
+fenced_buffer_copy_storage_to_cpu_locked(struct fenced_buffer *fenced_buf)
+{
+   const uint8_t *map;
+
+   assert(fenced_buf->data);
+   assert(fenced_buf->buffer);
+
+   map = pb_map(fenced_buf->buffer, PIPE_BUFFER_USAGE_CPU_READ);
+   if(!map)
+      return PIPE_ERROR;
+
+   memcpy(fenced_buf->data, map, fenced_buf->size);
+
+   pb_unmap(fenced_buf->buffer);
+
+   return PIPE_OK;
+}
+
+
+static void
+fenced_buffer_destroy(struct pb_buffer *buf)
+{
+   struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
+
+   assert(!pipe_is_referenced(&fenced_buf->base.base.reference));
+
+   pipe_mutex_lock(fenced_mgr->mutex);
+
+   fenced_buffer_destroy_locked(fenced_mgr, fenced_buf);
+
+   pipe_mutex_unlock(fenced_mgr->mutex);
 }
 
 
 static void *
-fenced_buffer_map(struct pb_buffer *buf, 
+fenced_buffer_map(struct pb_buffer *buf,
                   unsigned flags)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
-   struct fenced_buffer_list *fenced_list = fenced_buf->list;
-   struct pb_fence_ops *ops = fenced_list->ops;
-   void *map;
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
+   void *map = NULL;
+
+   pipe_mutex_lock(fenced_mgr->mutex);
 
    assert(!(flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE));
-   
-   /* Serialize writes */
-   if((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_WRITE) ||
-      ((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ) && (flags & PIPE_BUFFER_USAGE_CPU_WRITE))) {
-      if(flags & PIPE_BUFFER_USAGE_DONTBLOCK) {
-         /* Don't wait for the GPU to finish writing */
-         if(ops->fence_signalled(ops, fenced_buf->fence, 0) == 0)
-            _fenced_buffer_remove(fenced_list, fenced_buf);
-         else
-            return NULL;
+
+   /*
+    * Serialize writes.
+    */
+   while((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_WRITE) ||
+         ((fenced_buf->flags & PIPE_BUFFER_USAGE_GPU_READ) &&
+          (flags & PIPE_BUFFER_USAGE_CPU_WRITE))) {
+
+      /* 
+       * Don't wait for the GPU to finish accessing it, if blocking is forbidden.
+       */
+      if((flags & PIPE_BUFFER_USAGE_DONTBLOCK) &&
+          ops->fence_signalled(ops, fenced_buf->fence, 0) == 0) {
+         goto done;
       }
-      else {
-         /* Wait for the GPU to finish writing */
-         _fenced_buffer_finish(fenced_buf);
+
+      if (flags & PIPE_BUFFER_USAGE_UNSYNCHRONIZED) {
+         break;
       }
+
+      /*
+       * Wait for the GPU to finish accessing. This will release and re-acquire
+       * the mutex, so all copies of mutable state must be discarded.
+       */
+      fenced_buffer_finish_locked(fenced_mgr, fenced_buf);
    }
 
-#if 0
-   /* Check for CPU write access (read is OK) */
-   if(fenced_buf->flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE) {
-      /* this is legal -- just for debugging */
-      debug_warning("concurrent CPU writes");
+   if(fenced_buf->buffer) {
+      map = pb_map(fenced_buf->buffer, flags);
    }
-#endif
-   
-   map = pb_map(fenced_buf->buffer, flags);
+   else {
+      assert(fenced_buf->data);
+      map = fenced_buf->data;
+   }
+
    if(map) {
       ++fenced_buf->mapcount;
       fenced_buf->flags |= flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE;
    }
 
+done:
+   pipe_mutex_unlock(fenced_mgr->mutex);
+
    return map;
 }
 
@@ -332,13 +735,20 @@ static void
 fenced_buffer_unmap(struct pb_buffer *buf)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
+
+   pipe_mutex_lock(fenced_mgr->mutex);
+
    assert(fenced_buf->mapcount);
    if(fenced_buf->mapcount) {
-      pb_unmap(fenced_buf->buffer);
+      if (fenced_buf->buffer)
+         pb_unmap(fenced_buf->buffer);
       --fenced_buf->mapcount;
       if(!fenced_buf->mapcount)
 	 fenced_buf->flags &= ~PIPE_BUFFER_USAGE_CPU_READ_WRITE;
    }
+
+   pipe_mutex_unlock(fenced_mgr->mutex);
 }
 
 
@@ -348,48 +758,72 @@ fenced_buffer_validate(struct pb_buffer *buf,
                        unsigned flags)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
    enum pipe_error ret;
-   
+
+   pipe_mutex_lock(fenced_mgr->mutex);
+
    if(!vl) {
       /* invalidate */
       fenced_buf->vl = NULL;
       fenced_buf->validation_flags = 0;
-      return PIPE_OK;
+      ret = PIPE_OK;
+      goto done;
    }
-   
+
    assert(flags & PIPE_BUFFER_USAGE_GPU_READ_WRITE);
    assert(!(flags & ~PIPE_BUFFER_USAGE_GPU_READ_WRITE));
    flags &= PIPE_BUFFER_USAGE_GPU_READ_WRITE;
 
-   /* Buffer cannot be validated in two different lists */ 
-   if(fenced_buf->vl && fenced_buf->vl != vl)
-      return PIPE_ERROR_RETRY;
-   
-#if 0
-   /* Do not validate if buffer is still mapped */
-   if(fenced_buf->flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE) {
-      /* TODO: wait for the thread that mapped the buffer to unmap it */
-      return PIPE_ERROR_RETRY;
+   /* Buffer cannot be validated in two different lists */
+   if(fenced_buf->vl && fenced_buf->vl != vl) {
+      ret = PIPE_ERROR_RETRY;
+      goto done;
    }
-   /* Final sanity checking */
-   assert(!(fenced_buf->flags & PIPE_BUFFER_USAGE_CPU_READ_WRITE));
-   assert(!fenced_buf->mapcount);
-#endif
 
    if(fenced_buf->vl == vl &&
       (fenced_buf->validation_flags & flags) == flags) {
       /* Nothing to do -- buffer already validated */
-      return PIPE_OK;
+      ret = PIPE_OK;
+      goto done;
+   }
+
+   /*
+    * Create and update GPU storage.
+    */
+   if(!fenced_buf->buffer) {
+      assert(!fenced_buf->mapcount);
+
+      ret = fenced_buffer_create_gpu_storage_locked(fenced_mgr, fenced_buf, TRUE);
+      if(ret != PIPE_OK) {
+         goto done;
+      }
+
+      ret = fenced_buffer_copy_storage_to_gpu_locked(fenced_buf);
+      if(ret != PIPE_OK) {
+         fenced_buffer_destroy_gpu_storage_locked(fenced_buf);
+         goto done;
+      }
+
+      if(fenced_buf->mapcount) {
+         debug_printf("warning: validating a buffer while it is still mapped\n");
+      }
+      else {
+         fenced_buffer_destroy_cpu_storage_locked(fenced_buf);
+      }
    }
-   
+
    ret = pb_validate(fenced_buf->buffer, vl, flags);
    if (ret != PIPE_OK)
-      return ret;
-   
+      goto done;
+
    fenced_buf->vl = vl;
    fenced_buf->validation_flags |= flags;
-   
-   return PIPE_OK;
+
+done:
+   pipe_mutex_unlock(fenced_mgr->mutex);
+
+   return ret;
 }
 
 
@@ -397,36 +831,37 @@ static void
 fenced_buffer_fence(struct pb_buffer *buf,
                     struct pipe_fence_handle *fence)
 {
-   struct fenced_buffer *fenced_buf;
-   struct fenced_buffer_list *fenced_list;
-   struct pb_fence_ops *ops;
+   struct fenced_buffer *fenced_buf = fenced_buffer(buf);
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
+   struct pb_fence_ops *ops = fenced_mgr->ops;
 
-   fenced_buf = fenced_buffer(buf);
-   fenced_list = fenced_buf->list;
-   ops = fenced_list->ops;
-   
-   if(fence == fenced_buf->fence) {
-      /* Nothing to do */
-      return;
-   }
+   pipe_mutex_lock(fenced_mgr->mutex);
 
-   assert(fenced_buf->vl);
-   assert(fenced_buf->validation_flags);
-   
-   pipe_mutex_lock(fenced_list->mutex);
-   if (fenced_buf->fence)
-      _fenced_buffer_remove(fenced_list, fenced_buf);
-   if (fence) {
-      ops->fence_reference(ops, &fenced_buf->fence, fence);
-      fenced_buf->flags |= fenced_buf->validation_flags;
-      _fenced_buffer_add(fenced_buf);
+   assert(pipe_is_referenced(&fenced_buf->base.base.reference));
+   assert(fenced_buf->buffer);
+
+   if(fence != fenced_buf->fence) {
+      assert(fenced_buf->vl);
+      assert(fenced_buf->validation_flags);
+
+      if (fenced_buf->fence) {
+         boolean destroyed;
+         destroyed = fenced_buffer_remove_locked(fenced_mgr, fenced_buf);
+         assert(!destroyed);
+      }
+      if (fence) {
+         ops->fence_reference(ops, &fenced_buf->fence, fence);
+         fenced_buf->flags |= fenced_buf->validation_flags;
+         fenced_buffer_add_locked(fenced_mgr, fenced_buf);
+      }
+
+      pb_fence(fenced_buf->buffer, fence);
+
+      fenced_buf->vl = NULL;
+      fenced_buf->validation_flags = 0;
    }
-   pipe_mutex_unlock(fenced_list->mutex);
-   
-   pb_fence(fenced_buf->buffer, fence);
 
-   fenced_buf->vl = NULL;
-   fenced_buf->validation_flags = 0;
+   pipe_mutex_unlock(fenced_mgr->mutex);
 }
 
 
@@ -436,11 +871,29 @@ fenced_buffer_get_base_buffer(struct pb_buffer *buf,
                               pb_size *offset)
 {
    struct fenced_buffer *fenced_buf = fenced_buffer(buf);
-   pb_get_base_buffer(fenced_buf->buffer, base_buf, offset);
+   struct fenced_manager *fenced_mgr = fenced_buf->mgr;
+
+   pipe_mutex_lock(fenced_mgr->mutex);
+
+   /*
+    * This should only be called when the buffer is validated. Typically
+    * when processing relocations.
+    */
+   assert(fenced_buf->vl);
+   assert(fenced_buf->buffer);
+
+   if(fenced_buf->buffer)
+      pb_get_base_buffer(fenced_buf->buffer, base_buf, offset);
+   else {
+      *base_buf = buf;
+      *offset = 0;
+   }
+
+   pipe_mutex_unlock(fenced_mgr->mutex);
 }
 
 
-static const struct pb_vtbl 
+static const struct pb_vtbl
 fenced_buffer_vtbl = {
       fenced_buffer_destroy,
       fenced_buffer_map,
@@ -451,147 +904,166 @@ fenced_buffer_vtbl = {
 };
 
 
-struct pb_buffer *
-fenced_buffer_create(struct fenced_buffer_list *fenced_list, 
-                     struct pb_buffer *buffer)
+/**
+ * Wrap a buffer in a fenced buffer.
+ */
+static struct pb_buffer *
+fenced_bufmgr_create_buffer(struct pb_manager *mgr,
+                            pb_size size,
+                            const struct pb_desc *desc)
 {
-   struct fenced_buffer *buf;
-   
-   if(!buffer)
-      return NULL;
-   
-   buf = CALLOC_STRUCT(fenced_buffer);
-   if(!buf) {
-      pb_reference(&buffer, NULL);
-      return NULL;
+   struct fenced_manager *fenced_mgr = fenced_manager(mgr);
+   struct fenced_buffer *fenced_buf;
+   enum pipe_error ret;
+
+   /*
+    * Don't stall the GPU, waste time evicting buffers, or waste memory
+    * trying to create a buffer that will most likely never fit into the
+    * graphics aperture.
+    */
+   if(size > fenced_mgr->max_buffer_size) {
+      goto no_buffer;
    }
-   
-   pipe_reference_init(&buf->base.base.reference, 1);
-   buf->base.base.alignment = buffer->base.alignment;
-   buf->base.base.usage = buffer->base.usage;
-   buf->base.base.size = buffer->base.size;
-   
-   buf->base.vtbl = &fenced_buffer_vtbl;
-   buf->buffer = buffer;
-   buf->list = fenced_list;
-   
-#ifdef DEBUG
-   pipe_mutex_lock(fenced_list->mutex);
-   LIST_ADDTAIL(&buf->head, &fenced_list->unfenced);
-   ++fenced_list->numUnfenced;
-   pipe_mutex_unlock(fenced_list->mutex);
-#endif
 
-   return &buf->base;
-}
+   fenced_buf = CALLOC_STRUCT(fenced_buffer);
+   if(!fenced_buf)
+      goto no_buffer;
 
+   pipe_reference_init(&fenced_buf->base.base.reference, 1);
+   fenced_buf->base.base.alignment = desc->alignment;
+   fenced_buf->base.base.usage = desc->usage;
+   fenced_buf->base.base.size = size;
+   fenced_buf->size = size;
+   fenced_buf->desc = *desc;
 
-struct fenced_buffer_list *
-fenced_buffer_list_create(struct pb_fence_ops *ops) 
-{
-   struct fenced_buffer_list *fenced_list;
+   fenced_buf->base.vtbl = &fenced_buffer_vtbl;
+   fenced_buf->mgr = fenced_mgr;
 
-   fenced_list = CALLOC_STRUCT(fenced_buffer_list);
-   if (!fenced_list)
-      return NULL;
+   pipe_mutex_lock(fenced_mgr->mutex);
+
+   /*
+    * Try to create GPU storage without stalling,
+    */
+   ret = fenced_buffer_create_gpu_storage_locked(fenced_mgr, fenced_buf, FALSE);
 
-   fenced_list->ops = ops;
+   /*
+    * Attempt to use CPU memory to avoid stalling the GPU.
+    */
+   if(ret != PIPE_OK) {
+      ret = fenced_buffer_create_cpu_storage_locked(fenced_mgr, fenced_buf);
+   }
 
-   LIST_INITHEAD(&fenced_list->delayed);
-   fenced_list->numDelayed = 0;
-   
-#ifdef DEBUG
-   LIST_INITHEAD(&fenced_list->unfenced);
-   fenced_list->numUnfenced = 0;
-#endif
+   /*
+    * Create GPU storage, waiting for some to be available.
+    */
+   if(ret != PIPE_OK) {
+      ret = fenced_buffer_create_gpu_storage_locked(fenced_mgr, fenced_buf, TRUE);
+   }
+
+   /*
+    * Give up.
+    */
+   if(ret != PIPE_OK) {
+      goto no_storage;
+   }
 
-   pipe_mutex_init(fenced_list->mutex);
+   assert(fenced_buf->buffer || fenced_buf->data);
 
-   return fenced_list;
-}
+   LIST_ADDTAIL(&fenced_buf->head, &fenced_mgr->unfenced);
+   ++fenced_mgr->num_unfenced;
+   pipe_mutex_unlock(fenced_mgr->mutex);
 
+   return &fenced_buf->base;
 
-void
-fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list, 
-                              int wait)
-{
-   pipe_mutex_lock(fenced_list->mutex);
-   _fenced_buffer_list_check_free(fenced_list, wait);
-   pipe_mutex_unlock(fenced_list->mutex);
+no_storage:
+   pipe_mutex_unlock(fenced_mgr->mutex);
+   FREE(fenced_buf);
+no_buffer:
+   return NULL;
 }
 
 
-#ifdef DEBUG
-void
-fenced_buffer_list_dump(struct fenced_buffer_list *fenced_list)
+static void
+fenced_bufmgr_flush(struct pb_manager *mgr)
 {
-   struct pb_fence_ops *ops = fenced_list->ops;
-   struct list_head *curr, *next;
-   struct fenced_buffer *fenced_buf;
+   struct fenced_manager *fenced_mgr = fenced_manager(mgr);
 
-   pipe_mutex_lock(fenced_list->mutex);
+   pipe_mutex_lock(fenced_mgr->mutex);
+   while(fenced_manager_check_signalled_locked(fenced_mgr, TRUE))
+      ;
+   pipe_mutex_unlock(fenced_mgr->mutex);
 
-   debug_printf("%10s %7s %7s %10s %s\n",
-                "buffer", "size", "refcount", "fence", "signalled");
-   
-   curr = fenced_list->unfenced.next;
-   next = curr->next;
-   while(curr != &fenced_list->unfenced) {
-      fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
-      assert(!fenced_buf->fence);
-      debug_printf("%10p %7u %7u\n",
-                   (void *) fenced_buf,
-                   fenced_buf->base.base.size,
-                   p_atomic_read(&fenced_buf->base.base.reference.count));
-      curr = next; 
-      next = curr->next;
-   }
-   
-   curr = fenced_list->delayed.next;
-   next = curr->next;
-   while(curr != &fenced_list->delayed) {
-      int signaled;
-      fenced_buf = LIST_ENTRY(struct fenced_buffer, curr, head);
-      signaled = ops->fence_signalled(ops, fenced_buf->fence, 0);
-      debug_printf("%10p %7u %7u %10p %s\n",
-                   (void *) fenced_buf,
-                   fenced_buf->base.base.size,
-                   p_atomic_read(&fenced_buf->base.base.reference.count),
-                   (void *) fenced_buf->fence,
-                   signaled == 0 ? "y" : "n");
-      curr = next; 
-      next = curr->next;
-   }
-   
-   pipe_mutex_unlock(fenced_list->mutex);
+   assert(fenced_mgr->provider->flush);
+   if(fenced_mgr->provider->flush)
+      fenced_mgr->provider->flush(fenced_mgr->provider);
 }
-#endif
 
 
-void
-fenced_buffer_list_destroy(struct fenced_buffer_list *fenced_list)
+static void
+fenced_bufmgr_destroy(struct pb_manager *mgr)
 {
-   pipe_mutex_lock(fenced_list->mutex);
+   struct fenced_manager *fenced_mgr = fenced_manager(mgr);
+
+   pipe_mutex_lock(fenced_mgr->mutex);
 
    /* Wait on outstanding fences */
-   while (fenced_list->numDelayed) {
-      pipe_mutex_unlock(fenced_list->mutex);
+   while (fenced_mgr->num_fenced) {
+      pipe_mutex_unlock(fenced_mgr->mutex);
 #if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
       sched_yield();
 #endif
-      _fenced_buffer_list_check_free(fenced_list, 1);
-      pipe_mutex_lock(fenced_list->mutex);
+      pipe_mutex_lock(fenced_mgr->mutex);
+      while(fenced_manager_check_signalled_locked(fenced_mgr, TRUE))
+         ;
    }
 
 #ifdef DEBUG
-   /*assert(!fenced_list->numUnfenced);*/
+   /*assert(!fenced_mgr->num_unfenced);*/
 #endif
-      
-   pipe_mutex_unlock(fenced_list->mutex);
-   
-   fenced_list->ops->destroy(fenced_list->ops);
-   
-   FREE(fenced_list);
+
+   pipe_mutex_unlock(fenced_mgr->mutex);
+   pipe_mutex_destroy(fenced_mgr->mutex);
+
+   if(fenced_mgr->provider)
+      fenced_mgr->provider->destroy(fenced_mgr->provider);
+
+   fenced_mgr->ops->destroy(fenced_mgr->ops);
+
+   FREE(fenced_mgr);
 }
 
 
+struct pb_manager *
+fenced_bufmgr_create(struct pb_manager *provider,
+                     struct pb_fence_ops *ops,
+                     pb_size max_buffer_size,
+                     pb_size max_cpu_total_size)
+{
+   struct fenced_manager *fenced_mgr;
+
+   if(!provider)
+      return NULL;
+
+   fenced_mgr = CALLOC_STRUCT(fenced_manager);
+   if (!fenced_mgr)
+      return NULL;
+
+   fenced_mgr->base.destroy = fenced_bufmgr_destroy;
+   fenced_mgr->base.create_buffer = fenced_bufmgr_create_buffer;
+   fenced_mgr->base.flush = fenced_bufmgr_flush;
+
+   fenced_mgr->provider = provider;
+   fenced_mgr->ops = ops;
+   fenced_mgr->max_buffer_size = max_buffer_size;
+   fenced_mgr->max_cpu_total_size = max_cpu_total_size;
+
+   LIST_INITHEAD(&fenced_mgr->fenced);
+   fenced_mgr->num_fenced = 0;
+
+   LIST_INITHEAD(&fenced_mgr->unfenced);
+   fenced_mgr->num_unfenced = 0;
+
+   pipe_mutex_init(fenced_mgr->mutex);
+
+   return &fenced_mgr->base;
+}
diff --git a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.h b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.h
index 034ca1e..0372f81 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.h
+++ b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.h
@@ -98,43 +98,6 @@ struct pb_fence_ops
 };
 
 
-/**
- * Create a fenced buffer list.
- * 
- * See also fenced_bufmgr_create for a more convenient way to use this.
- */
-struct fenced_buffer_list *
-fenced_buffer_list_create(struct pb_fence_ops *ops);
-
-
-/**
- * Walk the fenced buffer list to check and free signalled buffers.
- */ 
-void
-fenced_buffer_list_check_free(struct fenced_buffer_list *fenced_list, 
-                              int wait);
-
-
-#ifdef DEBUG
-void
-fenced_buffer_list_dump(struct fenced_buffer_list *fenced_list);
-#endif
-
-
-void
-fenced_buffer_list_destroy(struct fenced_buffer_list *fenced_list);
-
-
-/**
- * Wrap a buffer in a fenced buffer.
- * 
- * NOTE: this will not increase the buffer reference count.
- */
-struct pb_buffer *
-fenced_buffer_create(struct fenced_buffer_list *fenced, 
-                     struct pb_buffer *buffer);
-
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/gallium/auxiliary/pipebuffer/pb_bufmgr.h b/src/gallium/auxiliary/pipebuffer/pb_bufmgr.h
index 8c8d713..0666991 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_bufmgr.h
+++ b/src/gallium/auxiliary/pipebuffer/pb_bufmgr.h
@@ -175,7 +175,9 @@ struct pb_fence_ops;
  */
 struct pb_manager *
 fenced_bufmgr_create(struct pb_manager *provider,
-                     struct pb_fence_ops *ops);
+                     struct pb_fence_ops *ops,
+                     pb_size max_buffer_size,
+                     pb_size max_cpu_total_size);
 
 
 struct pb_manager *
diff --git a/src/gallium/auxiliary/pipebuffer/pb_bufmgr_debug.c b/src/gallium/auxiliary/pipebuffer/pb_bufmgr_debug.c
index 6e3214c..8f74180 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_bufmgr_debug.c
+++ b/src/gallium/auxiliary/pipebuffer/pb_bufmgr_debug.c
@@ -371,6 +371,9 @@ pb_debug_manager_create_buffer(struct pb_manager *_mgr,
    struct pb_desc real_desc;
    pb_size real_size;
    
+   assert(size);
+   assert(desc->alignment);
+
    buf = CALLOC_STRUCT(pb_debug_buffer);
    if(!buf)
       return NULL;
diff --git a/src/gallium/auxiliary/pipebuffer/pb_bufmgr_fenced.c b/src/gallium/auxiliary/pipebuffer/pb_bufmgr_fenced.c
deleted file mode 100644
index 97dd142..0000000
--- a/src/gallium/auxiliary/pipebuffer/pb_bufmgr_fenced.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2006 Tungsten Graphics, Inc., Bismarck, ND., USA
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
- * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
- * USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * 
- **************************************************************************/
-
-/**
- * \file
- * A buffer manager that wraps buffers in fenced buffers.
- * 
- * \author Jose Fonseca <jrfonseca@tungstengraphics.dot.com>
- */
-
-
-#include "util/u_debug.h"
-#include "util/u_memory.h"
-
-#include "pb_buffer.h"
-#include "pb_buffer_fenced.h"
-#include "pb_bufmgr.h"
-
-
-struct fenced_pb_manager
-{
-   struct pb_manager base;
-
-   struct pb_manager *provider;
-   
-   struct fenced_buffer_list *fenced_list;
-};
-
-
-static INLINE struct fenced_pb_manager *
-fenced_pb_manager(struct pb_manager *mgr)
-{
-   assert(mgr);
-   return (struct fenced_pb_manager *)mgr;
-}
-
-
-static struct pb_buffer *
-fenced_bufmgr_create_buffer(struct pb_manager *mgr, 
-                            pb_size size,
-                            const struct pb_desc *desc)
-{
-   struct fenced_pb_manager *fenced_mgr = fenced_pb_manager(mgr);
-   struct pb_buffer *buf;
-   struct pb_buffer *fenced_buf;
-
-   /* check for free buffers before allocating new ones */
-   fenced_buffer_list_check_free(fenced_mgr->fenced_list, 0);
-   
-   buf = fenced_mgr->provider->create_buffer(fenced_mgr->provider, size, desc);
-   if(!buf) {
-      /* try harder to get a buffer */
-      fenced_buffer_list_check_free(fenced_mgr->fenced_list, 1);
-      
-      buf = fenced_mgr->provider->create_buffer(fenced_mgr->provider, size, desc);
-      if(!buf) {
-#if 0
-         fenced_buffer_list_dump(fenced_mgr->fenced_list);
-#endif
-         
-         /* give up */
-         return NULL;
-      }
-   }
-   
-   fenced_buf = fenced_buffer_create(fenced_mgr->fenced_list, buf);
-   if(!fenced_buf) {
-      pb_reference(&buf, NULL);
-   }
-   
-   return fenced_buf;
-}
-
-
-static void
-fenced_bufmgr_flush(struct pb_manager *mgr)
-{
-   struct fenced_pb_manager *fenced_mgr = fenced_pb_manager(mgr);
-
-   fenced_buffer_list_check_free(fenced_mgr->fenced_list, TRUE);
-
-   assert(fenced_mgr->provider->flush);
-   if(fenced_mgr->provider->flush)
-      fenced_mgr->provider->flush(fenced_mgr->provider);
-}
-
-
-static void
-fenced_bufmgr_destroy(struct pb_manager *mgr)
-{
-   struct fenced_pb_manager *fenced_mgr = fenced_pb_manager(mgr);
-
-   fenced_buffer_list_destroy(fenced_mgr->fenced_list);
-
-   if(fenced_mgr->provider)
-      fenced_mgr->provider->destroy(fenced_mgr->provider);
-   
-   FREE(fenced_mgr);
-}
-
-
-struct pb_manager *
-fenced_bufmgr_create(struct pb_manager *provider, 
-                     struct pb_fence_ops *ops) 
-{
-   struct fenced_pb_manager *fenced_mgr;
-
-   if(!provider)
-      return NULL;
-   
-   fenced_mgr = CALLOC_STRUCT(fenced_pb_manager);
-   if (!fenced_mgr)
-      return NULL;
-
-   fenced_mgr->base.destroy = fenced_bufmgr_destroy;
-   fenced_mgr->base.create_buffer = fenced_bufmgr_create_buffer;
-   fenced_mgr->base.flush = fenced_bufmgr_flush;
-
-   fenced_mgr->provider = provider;
-   fenced_mgr->fenced_list = fenced_buffer_list_create(ops);
-   if(!fenced_mgr->fenced_list) {
-      FREE(fenced_mgr);
-      return NULL;
-   }
-      
-   return &fenced_mgr->base;
-}
diff --git a/src/gallium/auxiliary/pipebuffer/pb_validate.c b/src/gallium/auxiliary/pipebuffer/pb_validate.c
index ce40c0c..903afc7 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_validate.c
+++ b/src/gallium/auxiliary/pipebuffer/pb_validate.c
@@ -39,7 +39,6 @@
 #include "util/u_debug.h"
 
 #include "pb_buffer.h"
-#include "pb_buffer_fenced.h"
 #include "pb_validate.h"
 
 
diff --git a/src/gallium/auxiliary/rbug/rbug_context.h b/src/gallium/auxiliary/rbug/rbug_context.h
index da61c23..03126d6 100644
--- a/src/gallium/auxiliary/rbug/rbug_context.h
+++ b/src/gallium/auxiliary/rbug/rbug_context.h
@@ -46,7 +46,7 @@ typedef enum
 	RBUG_BLOCK_BEFORE = 1,
 	RBUG_BLOCK_AFTER = 2,
 	RBUG_BLOCK_RULE = 4,
-	RBUG_BLOCK_MASK = 7,
+	RBUG_BLOCK_MASK = 7
 } rbug_block_t;
 
 struct rbug_proto_context_list
diff --git a/src/gallium/auxiliary/rbug/rbug_proto.h b/src/gallium/auxiliary/rbug/rbug_proto.h
index d273be0..4f3eb75 100644
--- a/src/gallium/auxiliary/rbug/rbug_proto.h
+++ b/src/gallium/auxiliary/rbug/rbug_proto.h
@@ -65,7 +65,7 @@ enum rbug_opcode
 	RBUG_OP_SHADER_DISABLE = 770,
 	RBUG_OP_SHADER_REPLACE = 771,
 	RBUG_OP_SHADER_LIST_REPLY = -768,
-	RBUG_OP_SHADER_INFO_REPLY = -769,
+	RBUG_OP_SHADER_INFO_REPLY = -769
 };
 
 /**
diff --git a/src/gallium/auxiliary/rtasm/rtasm_execmem.c b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
index 01811d5..ffed768 100644
--- a/src/gallium/auxiliary/rtasm/rtasm_execmem.c
+++ b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
@@ -41,6 +41,12 @@
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
+#if defined(PIPE_OS_WINDOWS)
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN 1
+#endif
+#include <windows.h>
+#endif
 
 #if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
 
@@ -118,7 +124,29 @@ rtasm_exec_free(void *addr)
 }
 
 
-#else /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#elif defined(PIPE_OS_WINDOWS)
+
+
+/*
+ * Avoid Data Execution Prevention.
+ */
+
+void *
+rtasm_exec_malloc(size_t size)
+{
+   return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+}
+
+
+void
+rtasm_exec_free(void *addr)
+{
+   VirtualFree(addr, 0, MEM_RELEASE);
+}
+
+
+#else
+
 
 /*
  * Just use regular memory.
@@ -138,4 +166,4 @@ rtasm_exec_free(void *addr)
 }
 
 
-#endif /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#endif
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index b7569e7..146000a 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -1209,11 +1209,19 @@ fetch_src_file_channel(
 
       default:
          assert( 0 );
+         chan->u[0] = 0;
+         chan->u[1] = 0;
+         chan->u[2] = 0;
+         chan->u[3] = 0;
       }
       break;
 
    default:
       assert( 0 );
+      chan->u[0] = 0;
+      chan->u[1] = 0;
+      chan->u[2] = 0;
+      chan->u[3] = 0;
    }
 }
 
diff --git a/src/gallium/auxiliary/tgsi/tgsi_scan.c b/src/gallium/auxiliary/tgsi/tgsi_scan.c
index f9c16f1..a4414d1 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_scan.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_scan.c
@@ -101,12 +101,10 @@ tgsi_scan_shader(const struct tgsi_token *tokens,
                   if (src->SrcRegister.File == TGSI_FILE_INPUT) {
                      const int ind = src->SrcRegister.Index;
                      if (info->input_semantic_name[ind] == TGSI_SEMANTIC_FOG) {
-                        if (src->SrcRegister.SwizzleX == TGSI_SWIZZLE_X) {
-                           info->uses_fogcoord = TRUE;
-                        }
-                        else if (src->SrcRegister.SwizzleX == TGSI_SWIZZLE_Y) {
-                           info->uses_frontfacing = TRUE;
-                        }
+                        info->uses_fogcoord = TRUE;
+                     }
+                     else if (info->input_semantic_name[ind] == TGSI_SEMANTIC_FACE) {
+                        info->uses_frontfacing = TRUE;
                      }
                   }
                }
diff --git a/src/gallium/auxiliary/tgsi/tgsi_sse2.c b/src/gallium/auxiliary/tgsi/tgsi_sse2.c
index a96fc94..2c39def 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_sse2.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_sse2.c
@@ -2142,40 +2142,50 @@ emit_instruction(
       break;
 
    case TGSI_OPCODE_XPD:
+      /* Note: we do all stores after all operands have been fetched
+       * to avoid src/dst register aliasing issues for an instruction
+       * such as:  XPD TEMP[2].xyz, TEMP[0], TEMP[2];
+       */
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) ) {
-         FETCH( func, *inst, 1, 1, CHAN_Z );
-         FETCH( func, *inst, 3, 0, CHAN_Z );
+         FETCH( func, *inst, 1, 1, CHAN_Z ); /* xmm[1] = src[1].z */
+         FETCH( func, *inst, 3, 0, CHAN_Z ); /* xmm[3] = src[0].z */
       }
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) ) {
-         FETCH( func, *inst, 0, 0, CHAN_Y );
-         FETCH( func, *inst, 4, 1, CHAN_Y );
+         FETCH( func, *inst, 0, 0, CHAN_Y ); /* xmm[0] = src[0].y */
+         FETCH( func, *inst, 4, 1, CHAN_Y ); /* xmm[4] = src[1].y */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) {
-         emit_MOV( func, 2, 0 );
-         emit_mul( func, 2, 1 );
-         emit_MOV( func, 5, 3 );
-         emit_mul( func, 5, 4 );
-         emit_sub( func, 2, 5 );
-         STORE( func, *inst, 2, 0, CHAN_X );
+         emit_MOV( func, 7, 0 );  /* xmm[7] = xmm[0] */
+         emit_mul( func, 7, 1 );  /* xmm[7] = xmm[2] * xmm[1] */
+         emit_MOV( func, 5, 3 );  /* xmm[5] = xmm[3] */
+         emit_mul( func, 5, 4 );  /* xmm[5] = xmm[5] * xmm[4] */
+         emit_sub( func, 7, 5 );  /* xmm[7] = xmm[2] - xmm[5] */
+         /* store xmm[7] in dst.x below */
       }
       if( IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) ||
           IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) ) {
-         FETCH( func, *inst, 2, 1, CHAN_X );
-         FETCH( func, *inst, 5, 0, CHAN_X );
+         FETCH( func, *inst, 2, 1, CHAN_X ); /* xmm[2] = src[1].x */
+         FETCH( func, *inst, 5, 0, CHAN_X ); /* xmm[5] = src[0].x */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) {
-         emit_mul( func, 3, 2 );
-         emit_mul( func, 1, 5 );
-         emit_sub( func, 3, 1 );
-         STORE( func, *inst, 3, 0, CHAN_Y );
+         emit_mul( func, 3, 2 );  /* xmm[3] = xmm[3] * xmm[2] */
+         emit_mul( func, 1, 5 );  /* xmm[1] = xmm[1] * xmm[5] */
+         emit_sub( func, 3, 1 );  /* xmm[3] = xmm[3] - xmm[1] */
+         /* store xmm[3] in dst.y below */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Z ) {
-         emit_mul( func, 5, 4 );
-         emit_mul( func, 0, 2 );
-         emit_sub( func, 5, 0 );
-         STORE( func, *inst, 5, 0, CHAN_Z );
+         emit_mul( func, 5, 4 );  /* xmm[5] = xmm[5] * xmm[4] */
+         emit_mul( func, 0, 2 );  /* xmm[0] = xmm[0] * xmm[2] */
+         emit_sub( func, 5, 0 );  /* xmm[5] = xmm[5] - xmm[0] */
+         STORE( func, *inst, 5, 0, CHAN_Z ); /* dst.z = xmm[5] */
+      }
+      IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_X ) {
+         STORE( func, *inst, 7, 0, CHAN_X ); /* dst.x = xmm[7] */
+      }
+      IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_Y ) {
+         STORE( func, *inst, 3, 0, CHAN_Y ); /* dst.y = xmm[3] */
       }
       IF_IS_DST0_CHANNEL_ENABLED( *inst, CHAN_W ) {
 	 emit_tempf(
diff --git a/src/gallium/auxiliary/tgsi/tgsi_ureg.c b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
index 3f752e9..bf39cf5 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_ureg.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
@@ -780,8 +780,8 @@ ureg_insn(struct ureg_program *ureg,
    unsigned i;
    boolean saturate;
    boolean predicate;
-   boolean negate;
-   unsigned swizzle[4];
+   boolean negate = FALSE;
+   unsigned swizzle[4] = { 0 };
 
    saturate = nr_dst ? dst[0].Saturate : FALSE;
    predicate = nr_dst ? dst[0].Predicate : FALSE;
@@ -827,8 +827,8 @@ ureg_tex_insn(struct ureg_program *ureg,
    unsigned i;
    boolean saturate;
    boolean predicate;
-   boolean negate;
-   unsigned swizzle[4];
+   boolean negate = FALSE;
+   unsigned swizzle[4] = { 0 };
 
    saturate = nr_dst ? dst[0].Saturate : FALSE;
    predicate = nr_dst ? dst[0].Predicate : FALSE;
diff --git a/src/gallium/auxiliary/util/Makefile b/src/gallium/auxiliary/util/Makefile
index 1d8bb55..7e47ec6 100644
--- a/src/gallium/auxiliary/util/Makefile
+++ b/src/gallium/auxiliary/util/Makefile
@@ -9,6 +9,7 @@ C_SOURCES = \
 	u_debug_symbol.c \
 	u_debug_stack.c \
 	u_blit.c \
+	u_bitmask.c \
 	u_cache.c \
 	u_cpu_detect.c \
 	u_draw_quad.c \
diff --git a/src/gallium/auxiliary/util/u_bitmask.c b/src/gallium/auxiliary/util/u_bitmask.c
index 77587c0..23c93a3 100644
--- a/src/gallium/auxiliary/util/u_bitmask.c
+++ b/src/gallium/auxiliary/util/u_bitmask.c
@@ -97,12 +97,12 @@ util_bitmask_resize(struct util_bitmask *bm,
    if(!minimum_size)
       return FALSE;
       
-   if(bm->size > minimum_size)
+   if(bm->size >= minimum_size)
       return TRUE;
 
    assert(bm->size % UTIL_BITMASK_BITS_PER_WORD == 0);
    new_size = bm->size;
-   while(!(new_size > minimum_size)) {
+   while(new_size < minimum_size) {
       new_size *= 2;
       /* Check integer overflow */
       if(new_size < bm->size)
@@ -136,7 +136,7 @@ util_bitmask_filled_set(struct util_bitmask *bm,
                         unsigned index)
 {
    assert(bm->filled <= bm->size);
-   assert(index <= bm->size);
+   assert(index < bm->size);
    
    if(index == bm->filled) {
       ++bm->filled;
@@ -149,7 +149,7 @@ util_bitmask_filled_unset(struct util_bitmask *bm,
                           unsigned index)
 {
    assert(bm->filled <= bm->size);
-   assert(index <= bm->size);
+   assert(index < bm->size);
    
    if(index < bm->filled)
       bm->filled = index;
@@ -182,7 +182,7 @@ util_bitmask_add(struct util_bitmask *bm)
       mask = 1;
    }
 found:
-   
+
    /* grow the bitmask if necessary */
    if(!util_bitmask_resize(bm, bm->filled))
       return UTIL_BITMASK_INVALID_INDEX;
@@ -198,9 +198,9 @@ unsigned
 util_bitmask_set(struct util_bitmask *bm, 
                  unsigned index)
 {
-   unsigned word = index / UTIL_BITMASK_BITS_PER_WORD;
-   unsigned bit  = index % UTIL_BITMASK_BITS_PER_WORD;
-   util_bitmask_word mask = 1 << bit;
+   unsigned word;
+   unsigned bit;
+   util_bitmask_word mask;
    
    assert(bm);
    
@@ -208,6 +208,10 @@ util_bitmask_set(struct util_bitmask *bm,
    if(!util_bitmask_resize(bm, index))
       return UTIL_BITMASK_INVALID_INDEX;
 
+   word = index / UTIL_BITMASK_BITS_PER_WORD;
+   bit  = index % UTIL_BITMASK_BITS_PER_WORD;
+   mask = 1 << bit;
+
    bm->words[word] |= mask;
 
    util_bitmask_filled_set(bm, index);
@@ -220,15 +224,19 @@ void
 util_bitmask_clear(struct util_bitmask *bm, 
                    unsigned index)
 {
-   unsigned word = index / UTIL_BITMASK_BITS_PER_WORD;
-   unsigned bit  = index % UTIL_BITMASK_BITS_PER_WORD;
-   util_bitmask_word mask = 1 << bit;
+   unsigned word;
+   unsigned bit;
+   util_bitmask_word mask;
    
    assert(bm);
    
    if(index >= bm->size)
       return;
 
+   word = index / UTIL_BITMASK_BITS_PER_WORD;
+   bit  = index % UTIL_BITMASK_BITS_PER_WORD;
+   mask = 1 << bit;
+
    bm->words[word] &= ~mask;
    
    util_bitmask_filled_unset(bm, index);
@@ -250,7 +258,7 @@ util_bitmask_get(struct util_bitmask *bm,
       return TRUE;
    }
 
-   if(index > bm->size)
+   if(index >= bm->size)
       return FALSE;
 
    if(bm->words[word] & mask) {
diff --git a/src/gallium/auxiliary/util/u_blit.c b/src/gallium/auxiliary/util/u_blit.c
index 5038642..cf35d3d 100644
--- a/src/gallium/auxiliary/util/u_blit.c
+++ b/src/gallium/auxiliary/util/u_blit.c
@@ -224,8 +224,8 @@ setup_vertex_data_tex(struct blit_state *ctx,
 
    offset = get_next_slot( ctx );
 
-   pipe_buffer_write(ctx->pipe->screen, ctx->vbuf,
-                     offset, sizeof(ctx->vertices), ctx->vertices);
+   pipe_buffer_write_nooverlap(ctx->pipe->screen, ctx->vbuf,
+                               offset, sizeof(ctx->vertices), ctx->vertices);
 
    return offset;
 }
diff --git a/src/gallium/auxiliary/util/u_clear.h b/src/gallium/auxiliary/util/u_clear.h
index 1e65a03..6be5ca2 100644
--- a/src/gallium/auxiliary/util/u_clear.h
+++ b/src/gallium/auxiliary/util/u_clear.h
@@ -46,7 +46,7 @@ util_clear(struct pipe_context *pipe,
 {
    if (buffers & PIPE_CLEAR_COLOR) {
       struct pipe_surface *ps = framebuffer->cbufs[0];
-      unsigned color;
+      unsigned color = 0;
 
       util_pack_color(rgba, ps->format, &color);
       if (pipe->surface_fill) {
diff --git a/src/gallium/auxiliary/util/u_debug.c b/src/gallium/auxiliary/util/u_debug.c
index 96d400c..be5eb87 100644
--- a/src/gallium/auxiliary/util/u_debug.c
+++ b/src/gallium/auxiliary/util/u_debug.c
@@ -452,7 +452,8 @@ debug_dump_flags(const struct debug_named_value *names,
 	    util_strncat(output, "|", sizeof(output));
 	 else
 	    first = 0;
-	 util_strncat(output, names->name, sizeof(output));
+	 util_strncat(output, names->name, sizeof(output) - 1);
+	 output[sizeof(output) - 1] = '\0';
 	 value &= ~names->value;
       }
       ++names;
@@ -465,7 +466,8 @@ debug_dump_flags(const struct debug_named_value *names,
 	 first = 0;
       
       util_snprintf(rest, sizeof(rest), "0x%08lx", value);
-      util_strncat(output, rest, sizeof(output));
+      util_strncat(output, rest, sizeof(output) - 1);
+      output[sizeof(output) - 1] = '\0';
    }
    
    if(first)
diff --git a/src/gallium/auxiliary/util/u_debug.h b/src/gallium/auxiliary/util/u_debug.h
index abd834c..facc30a 100644
--- a/src/gallium/auxiliary/util/u_debug.h
+++ b/src/gallium/auxiliary/util/u_debug.h
@@ -188,7 +188,7 @@ void _debug_assert_fail(const char *expr,
 #ifdef DEBUG
 #define debug_assert(expr) ((expr) ? (void)0 : _debug_assert_fail(#expr, __FILE__, __LINE__, __FUNCTION__))
 #else
-#define debug_assert(expr) ((void)0)
+#define debug_assert(expr) do { } while (0 && (expr))
 #endif
 
 
diff --git a/src/gallium/auxiliary/util/u_debug_memory.c b/src/gallium/auxiliary/util/u_debug_memory.c
index 7623cb9..d6484f4 100644
--- a/src/gallium/auxiliary/util/u_debug_memory.c
+++ b/src/gallium/auxiliary/util/u_debug_memory.c
@@ -297,9 +297,9 @@ debug_memory_end(unsigned long start_no)
 
       if((start_no <= hdr->no && hdr->no < last_no) ||
 	 (last_no < start_no && (hdr->no < last_no || start_no <= hdr->no))) {
-	 debug_printf("%s:%u:%s: %u bytes at %p not freed\n",
+	 debug_printf("%s:%u:%s: %lu bytes at %p not freed\n",
 		      hdr->file, hdr->line, hdr->function,
-		      hdr->size, ptr);
+		      (unsigned long) hdr->size, ptr);
 #if DEBUG_MEMORY_STACK
 	 debug_backtrace_dump(hdr->backtrace, DEBUG_MEMORY_STACK);
 #endif
@@ -315,8 +315,8 @@ debug_memory_end(unsigned long start_no)
    }
 
    if(total_size) {
-      debug_printf("Total of %u KB of system memory apparently leaked\n",
-		   (total_size + 1023)/1024);
+      debug_printf("Total of %lu KB of system memory apparently leaked\n",
+		   (unsigned long) (total_size + 1023)/1024);
    }
    else {
       debug_printf("No memory leaks detected.\n");
diff --git a/src/gallium/auxiliary/util/u_format.h b/src/gallium/auxiliary/util/u_format.h
index 7b5b7fc..bd27f34 100644
--- a/src/gallium/auxiliary/util/u_format.h
+++ b/src/gallium/auxiliary/util/u_format.h
@@ -79,7 +79,7 @@ enum util_format_colorspace {
    UTIL_FORMAT_COLORSPACE_RGB = 0,
    UTIL_FORMAT_COLORSPACE_SRGB = 1,
    UTIL_FORMAT_COLORSPACE_YUV = 2,
-   UTIL_FORMAT_COLORSPACE_ZS = 3,
+   UTIL_FORMAT_COLORSPACE_ZS = 3
 };
 
 
diff --git a/src/gallium/auxiliary/util/u_gen_mipmap.c b/src/gallium/auxiliary/util/u_gen_mipmap.c
index aa823aa..e47928b 100644
--- a/src/gallium/auxiliary/util/u_gen_mipmap.c
+++ b/src/gallium/auxiliary/util/u_gen_mipmap.c
@@ -1457,8 +1457,8 @@ set_vertex_data(struct gen_mipmap_state *ctx,
 
    offset = get_next_slot( ctx );
 
-   pipe_buffer_write(ctx->pipe->screen, ctx->vbuf,
-                     offset, sizeof(ctx->vertices), ctx->vertices);
+   pipe_buffer_write_nooverlap(ctx->pipe->screen, ctx->vbuf,
+                               offset, sizeof(ctx->vertices), ctx->vertices);
 
    return offset;
 }
diff --git a/src/gallium/auxiliary/util/u_network.c b/src/gallium/auxiliary/util/u_network.c
index 6269c72..87ee0e4 100644
--- a/src/gallium/auxiliary/util/u_network.c
+++ b/src/gallium/auxiliary/util/u_network.c
@@ -6,7 +6,7 @@
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  include <winsock2.h>
 #  include <windows.h>
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 #  include <sys/socket.h>
 #  include <netinet/in.h>
 #  include <unistd.h>
@@ -54,7 +54,7 @@ u_socket_close(int s)
    if (s < 0)
       return;
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
    shutdown(s, SHUT_RDWR);
    close(s);
 #elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
@@ -117,7 +117,7 @@ u_socket_connect(const char *hostname, uint16_t port)
    if (!host)
       return -1;
 
-   memcpy((char *)&sa.sin_addr,host->h_addr,host->h_length);
+   memcpy((char *)&sa.sin_addr,host->h_addr_list[0],host->h_length);
    sa.sin_family= host->h_addrtype;
    sa.sin_port = htons(port);
 
@@ -169,7 +169,7 @@ u_socket_listen_on_port(uint16_t portnum)
 void
 u_socket_block(int s, boolean block)
 {
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
    int old = fcntl(s, F_GETFL, 0);
    if (old == -1)
       return;
diff --git a/src/gallium/auxiliary/util/u_network.h b/src/gallium/auxiliary/util/u_network.h
index 0aa898b..187dcab 100644
--- a/src/gallium/auxiliary/util/u_network.h
+++ b/src/gallium/auxiliary/util/u_network.h
@@ -6,7 +6,7 @@
 
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  define PIPE_HAVE_SOCKETS
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 #  define PIPE_HAVE_SOCKETS
 #endif
 
diff --git a/src/gallium/auxiliary/util/u_stream_stdc.c b/src/gallium/auxiliary/util/u_stream_stdc.c
index 5cd05b2..4d976d6 100644
--- a/src/gallium/auxiliary/util/u_stream_stdc.c
+++ b/src/gallium/auxiliary/util/u_stream_stdc.c
@@ -32,7 +32,7 @@
 
 #include "pipe/p_config.h"
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_SUBSYSTEM_WINDOWS_USER) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_SUBSYSTEM_WINDOWS_USER) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_APPLE)
 
 #include <stdio.h>
 
diff --git a/src/gallium/auxiliary/util/u_tile.c b/src/gallium/auxiliary/util/u_tile.c
index 8a22f58..7b0680b 100644
--- a/src/gallium/auxiliary/util/u_tile.c
+++ b/src/gallium/auxiliary/util/u_tile.c
@@ -341,7 +341,7 @@ a4r4g4b4_put_tile_rgba(ushort *dst,
          g >>= 4;
          b >>= 4;
          a >>= 4;
-         *dst++ = (a << 12) | (r << 16) | (g << 4) | b;
+         *dst++ = (a << 12) | (r << 8) | (g << 4) | b;
       }
       p += src_stride;
    }
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.c b/src/gallium/auxiliary/util/u_upload_mgr.c
index 975ee89..55a6537 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.c
+++ b/src/gallium/auxiliary/util/u_upload_mgr.c
@@ -85,7 +85,9 @@ my_buffer_write(struct pipe_screen *screen,
 
    map = pipe_buffer_map_range(screen, buf, offset, size, 
                                PIPE_BUFFER_USAGE_CPU_WRITE |
-                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT);
+                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
+                               PIPE_BUFFER_USAGE_DISCARD |
+                               PIPE_BUFFER_USAGE_UNSYNCHRONIZED);
    if (map == NULL) 
       return PIPE_ERROR_OUT_OF_MEMORY;
 
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c b/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
index c4ba698..bbe0d5f 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_mc_renderer.c
@@ -336,11 +336,13 @@ create_frame_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
@@ -445,11 +447,13 @@ create_frame_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
@@ -536,11 +540,13 @@ create_frame_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_bi_pred_vert_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 create_frame_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
@@ -663,11 +669,13 @@ create_frame_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
    free(tokens);
 }
 
+#if 0
 static void
 create_field_bi_pred_frag_shader(struct vl_mpeg12_mc_renderer *r)
 {
    assert(false);
 }
+#endif
 
 static void
 xfer_buffers_map(struct vl_mpeg12_mc_renderer *r)
@@ -1087,6 +1095,9 @@ gen_macroblock_verts(struct vl_mpeg12_mc_renderer *r,
    assert(ycbcr_vb);
    assert(pos < r->macroblocks_per_batch);
 
+   mo_vec[1].x = 0;
+   mo_vec[1].y = 0;
+
    switch (mb->mb_type) {
       case PIPE_MPEG12_MACROBLOCK_TYPE_BI:
       {
diff --git a/src/gallium/drivers/i915/i915_buffer.c b/src/gallium/drivers/i915/i915_buffer.c
index effeba1..6699647 100644
--- a/src/gallium/drivers/i915/i915_buffer.c
+++ b/src/gallium/drivers/i915/i915_buffer.c
@@ -111,6 +111,7 @@ i915_buffer_unmap(struct pipe_screen *screen,
 {
    struct i915_buffer *buf = i915_buffer(buffer);
    assert(!buf->ibuf);
+   (void) buf;
 }
 
 static void
diff --git a/src/gallium/drivers/i915/i915_clear.c b/src/gallium/drivers/i915/i915_clear.c
index 90530f2..0d0859f 100644
--- a/src/gallium/drivers/i915/i915_clear.c
+++ b/src/gallium/drivers/i915/i915_clear.c
@@ -32,7 +32,6 @@
 
 #include "util/u_clear.h"
 #include "i915_context.h"
-#include "i915_state.h"
 
 
 /**
diff --git a/src/gallium/drivers/i915/i915_context.c b/src/gallium/drivers/i915/i915_context.c
index 94c8aee..16ca638 100644
--- a/src/gallium/drivers/i915/i915_context.c
+++ b/src/gallium/drivers/i915/i915_context.c
@@ -29,12 +29,9 @@
 #include "i915_state.h"
 #include "i915_screen.h"
 #include "i915_batch.h"
-#include "i915_texture.h"
-#include "i915_reg.h"
 
 #include "draw/draw_context.h"
 #include "pipe/p_defines.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "pipe/p_inlines.h"
 #include "util/u_memory.h"
 #include "pipe/p_screen.h"
diff --git a/src/gallium/drivers/i915/i915_debug.c b/src/gallium/drivers/i915/i915_debug.c
index c6e6d6f..237654d 100644
--- a/src/gallium/drivers/i915/i915_debug.c
+++ b/src/gallium/drivers/i915/i915_debug.c
@@ -29,7 +29,6 @@
 #include "i915_context.h"
 #include "i915_debug.h"
 #include "i915_batch.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "util/u_debug.h"
 
 
diff --git a/src/gallium/drivers/i915/i915_debug_fp.c b/src/gallium/drivers/i915/i915_debug_fp.c
index 9c5b117..f9c40d8 100644
--- a/src/gallium/drivers/i915/i915_debug_fp.c
+++ b/src/gallium/drivers/i915/i915_debug_fp.c
@@ -29,7 +29,6 @@
 #include "i915_reg.h"
 #include "i915_debug.h"
 #include "pipe/internal/p_winsys_screen.h"
-#include "util/u_memory.h"
 
 
 static void
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 71f00bc..1c8cb91 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -30,7 +30,6 @@
 
 
 #include "draw/draw_context.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
@@ -38,7 +37,6 @@
 
 #include "i915_context.h"
 #include "i915_reg.h"
-#include "i915_state.h"
 #include "i915_state_inlines.h"
 #include "i915_fpc.h"
 
@@ -58,10 +56,10 @@ translate_wrap_mode(unsigned wrap)
       return TEXCOORDMODE_CLAMP_EDGE;
    case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
       return TEXCOORDMODE_CLAMP_BORDER;
-/*
+   /*         
    case PIPE_TEX_WRAP_MIRRORED_REPEAT:
       return TEXCOORDMODE_MIRROR;
-*/
+    */
    default:
       return TEXCOORDMODE_WRAP;
    }
diff --git a/src/gallium/drivers/i915/i915_state_derived.c b/src/gallium/drivers/i915/i915_state_derived.c
index 178d4e8..1373f9e 100644
--- a/src/gallium/drivers/i915/i915_state_derived.c
+++ b/src/gallium/drivers/i915/i915_state_derived.c
@@ -33,7 +33,6 @@
 #include "i915_context.h"
 #include "i915_state.h"
 #include "i915_reg.h"
-#include "i915_fpc.h"
 
 
 
diff --git a/src/gallium/drivers/i915/i915_state_sampler.c b/src/gallium/drivers/i915/i915_state_sampler.c
index c5e9084..86a019d 100644
--- a/src/gallium/drivers/i915/i915_state_sampler.c
+++ b/src/gallium/drivers/i915/i915_state_sampler.c
@@ -27,7 +27,6 @@
 
 #include "pipe/p_context.h"
 #include "pipe/p_state.h"
-#include "util/u_memory.h"
 
 #include "i915_state_inlines.h"
 #include "i915_context.h"
diff --git a/src/gallium/drivers/i915/i915_surface.c b/src/gallium/drivers/i915/i915_surface.c
index ab8331f..793613b 100644
--- a/src/gallium/drivers/i915/i915_surface.c
+++ b/src/gallium/drivers/i915/i915_surface.c
@@ -27,13 +27,7 @@
 
 #include "i915_context.h"
 #include "i915_blit.h"
-#include "i915_state.h"
 #include "pipe/p_defines.h"
-#include "pipe/p_inlines.h"
-#include "pipe/p_inlines.h"
-#include "pipe/internal/p_winsys_screen.h"
-#include "util/u_tile.h"
-#include "util/u_rect.h"
 
 
 /* Assumes all values are within bounds -- no checking at this level -
diff --git a/src/gallium/drivers/i915/i915_texture.c b/src/gallium/drivers/i915/i915_texture.c
index 286c9ac..9c0de8f 100644
--- a/src/gallium/drivers/i915/i915_texture.c
+++ b/src/gallium/drivers/i915/i915_texture.c
@@ -34,13 +34,11 @@
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
 #include "pipe/p_inlines.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
 
 #include "i915_context.h"
 #include "i915_texture.h"
-#include "i915_debug.h"
 #include "i915_screen.h"
 #include "intel_winsys.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_alpha.c b/src/gallium/drivers/llvmpipe/lp_bld_alpha.c
index 2b4bc5c..7245730 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_alpha.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_alpha.c
@@ -35,7 +35,6 @@
 
 #include "lp_bld_type.h"
 #include "lp_bld_const.h"
-#include "lp_bld_arit.h"
 #include "lp_bld_logic.h"
 #include "lp_bld_flow.h"
 #include "lp_bld_debug.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_arit.c b/src/gallium/drivers/llvmpipe/lp_bld_arit.c
index 9c59677..f5d9db7 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_arit.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_arit.c
@@ -56,7 +56,6 @@
 #include "lp_bld_intr.h"
 #include "lp_bld_logic.h"
 #include "lp_bld_pack.h"
-#include "lp_bld_debug.h"
 #include "lp_bld_arit.h"
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c b/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
index d14f468..ced7b9c 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_blend_aos.c
@@ -142,7 +142,7 @@ lp_build_blend_factor_unswizzled(struct lp_build_blend_aos_context *bld,
 
 enum lp_build_blend_swizzle {
    LP_BUILD_BLEND_SWIZZLE_RGBA = 0,
-   LP_BUILD_BLEND_SWIZZLE_AAAA = 1,
+   LP_BUILD_BLEND_SWIZZLE_AAAA = 1
 };
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_blend_soa.c b/src/gallium/drivers/llvmpipe/lp_bld_blend_soa.c
index 9511299..5d5ca7a 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_blend_soa.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_blend_soa.c
@@ -71,7 +71,6 @@
 #include "pipe/p_state.h"
 
 #include "lp_bld_type.h"
-#include "lp_bld_const.h"
 #include "lp_bld_arit.h"
 #include "lp_bld_blend.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_conv.c b/src/gallium/drivers/llvmpipe/lp_bld_conv.c
index 9935209..ebf554c 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_conv.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_conv.c
@@ -63,11 +63,9 @@
 
 #include "util/u_debug.h"
 #include "util/u_math.h"
-#include "util/u_cpu_detect.h"
 
 #include "lp_bld_type.h"
 #include "lp_bld_const.h"
-#include "lp_bld_intr.h"
 #include "lp_bld_arit.h"
 #include "lp_bld_pack.h"
 #include "lp_bld_conv.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_depth.c b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
index 98ec1cb..d438c0e 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_depth.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
@@ -90,7 +90,7 @@ lp_depth_type(const struct util_format_description *format_desc,
 
    if(format_desc->channel[swizzle].type == UTIL_FORMAT_TYPE_FLOAT) {
       type.floating = TRUE;
-      assert(swizzle = 0);
+      assert(swizzle == 0);
       assert(format_desc->channel[swizzle].size == format_desc->block.bits);
    }
    else if(format_desc->channel[swizzle].type == UTIL_FORMAT_TYPE_UNSIGNED) {
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_flow.c b/src/gallium/drivers/llvmpipe/lp_bld_flow.c
index dcc25fb..25c10af 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_flow.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_flow.c
@@ -47,7 +47,7 @@
  */
 enum lp_build_flow_construct_kind {
    lP_BUILD_FLOW_SCOPE,
-   LP_BUILD_FLOW_SKIP,
+   LP_BUILD_FLOW_SKIP
 };
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c b/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
index 5836e01..dfa080b 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_format_aos.c
@@ -38,7 +38,6 @@
 
 #include "lp_bld_type.h"
 #include "lp_bld_const.h"
-#include "lp_bld_logic.h"
 #include "lp_bld_swizzle.h"
 #include "lp_bld_format.h"
 
@@ -130,7 +129,7 @@ lp_build_unpack_rgba_aos(LLVMBuilderRef builder,
 
    shifted = LLVMBuildLShr(builder, packed, LLVMConstVector(shifts, 4), "");
    masked = LLVMBuildAnd(builder, shifted, LLVMConstVector(masks, 4), "");
-   // UIToFP can't be expressed in SSE2
+   /* UIToFP can't be expressed in SSE2 */
    casted = LLVMBuildSIToFP(builder, masked, LLVMVectorType(LLVMFloatType(), 4), "");
 
    if (normalized)
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c b/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
index 94ce4ae..e722bca 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_tgsi_soa.c
@@ -47,13 +47,11 @@
 #include "tgsi/tgsi_exec.h"
 #include "lp_bld_type.h"
 #include "lp_bld_const.h"
-#include "lp_bld_intr.h"
 #include "lp_bld_arit.h"
 #include "lp_bld_logic.h"
 #include "lp_bld_swizzle.h"
 #include "lp_bld_flow.h"
 #include "lp_bld_tgsi.h"
-#include "lp_bld_debug.h"
 
 
 #define LP_MAX_TEMPS 256
@@ -321,7 +319,7 @@ emit_tex( struct lp_build_tgsi_soa_context *bld,
 {
    const uint unit = inst->FullSrcRegisters[1].SrcRegister.Index;
    LLVMValueRef lodbias;
-   LLVMValueRef oow;
+   LLVMValueRef oow = NULL;
    LLVMValueRef coords[3];
    unsigned num_coords;
    unsigned i;
@@ -446,7 +444,12 @@ emit_instruction(
 {
    unsigned chan_index;
    LLVMValueRef src0, src1, src2;
-   LLVMValueRef tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+   LLVMValueRef tmp0, tmp1, tmp2;
+   LLVMValueRef tmp3 = NULL;
+   LLVMValueRef tmp4 = NULL;
+   LLVMValueRef tmp5 = NULL;
+   LLVMValueRef tmp6 = NULL;
+   LLVMValueRef tmp7 = NULL;
    LLVMValueRef res;
    LLVMValueRef dst0[NUM_CHANNELS];
 
diff --git a/src/gallium/drivers/llvmpipe/lp_draw_arrays.c b/src/gallium/drivers/llvmpipe/lp_draw_arrays.c
index 0aa13a1..a43e438 100644
--- a/src/gallium/drivers/llvmpipe/lp_draw_arrays.c
+++ b/src/gallium/drivers/llvmpipe/lp_draw_arrays.c
@@ -33,8 +33,6 @@
 
 #include "pipe/p_defines.h"
 #include "pipe/p_context.h"
-#include "pipe/internal/p_winsys_screen.h"
-#include "pipe/p_inlines.h"
 #include "util/u_prim.h"
 
 #include "lp_buffer.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_flush.c b/src/gallium/drivers/llvmpipe/lp_flush.c
index cd8381f..6c81012 100644
--- a/src/gallium/drivers/llvmpipe/lp_flush.c
+++ b/src/gallium/drivers/llvmpipe/lp_flush.c
@@ -37,8 +37,6 @@
 #include "lp_surface.h"
 #include "lp_state.h"
 #include "lp_tile_cache.h"
-#include "lp_tex_cache.h"
-#include "lp_winsys.h"
 
 
 void
diff --git a/src/gallium/drivers/llvmpipe/lp_jit.c b/src/gallium/drivers/llvmpipe/lp_jit.c
index 13535dd..b5aa7d6 100644
--- a/src/gallium/drivers/llvmpipe/lp_jit.c
+++ b/src/gallium/drivers/llvmpipe/lp_jit.c
@@ -39,7 +39,6 @@
 #include "util/u_cpu_detect.h"
 #include "lp_screen.h"
 #include "lp_bld_intr.h"
-#include "lp_bld_misc.h"
 #include "lp_jit.h"
 
 
diff --git a/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c b/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
index 4abff4e..e8e2e25 100644
--- a/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
+++ b/src/gallium/drivers/llvmpipe/lp_prim_vbuf.c
@@ -128,6 +128,7 @@ lp_vbuf_unmap_vertices(struct vbuf_render *vbr,
 {
    struct llvmpipe_vbuf_render *cvbr = llvmpipe_vbuf_render(vbr);
    assert( cvbr->vertex_buffer_size >= (max_index+1) * cvbr->vertex_size );
+   (void) cvbr;
    /* do nothing */
 }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_setup.c b/src/gallium/drivers/llvmpipe/lp_setup.c
index ffcbc9a..95bc66e 100644
--- a/src/gallium/drivers/llvmpipe/lp_setup.c
+++ b/src/gallium/drivers/llvmpipe/lp_setup.c
@@ -40,7 +40,6 @@
 #include "draw/draw_private.h"
 #include "draw/draw_vertex.h"
 #include "pipe/p_shader_tokens.h"
-#include "pipe/p_thread.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
 #include "lp_bld_debug.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 2e9aa9f..2297cbb 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -62,7 +62,6 @@
 #include "util/u_memory.h"
 #include "util/u_format.h"
 #include "util/u_debug_dump.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "pipe/p_shader_tokens.h"
 #include "draw/draw_context.h"
 #include "tgsi/tgsi_dump.h"
@@ -85,7 +84,6 @@
 #include "lp_context.h"
 #include "lp_buffer.h"
 #include "lp_state.h"
-#include "lp_quad.h"
 #include "lp_tex_sample.h"
 
 
@@ -676,6 +674,7 @@ llvmpipe_delete_fs_state(struct pipe_context *pipe, void *fs)
    struct lp_fragment_shader_variant *variant;
 
    assert(fs != llvmpipe->fs);
+   (void) llvmpipe;
 
    variant = shader->variants;
    while(variant) {
diff --git a/src/gallium/drivers/llvmpipe/lp_state_surface.c b/src/gallium/drivers/llvmpipe/lp_state_surface.c
index c06ce8b..9f74585 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_surface.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_surface.c
@@ -30,7 +30,6 @@
 
 #include "lp_context.h"
 #include "lp_state.h"
-#include "lp_surface.h"
 #include "lp_tile_cache.h"
 
 #include "draw/draw_context.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_state_vertex.c b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
index 1a17631..57ac25e 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_vertex.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
@@ -31,7 +31,6 @@
 
 #include "lp_context.h"
 #include "lp_state.h"
-#include "lp_surface.h"
 
 #include "draw/draw_context.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_test_blend.c b/src/gallium/drivers/llvmpipe/lp_test_blend.c
index 29fff91..411e99d 100644
--- a/src/gallium/drivers/llvmpipe/lp_test_blend.c
+++ b/src/gallium/drivers/llvmpipe/lp_test_blend.c
@@ -38,7 +38,6 @@
 
 
 #include "lp_bld_type.h"
-#include "lp_bld_arit.h"
 #include "lp_bld_blend.h"
 #include "lp_bld_debug.h"
 #include "lp_test.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_test_conv.c b/src/gallium/drivers/llvmpipe/lp_test_conv.c
index 968c7a2..faddfb9 100644
--- a/src/gallium/drivers/llvmpipe/lp_test_conv.c
+++ b/src/gallium/drivers/llvmpipe/lp_test_conv.c
@@ -330,7 +330,7 @@ test_one(unsigned verbose,
          fprintf(stderr, "conv.bc written\n");
          fprintf(stderr, "Invoke as \"llc -o - conv.bc\"\n");
          firsttime = FALSE;
-         //abort();
+         /* abort(); */
       }
    }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_cache.c b/src/gallium/drivers/llvmpipe/lp_tex_cache.c
index 773e848..b28f8dc 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_cache.c
+++ b/src/gallium/drivers/llvmpipe/lp_tex_cache.c
@@ -37,7 +37,6 @@
 #include "util/u_tile.h"
 #include "util/u_format.h"
 #include "lp_context.h"
-#include "lp_surface.h"
 #include "lp_texture.h"
 #include "lp_tex_cache.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_cache.h b/src/gallium/drivers/llvmpipe/lp_tex_cache.h
index 9fa6c36..05fded7 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_cache.h
+++ b/src/gallium/drivers/llvmpipe/lp_tex_cache.h
@@ -115,7 +115,7 @@ extern const struct llvmpipe_cached_tex_tile *
 lp_find_cached_tex_tile(struct llvmpipe_tex_tile_cache *tc,
                         union tex_tile_address addr );
 
-static INLINE const union tex_tile_address
+static INLINE union tex_tile_address
 tex_tile_address( unsigned x,
                   unsigned y,
                   unsigned z,
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c b/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
index a1365a0..d1f5d95 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
+++ b/src/gallium/drivers/llvmpipe/lp_tex_sample_c.c
@@ -35,7 +35,6 @@
 
 #include "lp_context.h"
 #include "lp_quad.h"
-#include "lp_surface.h"
 #include "lp_texture.h"
 #include "lp_tex_sample.h"
 #include "lp_tex_cache.h"
@@ -1085,7 +1084,7 @@ lp_get_samples_2d_common(struct tgsi_sampler *tgsi_sampler,
    const struct pipe_sampler_state *sampler = samp->sampler;
    unsigned level0, level1, j, imgFilter;
    int width, height;
-   float levelBlend;
+   float levelBlend = 0.0F;
 
    choose_mipmap_levels(tgsi_sampler, s, t, p, 
                         lodbias,
diff --git a/src/gallium/drivers/llvmpipe/lp_tex_sample_llvm.c b/src/gallium/drivers/llvmpipe/lp_tex_sample_llvm.c
index d2a6ae2..5138ccf 100644
--- a/src/gallium/drivers/llvmpipe/lp_tex_sample_llvm.c
+++ b/src/gallium/drivers/llvmpipe/lp_tex_sample_llvm.c
@@ -44,7 +44,6 @@
 #include "pipe/p_shader_tokens.h"
 #include "lp_bld_debug.h"
 #include "lp_bld_type.h"
-#include "lp_bld_intr.h"
 #include "lp_bld_sample.h"
 #include "lp_bld_tgsi.h"
 #include "lp_state.h"
diff --git a/src/gallium/drivers/llvmpipe/lp_texture.c b/src/gallium/drivers/llvmpipe/lp_texture.c
index a00f249..948e3de 100644
--- a/src/gallium/drivers/llvmpipe/lp_texture.c
+++ b/src/gallium/drivers/llvmpipe/lp_texture.c
@@ -33,14 +33,12 @@
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
 #include "pipe/p_inlines.h"
-#include "pipe/internal/p_winsys_screen.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
 
 #include "lp_context.h"
 #include "lp_state.h"
 #include "lp_texture.h"
-#include "lp_tex_cache.h"
 #include "lp_screen.h"
 #include "lp_winsys.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_tile_cache.c b/src/gallium/drivers/llvmpipe/lp_tile_cache.c
index ec3e002..a555149 100644
--- a/src/gallium/drivers/llvmpipe/lp_tile_cache.c
+++ b/src/gallium/drivers/llvmpipe/lp_tile_cache.c
@@ -38,8 +38,6 @@
 #include "util/u_tile.h"
 #include "util/u_rect.h"
 #include "lp_context.h"
-#include "lp_surface.h"
-#include "lp_texture.h"
 #include "lp_tile_soa.h"
 #include "lp_tile_cache.h"
 
diff --git a/src/gallium/drivers/llvmpipe/lp_tile_soa.h b/src/gallium/drivers/llvmpipe/lp_tile_soa.h
index 040b018..19d00b5 100644
--- a/src/gallium/drivers/llvmpipe/lp_tile_soa.h
+++ b/src/gallium/drivers/llvmpipe/lp_tile_soa.h
@@ -29,7 +29,7 @@
 #define LP_TILE_SOA_H
 
 #include "pipe/p_compiler.h"
-#include "tgsi/tgsi_exec.h" // for NUM_CHANNELS
+#include "tgsi/tgsi_exec.h" /* for NUM_CHANNELS */
 
 
 #ifdef __cplusplus
diff --git a/src/gallium/drivers/llvmpipe/lp_winsys.h b/src/gallium/drivers/llvmpipe/lp_winsys.h
index 595481c..74b472b 100644
--- a/src/gallium/drivers/llvmpipe/lp_winsys.h
+++ b/src/gallium/drivers/llvmpipe/lp_winsys.h
@@ -35,7 +35,7 @@
 #define LP_WINSYS_H
 
 
-#include "pipe/p_compiler.h" // for boolean
+#include "pipe/p_compiler.h" /* for boolean */
 #include "pipe/p_format.h"
 
 
diff --git a/src/gallium/drivers/nv50/nv50_query.c b/src/gallium/drivers/nv50/nv50_query.c
index 5305c93..f605c47 100644
--- a/src/gallium/drivers/nv50/nv50_query.c
+++ b/src/gallium/drivers/nv50/nv50_query.c
@@ -111,7 +111,7 @@ nv50_query_result(struct pipe_context *pipe, struct pipe_query *pq,
 
 	if (!q->ready) {
 		ret = nouveau_bo_map(q->bo, NOUVEAU_BO_RD |
-				     wait ? 0 : NOUVEAU_BO_NOWAIT);
+				     (wait ? 0 : NOUVEAU_BO_NOWAIT));
 		if (ret)
 			return false;
 		q->result = ((uint32_t *)q->bo->map)[1];
diff --git a/src/gallium/drivers/r300/r300_cs.h b/src/gallium/drivers/r300/r300_cs.h
index 86ba91d..5342488 100644
--- a/src/gallium/drivers/r300/r300_cs.h
+++ b/src/gallium/drivers/r300/r300_cs.h
@@ -51,7 +51,7 @@
 #define CS_LOCALS(context) \
     struct r300_context* const cs_context_copy = (context); \
     struct r300_winsys* cs_winsys = cs_context_copy->winsys; \
-    int cs_count = 0;
+    int cs_count = 0
 
 #define CHECK_CS(size) \
     cs_winsys->check_cs(cs_winsys, (size))
diff --git a/src/gallium/drivers/r300/r300_emit.c b/src/gallium/drivers/r300/r300_emit.c
index eeb97a2..b44c7bd 100644
--- a/src/gallium/drivers/r300/r300_emit.c
+++ b/src/gallium/drivers/r300/r300_emit.c
@@ -871,7 +871,7 @@ validate:
             goto validate;
         }
     } else {
-        // debug_printf("No VBO while emitting dirty state!\n");
+        /* debug_printf("No VBO while emitting dirty state!\n"); */
     }
     if (!r300->winsys->validate(r300->winsys)) {
         r300->context.flush(&r300->context, 0, NULL);
@@ -999,7 +999,7 @@ validate:
     */
 
     /* Finally, emit the VBO. */
-    //r300_emit_vertex_buffer(r300);
+    /* r300_emit_vertex_buffer(r300); */
 
     r300->dirty_hw++;
 }
diff --git a/src/gallium/drivers/r300/r300_flush.c b/src/gallium/drivers/r300/r300_flush.c
index 14a0824..4282357 100644
--- a/src/gallium/drivers/r300/r300_flush.c
+++ b/src/gallium/drivers/r300/r300_flush.c
@@ -39,6 +39,7 @@ static void r300_flush(struct pipe_context* pipe,
     struct r300_query *query;
 
     CS_LOCALS(r300);
+    (void) cs_count;
     /* We probably need to flush Draw, but we may have been called from
      * within Draw. This feels kludgy, but it might be the best thing.
      *
diff --git a/src/gallium/drivers/r300/r300_reg.h b/src/gallium/drivers/r300/r300_reg.h
index 8ca785c..744ea65 100644
--- a/src/gallium/drivers/r300/r300_reg.h
+++ b/src/gallium/drivers/r300/r300_reg.h
@@ -2636,7 +2636,7 @@ enum {
 	VE_COND_MUX_GTE			= 25,
 	VE_SET_GREATER_THAN		= 26,
 	VE_SET_EQUAL			= 27,
-	VE_SET_NOT_EQUAL		= 28,
+	VE_SET_NOT_EQUAL		= 28
 };
 
 enum {
@@ -2670,20 +2670,20 @@ enum {
 	ME_PRED_SET_CLR			= 25,
 	ME_PRED_SET_INV			= 26,
 	ME_PRED_SET_POP			= 27,
-	ME_PRED_SET_RESTORE		= 28,
+	ME_PRED_SET_RESTORE		= 28
 };
 
 enum {
 	/* R3XX */
 	PVS_MACRO_OP_2CLK_MADD		= 0,
-	PVS_MACRO_OP_2CLK_M2X_ADD	= 1,
+	PVS_MACRO_OP_2CLK_M2X_ADD	= 1
 };
 
 enum {
 	PVS_SRC_REG_TEMPORARY		= 0,	/* Intermediate Storage */
 	PVS_SRC_REG_INPUT		= 1,	/* Input Vertex Storage */
 	PVS_SRC_REG_CONSTANT		= 2,	/* Constant State Storage */
-	PVS_SRC_REG_ALT_TEMPORARY	= 3,	/* Alternate Intermediate Storage */
+	PVS_SRC_REG_ALT_TEMPORARY	= 3	/* Alternate Intermediate Storage */
 };
 
 enum {
@@ -2692,7 +2692,7 @@ enum {
 	PVS_DST_REG_OUT			= 2,	/* Output Memory. Used for all outputs */
 	PVS_DST_REG_OUT_REPL_X		= 3,	/* Output Memory & Replicate X to all channels */
 	PVS_DST_REG_ALT_TEMPORARY	= 4,	/* Alternate Intermediate Storage */
-	PVS_DST_REG_INPUT		= 5,	/* Output Memory & Replicate X to all channels */
+	PVS_DST_REG_INPUT		= 5	/* Output Memory & Replicate X to all channels */
 };
 
 enum {
@@ -2701,7 +2701,7 @@ enum {
 	PVS_SRC_SELECT_Z		= 2,	/* Select Z Component */
 	PVS_SRC_SELECT_W		= 3,	/* Select W Component */
 	PVS_SRC_SELECT_FORCE_0		= 4,	/* Force Component to 0.0 */
-	PVS_SRC_SELECT_FORCE_1		= 5,	/* Force Component to 1.0 */
+	PVS_SRC_SELECT_FORCE_1		= 5	/* Force Component to 1.0 */
 };
 
 /* PVS Opcode & Destination Operand Description */
@@ -2740,7 +2740,7 @@ enum {
 	PVS_DST_ADDR_SEL_MASK		= 0x3,
 	PVS_DST_ADDR_SEL_SHIFT		= 29,
 	PVS_DST_ADDR_MODE_0_MASK	= 0x1,
-	PVS_DST_ADDR_MODE_0_SHIFT	= 31,
+	PVS_DST_ADDR_MODE_0_SHIFT	= 31
 };
 
 /* PVS Source Operand Description */
@@ -2775,7 +2775,7 @@ enum {
 	PVS_SRC_ADDR_SEL_MASK		= 0x3,
 	PVS_SRC_ADDR_SEL_SHIFT		= 29,
 	PVS_SRC_ADDR_MODE_1_MASK	= 0x0,
-	PVS_SRC_ADDR_MODE_1_SHIFT	= 32,
+	PVS_SRC_ADDR_MODE_1_SHIFT	= 32
 };
 
 /*\}*/
diff --git a/src/gallium/drivers/r300/r300_state_derived.c b/src/gallium/drivers/r300/r300_state_derived.c
index 7166694..55430a9 100644
--- a/src/gallium/drivers/r300/r300_state_derived.c
+++ b/src/gallium/drivers/r300/r300_state_derived.c
@@ -464,7 +464,7 @@ static void r300_update_rs_block(struct r300_context* r300,
 /* Update the vertex format. */
 static void r300_update_derived_shader_state(struct r300_context* r300)
 {
-    struct r300_screen* r300screen = r300_screen(r300->context.screen);
+    /* struct r300_screen* r300screen = r300_screen(r300->context.screen); */
     struct r300_vertex_info* vformat;
     struct r300_rs_block* rs_block;
     int i;
diff --git a/src/gallium/drivers/softpipe/sp_context.c b/src/gallium/drivers/softpipe/sp_context.c
index 5f60139..beeb6f6 100644
--- a/src/gallium/drivers/softpipe/sp_context.c
+++ b/src/gallium/drivers/softpipe/sp_context.c
@@ -43,7 +43,6 @@
 #include "sp_surface.h"
 #include "sp_tile_cache.h"
 #include "sp_tex_tile_cache.h"
-#include "sp_texture.h"
 #include "sp_winsys.h"
 #include "sp_query.h"
 
diff --git a/src/gallium/drivers/softpipe/sp_flush.c b/src/gallium/drivers/softpipe/sp_flush.c
index e38b767..db293a5 100644
--- a/src/gallium/drivers/softpipe/sp_flush.c
+++ b/src/gallium/drivers/softpipe/sp_flush.c
@@ -34,11 +34,9 @@
 #include "draw/draw_context.h"
 #include "sp_flush.h"
 #include "sp_context.h"
-#include "sp_surface.h"
 #include "sp_state.h"
 #include "sp_tile_cache.h"
 #include "sp_tex_tile_cache.h"
-#include "sp_winsys.h"
 
 
 void
diff --git a/src/gallium/drivers/softpipe/sp_prim_vbuf.c b/src/gallium/drivers/softpipe/sp_prim_vbuf.c
index 5fbac06..43a0bd4 100644
--- a/src/gallium/drivers/softpipe/sp_prim_vbuf.c
+++ b/src/gallium/drivers/softpipe/sp_prim_vbuf.c
@@ -128,6 +128,7 @@ sp_vbuf_unmap_vertices(struct vbuf_render *vbr,
 {
    struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
    assert( cvbr->vertex_buffer_size >= (max_index+1) * cvbr->vertex_size );
+   (void) cvbr;
    /* do nothing */
 }
 
@@ -525,6 +526,8 @@ static void
 sp_vbuf_destroy(struct vbuf_render *vbr)
 {
    struct softpipe_vbuf_render *cvbr = softpipe_vbuf_render(vbr);
+   if(cvbr->vertex_buffer)
+      align_free(cvbr->vertex_buffer);
    sp_setup_destroy_context(cvbr->setup);
    FREE(cvbr);
 }
diff --git a/src/gallium/drivers/softpipe/sp_quad_blend.c b/src/gallium/drivers/softpipe/sp_quad_blend.c
index fe6b6ce..3b8c2d5 100644
--- a/src/gallium/drivers/softpipe/sp_quad_blend.c
+++ b/src/gallium/drivers/softpipe/sp_quad_blend.c
@@ -35,7 +35,6 @@
 #include "util/u_memory.h"
 #include "sp_context.h"
 #include "sp_quad.h"
-#include "sp_surface.h"
 #include "sp_tile_cache.h"
 #include "sp_quad_pipe.h"
 
@@ -229,7 +228,7 @@ blend_quad(struct quad_stage *qs,
    static const float zero[4] = { 0, 0, 0, 0 };
    static const float one[4] = { 1, 1, 1, 1 };
    struct softpipe_context *softpipe = qs->softpipe;
-   float source[4][QUAD_SIZE];
+   float source[4][QUAD_SIZE] = { { 0 } };
 
    /*
     * Compute src/first term RGB
diff --git a/src/gallium/drivers/softpipe/sp_quad_depth_test.c b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
index 0ca86c4..5cb17c5 100644
--- a/src/gallium/drivers/softpipe/sp_quad_depth_test.c
+++ b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
@@ -34,7 +34,6 @@
 #include "tgsi/tgsi_scan.h"
 #include "sp_context.h"
 #include "sp_quad.h"
-#include "sp_surface.h"
 #include "sp_quad_pipe.h"
 #include "sp_tile_cache.h"
 #include "sp_state.h"           /* for sp_fragment_shader */
@@ -667,6 +666,7 @@ depth_test_quads_fallback(struct quad_stage *qs,
    }
 
    if (qs->softpipe->framebuffer.zsbuf && 
+       pf_get_component_bits(qs->softpipe->framebuffer.zsbuf->format, PIPE_FORMAT_COMP_Z) &&
        (qs->softpipe->depth_stencil->depth.enabled ||
         qs->softpipe->depth_stencil->stencil[0].enabled)) {
 
@@ -885,6 +885,7 @@ choose_depth_test(struct quad_stage *qs,
    boolean alpha = qs->softpipe->depth_stencil->alpha.enabled;
 
    boolean depth = (qs->softpipe->framebuffer.zsbuf && 
+                    pf_get_component_bits(qs->softpipe->framebuffer.zsbuf->format, PIPE_FORMAT_COMP_Z) &&
                     qs->softpipe->depth_stencil->depth.enabled);
 
    unsigned depthfunc = qs->softpipe->depth_stencil->depth.func;
@@ -895,7 +896,6 @@ choose_depth_test(struct quad_stage *qs,
 
    boolean occlusion = qs->softpipe->active_query_count;
 
-
    if (!alpha &&
        !depth &&
        !stencil) {
diff --git a/src/gallium/drivers/softpipe/sp_quad_fs.c b/src/gallium/drivers/softpipe/sp_quad_fs.c
index 1e7533d..e799df1 100644
--- a/src/gallium/drivers/softpipe/sp_quad_fs.c
+++ b/src/gallium/drivers/softpipe/sp_quad_fs.c
@@ -45,8 +45,6 @@
 #include "sp_state.h"
 #include "sp_quad.h"
 #include "sp_quad_pipe.h"
-#include "sp_texture.h"
-#include "sp_tex_sample.h"
 
 
 struct quad_shade_stage
diff --git a/src/gallium/drivers/softpipe/sp_setup.c b/src/gallium/drivers/softpipe/sp_setup.c
index 615581b..478d8ef 100644
--- a/src/gallium/drivers/softpipe/sp_setup.c
+++ b/src/gallium/drivers/softpipe/sp_setup.c
@@ -41,7 +41,6 @@
 #include "draw/draw_private.h"
 #include "draw/draw_vertex.h"
 #include "pipe/p_shader_tokens.h"
-#include "pipe/p_thread.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
 
diff --git a/src/gallium/drivers/softpipe/sp_state_surface.c b/src/gallium/drivers/softpipe/sp_state_surface.c
index bc0e201..794a922 100644
--- a/src/gallium/drivers/softpipe/sp_state_surface.c
+++ b/src/gallium/drivers/softpipe/sp_state_surface.c
@@ -30,7 +30,6 @@
 
 #include "sp_context.h"
 #include "sp_state.h"
-#include "sp_surface.h"
 #include "sp_tile_cache.h"
 
 #include "draw/draw_context.h"
diff --git a/src/gallium/drivers/softpipe/sp_state_vertex.c b/src/gallium/drivers/softpipe/sp_state_vertex.c
index 46b6991..b491d92 100644
--- a/src/gallium/drivers/softpipe/sp_state_vertex.c
+++ b/src/gallium/drivers/softpipe/sp_state_vertex.c
@@ -31,7 +31,6 @@
 
 #include "sp_context.h"
 #include "sp_state.h"
-#include "sp_surface.h"
 
 #include "draw/draw_context.h"
 
diff --git a/src/gallium/drivers/softpipe/sp_tex_tile_cache.c b/src/gallium/drivers/softpipe/sp_tex_tile_cache.c
index 407a22a..0312a31 100644
--- a/src/gallium/drivers/softpipe/sp_tex_tile_cache.c
+++ b/src/gallium/drivers/softpipe/sp_tex_tile_cache.c
@@ -36,7 +36,6 @@
 #include "util/u_memory.h"
 #include "util/u_tile.h"
 #include "sp_context.h"
-#include "sp_surface.h"
 #include "sp_texture.h"
 #include "sp_tex_tile_cache.h"
 
diff --git a/src/gallium/drivers/softpipe/sp_texture.c b/src/gallium/drivers/softpipe/sp_texture.c
index 7caf292..64a70bf 100644
--- a/src/gallium/drivers/softpipe/sp_texture.c
+++ b/src/gallium/drivers/softpipe/sp_texture.c
@@ -36,7 +36,6 @@
 #include "util/u_memory.h"
 
 #include "sp_context.h"
-#include "sp_state.h"
 #include "sp_texture.h"
 #include "sp_screen.h"
 #include "sp_winsys.h"
diff --git a/src/gallium/drivers/svga/svga_context.c b/src/gallium/drivers/svga/svga_context.c
index c3de12b..af99c9d 100644
--- a/src/gallium/drivers/svga/svga_context.c
+++ b/src/gallium/drivers/svga/svga_context.c
@@ -29,6 +29,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_screen.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "util/u_upload_mgr.h"
 
 #include "svga_context.h"
@@ -61,6 +62,9 @@ static void svga_destroy( struct pipe_context *pipe )
    u_upload_destroy( svga->upload_vb );
    u_upload_destroy( svga->upload_ib );
 
+   util_bitmask_destroy( svga->vs_bm );
+   util_bitmask_destroy( svga->fs_bm );
+
    for(shader = 0; shader < PIPE_SHADER_TYPES; ++shader)
       pipe_buffer_reference( &svga->curr.cb[shader], NULL );
 
@@ -130,7 +134,7 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    svga = CALLOC_STRUCT(svga_context);
    if (svga == NULL)
-      goto error1;
+      goto no_svga;
 
    svga->pipe.winsys = screen->winsys;
    svga->pipe.screen = screen;
@@ -142,7 +146,7 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    svga->swc = svgascreen->sws->context_create(svgascreen->sws);
    if(!svga->swc)
-      goto error2;
+      goto no_swc;
 
    svga_init_blend_functions(svga);
    svga_init_blit_functions(svga);
@@ -165,32 +169,40 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
    svga->debug.disable_shader = debug_get_num_option("SVGA_DISABLE_SHADER", ~0);
 
    if (!svga_init_swtnl(svga))
-      goto error3;
+      goto no_swtnl;
+
+   svga->fs_bm = util_bitmask_create();
+   if (svga->fs_bm == NULL)
+      goto no_fs_bm;
+
+   svga->vs_bm = util_bitmask_create();
+   if (svga->vs_bm == NULL)
+      goto no_vs_bm;
 
    svga->upload_ib = u_upload_create( svga->pipe.screen,
                                       32 * 1024,
                                       16,
                                       PIPE_BUFFER_USAGE_INDEX );
    if (svga->upload_ib == NULL)
-      goto error4;
+      goto no_upload_ib;
 
    svga->upload_vb = u_upload_create( svga->pipe.screen,
                                       128 * 1024,
                                       16,
                                       PIPE_BUFFER_USAGE_VERTEX );
    if (svga->upload_vb == NULL)
-      goto error5;
+      goto no_upload_vb;
 
    svga->hwtnl = svga_hwtnl_create( svga,
                                     svga->upload_ib,
                                     svga->swc );
    if (svga->hwtnl == NULL)
-      goto error6;
+      goto no_hwtnl;
 
 
    ret = svga_emit_initial_state( svga );
    if (ret)
-      goto error7;
+      goto no_state;
    
    /* Avoid shortcircuiting state with initial value of zero.
     */
@@ -209,19 +221,23 @@ struct pipe_context *svga_context_create( struct pipe_screen *screen )
 
    return &svga->pipe;
 
-error7:
+no_state:
    svga_hwtnl_destroy( svga->hwtnl );
-error6:
+no_hwtnl:
    u_upload_destroy( svga->upload_vb );
-error5:
+no_upload_vb:
    u_upload_destroy( svga->upload_ib );
-error4:
+no_upload_ib:
+   util_bitmask_destroy( svga->vs_bm );
+no_vs_bm:
+   util_bitmask_destroy( svga->fs_bm );
+no_fs_bm:
    svga_destroy_swtnl(svga);
-error3:
+no_swtnl:
    svga->swc->destroy(svga->swc);
-error2:
+no_swc:
    FREE(svga);
-error1:
+no_svga:
    return NULL;
 }
 
diff --git a/src/gallium/drivers/svga/svga_context.h b/src/gallium/drivers/svga/svga_context.h
index e650a25..32e9304 100644
--- a/src/gallium/drivers/svga/svga_context.h
+++ b/src/gallium/drivers/svga/svga_context.h
@@ -41,6 +41,7 @@
 struct draw_vertex_shader;
 struct svga_shader_result;
 struct SVGACmdMemory;
+struct util_bitmask;
 struct u_upload_mgr;
 
 
@@ -267,8 +268,6 @@ struct svga_hw_draw_state
    unsigned ts[16][TS_MAX];
    float cb[PIPE_SHADER_TYPES][CB_MAX][4];
 
-   unsigned shader_id[PIPE_SHADER_TYPES];
-   
    struct svga_shader_result *fs;
    struct svga_shader_result *vs;
    struct svga_hw_view_state views[PIPE_MAX_SAMPLERS];
@@ -321,12 +320,14 @@ struct svga_context
       boolean new_vdecl;
    } swtnl;
 
+   /* Bitmask of used shader IDs */
+   struct util_bitmask *fs_bm;
+   struct util_bitmask *vs_bm;
+
    struct {
       unsigned dirty[4];
 
       unsigned texture_timestamp;
-      unsigned next_fs_id;
-      unsigned next_vs_id;
 
       /* Internally generated shaders:
        */
diff --git a/src/gallium/drivers/svga/svga_draw.c b/src/gallium/drivers/svga/svga_draw.c
index 8db40d0..ca73cf9 100644
--- a/src/gallium/drivers/svga/svga_draw.c
+++ b/src/gallium/drivers/svga/svga_draw.c
@@ -164,7 +164,8 @@ svga_hwtnl_flush( struct svga_hwtnl *hwtnl )
       }
 
       SVGA_DBG(DEBUG_DMA, "draw to sid %p, %d prims\n",
-               svga_surface(svga->curr.framebuffer.cbufs[0])->handle,
+               svga->curr.framebuffer.cbufs[0] ?
+               svga_surface(svga->curr.framebuffer.cbufs[0])->handle : NULL,
                hwtnl->cmd.prim_count);
 
       ret = SVGA3D_BeginDrawPrimitives(swc, 
diff --git a/src/gallium/drivers/svga/svga_draw_arrays.c b/src/gallium/drivers/svga/svga_draw_arrays.c
index 75492df..6b6ebc9 100644
--- a/src/gallium/drivers/svga/svga_draw_arrays.c
+++ b/src/gallium/drivers/svga/svga_draw_arrays.c
@@ -26,7 +26,6 @@
 #include "svga_cmd.h"
 
 #include "pipe/p_inlines.h"
-#include "util/u_prim.h"
 #include "indices/u_indices.h"
 
 #include "svga_hw_reg.h"
diff --git a/src/gallium/drivers/svga/svga_draw_elements.c b/src/gallium/drivers/svga/svga_draw_elements.c
index 167d817..022b444 100644
--- a/src/gallium/drivers/svga/svga_draw_elements.c
+++ b/src/gallium/drivers/svga/svga_draw_elements.c
@@ -24,7 +24,6 @@
  **********************************************************/
 
 #include "pipe/p_inlines.h"
-#include "util/u_prim.h"
 #include "util/u_upload_mgr.h"
 #include "indices/u_indices.h"
 
diff --git a/src/gallium/drivers/svga/svga_pipe_blend.c b/src/gallium/drivers/svga/svga_pipe_blend.c
index 855d228..3ad3f97 100644
--- a/src/gallium/drivers/svga/svga_pipe_blend.c
+++ b/src/gallium/drivers/svga/svga_pipe_blend.c
@@ -29,7 +29,6 @@
 #include "util/u_memory.h"
 
 #include "svga_context.h"
-#include "svga_state.h"
 
 #include "svga_hw_reg.h"
 
diff --git a/src/gallium/drivers/svga/svga_pipe_constants.c b/src/gallium/drivers/svga/svga_pipe_constants.c
index 10e7a12..a6dc344 100644
--- a/src/gallium/drivers/svga/svga_pipe_constants.c
+++ b/src/gallium/drivers/svga/svga_pipe_constants.c
@@ -30,9 +30,6 @@
 #include "tgsi/tgsi_parse.h"
 
 #include "svga_context.h"
-#include "svga_state.h"
-#include "svga_hw_reg.h"
-#include "svga_cmd.h"
 
 /***********************************************************************
  * Constant buffers 
diff --git a/src/gallium/drivers/svga/svga_pipe_depthstencil.c b/src/gallium/drivers/svga/svga_pipe_depthstencil.c
index df636c0..34e60cb 100644
--- a/src/gallium/drivers/svga/svga_pipe_depthstencil.c
+++ b/src/gallium/drivers/svga/svga_pipe_depthstencil.c
@@ -29,7 +29,6 @@
 #include "util/u_memory.h"
 
 #include "svga_context.h"
-#include "svga_state.h"
 #include "svga_hw_reg.h"
 
 
diff --git a/src/gallium/drivers/svga/svga_pipe_draw.c b/src/gallium/drivers/svga/svga_pipe_draw.c
index 71a5528..719b341 100644
--- a/src/gallium/drivers/svga/svga_pipe_draw.c
+++ b/src/gallium/drivers/svga/svga_pipe_draw.c
@@ -33,7 +33,6 @@
 #include "svga_hw_reg.h"
 #include "svga_context.h"
 #include "svga_screen.h"
-#include "svga_winsys.h"
 #include "svga_draw.h"
 #include "svga_state.h"
 #include "svga_swtnl.h"
diff --git a/src/gallium/drivers/svga/svga_pipe_flush.c b/src/gallium/drivers/svga/svga_pipe_flush.c
index 0becb07..3eb1033 100644
--- a/src/gallium/drivers/svga/svga_pipe_flush.c
+++ b/src/gallium/drivers/svga/svga_pipe_flush.c
@@ -28,13 +28,8 @@
 #include "svga_screen_texture.h"
 #include "svga_context.h"
 #include "svga_winsys.h"
-#include "svga_draw.h"
 #include "svga_debug.h"
 
-#include "svga_hw_reg.h"
-
-
-
 
 static void svga_flush( struct pipe_context *pipe,
                         unsigned flags,
diff --git a/src/gallium/drivers/svga/svga_pipe_fs.c b/src/gallium/drivers/svga/svga_pipe_fs.c
index e3be840..32f07fb 100644
--- a/src/gallium/drivers/svga/svga_pipe_fs.c
+++ b/src/gallium/drivers/svga/svga_pipe_fs.c
@@ -26,16 +26,15 @@
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "tgsi/tgsi_parse.h"
 #include "tgsi/tgsi_text.h"
 
 #include "svga_screen.h"
 #include "svga_context.h"
-#include "svga_state.h"
 #include "svga_tgsi.h"
 #include "svga_hw_reg.h"
 #include "svga_cmd.h"
-#include "svga_draw.h"
 #include "svga_debug.h"
 
 
@@ -107,7 +106,16 @@ void svga_delete_fs_state(struct pipe_context *pipe, void *shader)
          assert(ret == PIPE_OK);
       }
 
+      util_bitmask_clear( svga->fs_bm, result->id );
+
       svga_destroy_shader_result( result );
+
+      /*
+       * Remove stale references to this result to ensure a new result on the
+       * same address will be detected as a change.
+       */
+      if(result == svga->state.hw_draw.fs)
+         svga->state.hw_draw.fs = NULL;
    }
 
    FREE((void *)fs->base.tokens);
diff --git a/src/gallium/drivers/svga/svga_pipe_misc.c b/src/gallium/drivers/svga/svga_pipe_misc.c
index 58cb1e6..8cf1f2e 100644
--- a/src/gallium/drivers/svga/svga_pipe_misc.c
+++ b/src/gallium/drivers/svga/svga_pipe_misc.c
@@ -27,12 +27,6 @@
 
 #include "svga_context.h"
 #include "svga_screen_texture.h"
-#include "svga_state.h"
-#include "svga_winsys.h"
-
-#include "svga_hw_reg.h"
-
-
 
 
 static void svga_set_scissor_state( struct pipe_context *pipe,
diff --git a/src/gallium/drivers/svga/svga_pipe_query.c b/src/gallium/drivers/svga/svga_pipe_query.c
index 01336b0..08283e3 100644
--- a/src/gallium/drivers/svga/svga_pipe_query.c
+++ b/src/gallium/drivers/svga/svga_pipe_query.c
@@ -32,7 +32,6 @@
 #include "svga_screen.h"
 #include "svga_screen_buffer.h"
 #include "svga_winsys.h"
-#include "svga_draw.h"
 #include "svga_debug.h"
 
 
diff --git a/src/gallium/drivers/svga/svga_pipe_rasterizer.c b/src/gallium/drivers/svga/svga_pipe_rasterizer.c
index b03f8eb..9ea11aa 100644
--- a/src/gallium/drivers/svga/svga_pipe_rasterizer.c
+++ b/src/gallium/drivers/svga/svga_pipe_rasterizer.c
@@ -30,7 +30,6 @@
 #include "util/u_memory.h"
 
 #include "svga_context.h"
-#include "svga_state.h"
 
 #include "svga_hw_reg.h"
 
diff --git a/src/gallium/drivers/svga/svga_pipe_sampler.c b/src/gallium/drivers/svga/svga_pipe_sampler.c
index 3eeca6b..9cc69c8 100644
--- a/src/gallium/drivers/svga/svga_pipe_sampler.c
+++ b/src/gallium/drivers/svga/svga_pipe_sampler.c
@@ -32,9 +32,6 @@
 
 #include "svga_context.h"
 #include "svga_screen_texture.h"
-#include "svga_state.h"
-
-#include "svga_hw_reg.h"
 
 #include "svga_debug.h"
 
diff --git a/src/gallium/drivers/svga/svga_pipe_vertex.c b/src/gallium/drivers/svga/svga_pipe_vertex.c
index 28e2787..87ac923 100644
--- a/src/gallium/drivers/svga/svga_pipe_vertex.c
+++ b/src/gallium/drivers/svga/svga_pipe_vertex.c
@@ -32,10 +32,6 @@
 #include "svga_screen.h"
 #include "svga_screen_buffer.h"
 #include "svga_context.h"
-#include "svga_state.h"
-#include "svga_winsys.h"
-
-#include "svga_hw_reg.h"
 
 
 static void svga_set_vertex_buffers(struct pipe_context *pipe,
diff --git a/src/gallium/drivers/svga/svga_pipe_vs.c b/src/gallium/drivers/svga/svga_pipe_vs.c
index e5ffe66..7f2b2bc 100644
--- a/src/gallium/drivers/svga/svga_pipe_vs.c
+++ b/src/gallium/drivers/svga/svga_pipe_vs.c
@@ -27,12 +27,12 @@
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 #include "tgsi/tgsi_parse.h"
 #include "tgsi/tgsi_text.h"
 
 #include "svga_screen.h"
 #include "svga_context.h"
-#include "svga_state.h"
 #include "svga_tgsi.h"
 #include "svga_hw_reg.h"
 #include "svga_cmd.h"
@@ -172,7 +172,16 @@ static void svga_delete_vs_state(struct pipe_context *pipe, void *shader)
          assert(ret == PIPE_OK);
       }
 
+      util_bitmask_clear( svga->vs_bm, result->id );
+
       svga_destroy_shader_result( result );
+
+      /*
+       * Remove stale references to this result to ensure a new result on the
+       * same address will be detected as a change.
+       */
+      if(result == svga->state.hw_draw.vs)
+         svga->state.hw_draw.vs = NULL;
    }
 
    FREE((void *)vs->base.tokens);
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index fc1b3c9..cd1ed7b 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -33,10 +33,8 @@
 #include "svga_screen.h"
 #include "svga_screen_texture.h"
 #include "svga_screen_buffer.h"
-#include "svga_cmd.h"
 #include "svga_debug.h"
 
-#include "svga_hw_reg.h"
 #include "svga3d_shaderdefs.h"
 
 
@@ -393,8 +391,6 @@ svga_screen_create(struct svga_winsys_screen *sws)
    pipe_mutex_init(svgascreen->tex_mutex);
    pipe_mutex_init(svgascreen->swc_mutex);
 
-   LIST_INITHEAD(&svgascreen->cached_buffers);
-   
    svga_screen_cache_init(svgascreen);
 
    return screen;
diff --git a/src/gallium/drivers/svga/svga_screen.h b/src/gallium/drivers/svga/svga_screen.h
index b94ca7f..a009b60 100644
--- a/src/gallium/drivers/svga/svga_screen.h
+++ b/src/gallium/drivers/svga/svga_screen.h
@@ -68,12 +68,6 @@ struct svga_screen
    pipe_mutex tex_mutex; 
    pipe_mutex swc_mutex; /* Protects the use of swc and dirty_buffers */
    
-   /** 
-    * List of buffers with cached GMR. Ordered from the most recently used to
-    * the least recently used 
-    */
-   struct list_head cached_buffers;
-   
    struct svga_host_surface_cache cache;
 };
 
diff --git a/src/gallium/drivers/svga/svga_screen_buffer.c b/src/gallium/drivers/svga/svga_screen_buffer.c
index 1f8a889..719adde 100644
--- a/src/gallium/drivers/svga/svga_screen_buffer.c
+++ b/src/gallium/drivers/svga/svga_screen_buffer.c
@@ -113,68 +113,9 @@ svga_buffer_destroy_hw_storage(struct svga_screen *ss, struct svga_buffer *sbuf)
    if(sbuf->hw.buf) {
       sws->buffer_destroy(sws, sbuf->hw.buf);
       sbuf->hw.buf = NULL;
-      assert(sbuf->head.prev && sbuf->head.next);
-      LIST_DEL(&sbuf->head);
-#ifdef DEBUG
-      sbuf->head.next = sbuf->head.prev = NULL; 
-#endif
    }
 }
 
-static INLINE enum pipe_error
-svga_buffer_backup(struct svga_screen *ss, struct svga_buffer *sbuf)
-{
-   if (sbuf->hw.buf && sbuf->hw.num_ranges) {
-      void *src;
-
-      if (!sbuf->swbuf)
-	 sbuf->swbuf = align_malloc(sbuf->base.size, sbuf->base.alignment);
-      if (!sbuf->swbuf)
-	 return PIPE_ERROR_OUT_OF_MEMORY;
-
-      src = ss->sws->buffer_map(ss->sws, sbuf->hw.buf,
-				PIPE_BUFFER_USAGE_CPU_READ);
-      if (!src)
-	 return PIPE_ERROR;
-
-      memcpy(sbuf->swbuf, src, sbuf->base.size);
-      ss->sws->buffer_unmap(ss->sws, sbuf->hw.buf);
-   }
-
-   return PIPE_OK;
-}
-
-/**
- * Try to make GMR space available by freeing the hardware storage of 
- * unmapped
- */
-boolean
-svga_buffer_free_cached_hw_storage(struct svga_screen *ss)
-{
-   struct list_head *curr;
-   struct svga_buffer *sbuf;
-   enum pipe_error ret = PIPE_OK;
-
-   curr = ss->cached_buffers.prev;
-   
-   /* free the least recently used buffer's hw storage which is not mapped */
-   do {
-      if(curr == &ss->cached_buffers)
-         return FALSE;
-
-      sbuf = LIST_ENTRY(struct svga_buffer, curr, head);
-      
-      curr = curr->prev;
-      if (sbuf->map.count == 0)
-	 ret = svga_buffer_backup(ss, sbuf);
-
-   } while(sbuf->map.count != 0 || ret != PIPE_OK);
-   
-   svga_buffer_destroy_hw_storage(ss, sbuf);
-   
-   return TRUE;
-}
-
 struct svga_winsys_buffer *
 svga_winsys_buffer_create( struct svga_screen *ss,
                            unsigned alignment, 
@@ -195,12 +136,6 @@ svga_winsys_buffer_create( struct svga_screen *ss,
       svga_screen_flush(ss, NULL);
       buf = sws->buffer_create(sws, alignment, usage, size);
 
-      SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "evicting buffers to find %d bytes GMR\n", 
-               size);
-
-      /* Try evicing all buffer storage */
-      while(!buf && svga_buffer_free_cached_hw_storage(ss))
-         buf = sws->buffer_create(sws, alignment, usage, size);
    }
    
    return buf;
@@ -226,8 +161,6 @@ svga_buffer_create_hw_storage(struct svga_screen *ss,
          return PIPE_ERROR_OUT_OF_MEMORY;
       
       assert(!sbuf->needs_flush);
-      assert(!sbuf->head.prev && !sbuf->head.next);
-      LIST_ADD(&sbuf->head, &ss->cached_buffers);
    }
    
    return PIPE_OK;
@@ -311,7 +244,6 @@ static void
 svga_buffer_upload_flush(struct svga_context *svga,
                          struct svga_buffer *sbuf)
 {
-   struct svga_screen *ss = svga_screen(svga->pipe.screen);
    SVGA3dCopyBox *boxes;
    unsigned i;
 
@@ -348,13 +280,16 @@ svga_buffer_upload_flush(struct svga_context *svga,
 
    assert(sbuf->head.prev && sbuf->head.next);
    LIST_DEL(&sbuf->head);
+#ifdef DEBUG
+   sbuf->head.next = sbuf->head.prev = NULL; 
+#endif
    sbuf->needs_flush = FALSE;
-   /* XXX: do we care about cached_buffers any more ?*/
-   LIST_ADD(&sbuf->head, &ss->cached_buffers);
 
    sbuf->hw.svga = NULL;
    sbuf->hw.boxes = NULL;
 
+   sbuf->host_written = TRUE;
+
    /* Decrement reference count */
    pipe_buffer_reference((struct pipe_buffer **)&sbuf, NULL);
 }
@@ -436,17 +371,17 @@ svga_buffer_map_range( struct pipe_screen *screen,
    }
    else {
       if(!sbuf->hw.buf) {
-         struct svga_winsys_surface *handle = sbuf->handle;
-
          if(svga_buffer_create_hw_storage(ss, sbuf) != PIPE_OK)
             return NULL;
          
          /* Populate the hardware storage if the host surface pre-existed */
-         if((usage & PIPE_BUFFER_USAGE_CPU_READ) && handle) {
+         if(sbuf->host_written) {
             SVGA3dSurfaceDMAFlags flags;
             enum pipe_error ret;
             struct pipe_fence_handle *fence = NULL;
             
+            assert(sbuf->handle);
+
             SVGA_DBG(DEBUG_DMA|DEBUG_PERF, "dma from sid %p (buffer), bytes %u - %u\n", 
                      sbuf->handle, 0, sbuf->base.size);
 
@@ -477,17 +412,6 @@ svga_buffer_map_range( struct pipe_screen *screen,
             sws->fence_reference(sws, &fence, NULL);
          }
       }
-      else {
-         if((usage & PIPE_BUFFER_USAGE_CPU_READ) && !sbuf->needs_flush) {
-            /* We already had the hardware storage but we would have to issue
-             * a download if we hadn't, so move the buffer to the begginning
-             * of the LRU list.
-             */
-            assert(sbuf->head.prev && sbuf->head.next);
-            LIST_DEL(&sbuf->head);
-            LIST_ADD(&sbuf->head, &ss->cached_buffers);
-         }
-      }
          
       map = sws->buffer_map(sws, sbuf->hw.buf, usage);
    }
@@ -571,10 +495,8 @@ svga_buffer_destroy( struct pipe_buffer *buf )
    
    assert(!sbuf->needs_flush);
 
-   if(sbuf->handle) {
-      SVGA_DBG(DEBUG_DMA, "release sid %p sz %d\n", sbuf->handle, sbuf->base.size);
-      svga_screen_surface_destroy(ss, &sbuf->key, &sbuf->handle);
-   }
+   if(sbuf->handle)
+      svga_buffer_destroy_host_surface(ss, sbuf);
    
    if(sbuf->hw.buf)
       svga_buffer_destroy_hw_storage(ss, sbuf);
@@ -594,6 +516,9 @@ svga_buffer_create(struct pipe_screen *screen,
    struct svga_screen *ss = svga_screen(screen);
    struct svga_buffer *sbuf;
    
+   assert(size);
+   assert(alignment);
+
    sbuf = CALLOC_STRUCT(svga_buffer);
    if(!sbuf)
       goto error1;
@@ -754,8 +679,7 @@ svga_buffer_handle(struct svga_context *svga,
       assert(sbuf->hw.svga == svga);
 
       sbuf->needs_flush = TRUE;
-      assert(sbuf->head.prev && sbuf->head.next);
-      LIST_DEL(&sbuf->head);
+      assert(!sbuf->head.prev && !sbuf->head.next);
       LIST_ADDTAIL(&sbuf->head, &svga->dirty_buffers);
    }
 
diff --git a/src/gallium/drivers/svga/svga_screen_buffer.h b/src/gallium/drivers/svga/svga_screen_buffer.h
index 5d7af5a..448ac10 100644
--- a/src/gallium/drivers/svga/svga_screen_buffer.h
+++ b/src/gallium/drivers/svga/svga_screen_buffer.h
@@ -135,6 +135,11 @@ struct svga_buffer
     */
    struct svga_winsys_surface *handle;
    
+   /**
+    * Whether the host has been ever written.
+    */
+   boolean host_written;
+
    struct {
       unsigned count;
       boolean writing;
@@ -178,9 +183,6 @@ svga_buffer_handle(struct svga_context *svga,
 void
 svga_context_flush_buffers(struct svga_context *svga);
 
-boolean
-svga_buffer_free_cached_hw_storage(struct svga_screen *ss);
-
 struct svga_winsys_buffer *
 svga_winsys_buffer_create(struct svga_screen *ss,
                           unsigned alignment, 
diff --git a/src/gallium/drivers/svga/svga_screen_texture.c b/src/gallium/drivers/svga/svga_screen_texture.c
index 1eb03db..9ad4eda 100644
--- a/src/gallium/drivers/svga/svga_screen_texture.c
+++ b/src/gallium/drivers/svga/svga_screen_texture.c
@@ -308,11 +308,19 @@ svga_texture_create(struct pipe_screen *screen,
       tex->key.numFaces = 1;
    }
 
+   tex->key.cachable = 1;
+
    if(templat->tex_usage & PIPE_TEXTURE_USAGE_SAMPLER)
       tex->key.flags |= SVGA3D_SURFACE_HINT_TEXTURE;
 
-   if(templat->tex_usage & PIPE_TEXTURE_USAGE_PRIMARY)
+   if(templat->tex_usage & PIPE_TEXTURE_USAGE_DISPLAY_TARGET) {
+      tex->key.cachable = 0;
+   }
+
+   if(templat->tex_usage & PIPE_TEXTURE_USAGE_PRIMARY) {
       tex->key.flags |= SVGA3D_SURFACE_HINT_SCANOUT;
+      tex->key.cachable = 0;
+   }
    
    /* 
     * XXX: Never pass the SVGA3D_SURFACE_HINT_RENDERTARGET hint. Mesa cannot
@@ -335,8 +343,6 @@ svga_texture_create(struct pipe_screen *screen,
    if(tex->key.format == SVGA3D_FORMAT_INVALID)
       goto error2;
 
-   tex->key.cachable = 1;
-   
    SVGA_DBG(DEBUG_DMA, "surface_create for texture\n", tex->handle);
    tex->handle = svga_screen_surface_create(svgascreen, &tex->key);
    if (tex->handle)
@@ -418,6 +424,62 @@ svga_texture_blanket(struct pipe_screen * screen,
 }
 
 
+struct pipe_texture *
+svga_screen_texture_wrap_surface(struct pipe_screen *screen,
+				 struct pipe_texture *base,
+				 enum SVGA3dSurfaceFormat format,
+				 struct svga_winsys_surface *srf)
+{
+   struct svga_texture *tex;
+   assert(screen);
+
+   /* Only supports one type */
+   if (base->target != PIPE_TEXTURE_2D ||
+       base->last_level != 0 ||
+       base->depth[0] != 1) {
+      return NULL;
+   }
+
+   if (!srf)
+      return NULL;
+
+   if (svga_translate_format(base->format) != format) {
+      unsigned f1 = svga_translate_format(base->format);
+      unsigned f2 = format;
+
+      /* It's okay for XRGB and ARGB or depth with/out stencil to get mixed up */
+      if ( !( (f1 == SVGA3D_X8R8G8B8 && f2 == SVGA3D_A8R8G8B8) ||
+              (f1 == SVGA3D_A8R8G8B8 && f2 == SVGA3D_X8R8G8B8) ||
+              (f1 == SVGA3D_Z_D24X8 && f2 == SVGA3D_Z_D24S8) ) ) {
+         debug_printf("%s wrong format %u != %u\n", __FUNCTION__, f1, f2);
+         return NULL;
+      }
+   }
+
+   tex = CALLOC_STRUCT(svga_texture);
+   if (!tex)
+      return NULL;
+
+   tex->base = *base;
+   
+
+   if (format == 1)
+      tex->base.format = PIPE_FORMAT_X8R8G8B8_UNORM;
+   else if (format == 2)
+      tex->base.format = PIPE_FORMAT_A8R8G8B8_UNORM;
+
+   pipe_reference_init(&tex->base.reference, 1);
+   tex->base.screen = screen;
+
+   SVGA_DBG(DEBUG_DMA, "wrap surface sid %p\n", srf);
+
+   tex->key.cachable = 0;
+   tex->handle = srf;
+
+   return &tex->base;
+}
+
+
 static void
 svga_texture_destroy(struct pipe_texture *pt)
 {
diff --git a/src/gallium/drivers/svga/svga_state_framebuffer.c b/src/gallium/drivers/svga/svga_state_framebuffer.c
index cfdcae4..eda1aef 100644
--- a/src/gallium/drivers/svga/svga_state_framebuffer.c
+++ b/src/gallium/drivers/svga/svga_state_framebuffer.c
@@ -32,8 +32,6 @@
 #include "svga_cmd.h"
 #include "svga_debug.h"
 
-#include "svga_hw_reg.h"
-
 
 /***********************************************************************
  * Hardware state update
diff --git a/src/gallium/drivers/svga/svga_state_fs.c b/src/gallium/drivers/svga/svga_state_fs.c
index 6ec38ed..4fe9141 100644
--- a/src/gallium/drivers/svga/svga_state_fs.c
+++ b/src/gallium/drivers/svga/svga_state_fs.c
@@ -26,6 +26,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_defines.h"
 #include "util/u_math.h"
+#include "util/u_bitmask.h"
 
 #include "svga_context.h"
 #include "svga_state.h"
@@ -66,7 +67,7 @@ static enum pipe_error compile_fs( struct svga_context *svga,
                                    struct svga_shader_result **out_result )
 {
    struct svga_shader_result *result;
-   enum pipe_error ret;
+   enum pipe_error ret = PIPE_ERROR;
 
    result = svga_translate_fragment_program( fs, key );
    if (result == NULL) {
@@ -74,9 +75,14 @@ static enum pipe_error compile_fs( struct svga_context *svga,
       goto fail;
    }
 
+   result->id = util_bitmask_add(svga->fs_bm);
+   if(result->id == UTIL_BITMASK_INVALID_INDEX) {
+      ret = PIPE_ERROR_OUT_OF_MEMORY;
+      goto fail;
+   }
 
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_fs_id,
+                             result->id,
                              SVGA3D_SHADERTYPE_PS,
                              result->tokens, 
                              result->nr_tokens * sizeof result->tokens[0]);
@@ -84,14 +90,16 @@ static enum pipe_error compile_fs( struct svga_context *svga,
       goto fail;
 
    *out_result = result;
-   result->id = svga->state.next_fs_id++;
    result->next = fs->base.results;
    fs->base.results = result;
    return PIPE_OK;
 
 fail:
-   if (result)
+   if (result) {
+      if (result->id != UTIL_BITMASK_INVALID_INDEX)
+         util_bitmask_clear( svga->fs_bm, result->id );
       svga_destroy_shader_result( result );
+   }
    return ret;
 }
 
@@ -116,7 +124,7 @@ fail:
  */
 static int emit_white_fs( struct svga_context *svga )
 {
-   int ret;
+   int ret = PIPE_ERROR;
 
    /* ps_3_0
     * def c0, 1.000000, 0.000000, 0.000000, 1.000000
@@ -137,16 +145,26 @@ static int emit_white_fs( struct svga_context *svga )
       0x0000ffff,
    };
 
+   assert(SVGA3D_INVALID_ID == UTIL_BITMASK_INVALID_INDEX);
+   svga->state.white_fs_id = util_bitmask_add(svga->fs_bm);
+   if(svga->state.white_fs_id == SVGA3D_INVALID_ID)
+      goto no_fs_id;
+
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_fs_id,
+                             svga->state.white_fs_id,
                              SVGA3D_SHADERTYPE_PS,
                              white_tokens, 
                              sizeof(white_tokens));
    if (ret)
-      return ret;
+      goto no_definition;
 
-   svga->state.white_fs_id = svga->state.next_fs_id++;
    return 0;
+
+no_definition:
+   util_bitmask_clear(svga->fs_bm, svga->state.white_fs_id);
+   svga->state.white_fs_id = SVGA3D_INVALID_ID;
+no_fs_id:
+   return ret;
 }
 
 
@@ -251,15 +269,14 @@ static int emit_hw_fs( struct svga_context *svga,
 
    assert(id != SVGA3D_INVALID_ID);
 
-   if (id != svga->state.hw_draw.shader_id[PIPE_SHADER_FRAGMENT]) {
-      ret = SVGA3D_SetShader(svga->swc, 
-                             SVGA3D_SHADERTYPE_PS, 
+   if (result != svga->state.hw_draw.fs) {
+      ret = SVGA3D_SetShader(svga->swc,
+                             SVGA3D_SHADERTYPE_PS,
                              id );
       if (ret)
          return ret;
 
       svga->dirty |= SVGA_NEW_FS_RESULT;
-      svga->state.hw_draw.shader_id[PIPE_SHADER_FRAGMENT] = id;
       svga->state.hw_draw.fs = result;      
    }
 
diff --git a/src/gallium/drivers/svga/svga_state_rss.c b/src/gallium/drivers/svga/svga_state_rss.c
index 8b6803a..2f9adae 100644
--- a/src/gallium/drivers/svga/svga_state_rss.c
+++ b/src/gallium/drivers/svga/svga_state_rss.c
@@ -31,9 +31,6 @@
 #include "svga_state.h"
 #include "svga_cmd.h"
 
-#include "svga_hw_reg.h"
-
-
 
 struct rs_queue {
    unsigned rs_count;
diff --git a/src/gallium/drivers/svga/svga_state_tss.c b/src/gallium/drivers/svga/svga_state_tss.c
index b313794..b3c9687 100644
--- a/src/gallium/drivers/svga/svga_state_tss.c
+++ b/src/gallium/drivers/svga/svga_state_tss.c
@@ -33,8 +33,6 @@
 #include "svga_state.h"
 #include "svga_cmd.h"
 
-#include "svga_hw_reg.h"
-
 
 void svga_cleanup_tss_binding(struct svga_context *svga)
 {
diff --git a/src/gallium/drivers/svga/svga_state_vs.c b/src/gallium/drivers/svga/svga_state_vs.c
index a947745..5e33c12 100644
--- a/src/gallium/drivers/svga/svga_state_vs.c
+++ b/src/gallium/drivers/svga/svga_state_vs.c
@@ -26,6 +26,7 @@
 #include "pipe/p_inlines.h"
 #include "pipe/p_defines.h"
 #include "util/u_math.h"
+#include "util/u_bitmask.h"
 #include "translate/translate.h"
 
 #include "svga_context.h"
@@ -69,7 +70,7 @@ static enum pipe_error compile_vs( struct svga_context *svga,
                                    struct svga_shader_result **out_result )
 {
    struct svga_shader_result *result;
-   enum pipe_error ret = PIPE_OK;
+   enum pipe_error ret = PIPE_ERROR;
 
    result = svga_translate_vertex_program( vs, key );
    if (result == NULL) {
@@ -77,8 +78,14 @@ static enum pipe_error compile_vs( struct svga_context *svga,
       goto fail;
    }
 
+   result->id = util_bitmask_add(svga->vs_bm);
+   if(result->id == UTIL_BITMASK_INVALID_INDEX) {
+      ret = PIPE_ERROR_OUT_OF_MEMORY;
+      goto fail;
+   }
+
    ret = SVGA3D_DefineShader(svga->swc, 
-                             svga->state.next_vs_id,
+                             result->id,
                              SVGA3D_SHADERTYPE_VS,
                              result->tokens, 
                              result->nr_tokens * sizeof result->tokens[0]);
@@ -86,14 +93,16 @@ static enum pipe_error compile_vs( struct svga_context *svga,
       goto fail;
 
    *out_result = result;
-   result->id = svga->state.next_vs_id++;
    result->next = vs->base.results;
    vs->base.results = result;
    return PIPE_OK;
 
 fail:
-   if (result)
+   if (result) {
+      if (result->id != UTIL_BITMASK_INVALID_INDEX)
+         util_bitmask_clear( svga->vs_bm, result->id );
       svga_destroy_shader_result( result );
+   }
    return ret;
 }
 
@@ -141,15 +150,14 @@ static int emit_hw_vs( struct svga_context *svga,
       id = result->id;
    }
 
-   if (id != svga->state.hw_draw.shader_id[PIPE_SHADER_VERTEX]) {
-      ret = SVGA3D_SetShader(svga->swc, 
-                             SVGA3D_SHADERTYPE_VS, 
+   if (result != svga->state.hw_draw.vs) {
+      ret = SVGA3D_SetShader(svga->swc,
+                             SVGA3D_SHADERTYPE_VS,
                              id );
       if (ret)
          return ret;
 
       svga->dirty |= SVGA_NEW_VS_RESULT;
-      svga->state.hw_draw.shader_id[PIPE_SHADER_VERTEX] = id;
       svga->state.hw_draw.vs = result;      
    }
 
diff --git a/src/gallium/drivers/svga/svga_swtnl_backend.c b/src/gallium/drivers/svga/svga_swtnl_backend.c
index b4f757a..aafb3e2 100644
--- a/src/gallium/drivers/svga/svga_swtnl_backend.c
+++ b/src/gallium/drivers/svga/svga_swtnl_backend.c
@@ -31,7 +31,6 @@
 #include "pipe/p_inlines.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
-#include "util/u_simple_shaders.h"
 
 #include "svga_context.h"
 #include "svga_state.h"
@@ -87,13 +86,13 @@ svga_vbuf_render_allocate_vertices( struct vbuf_render *render,
    if (!svga_render->vbuf) {
       svga_render->vbuf_size = MAX2(size, svga_render->vbuf_alloc_size);
       svga_render->vbuf = pipe_buffer_create(screen,
-                                             0,
+                                             16,
                                              PIPE_BUFFER_USAGE_VERTEX,
                                              svga_render->vbuf_size);
       if(!svga_render->vbuf) {
          svga_context_flush(svga, NULL);
          svga_render->vbuf = pipe_buffer_create(screen,
-                                                0,
+                                                16,
                                                 PIPE_BUFFER_USAGE_VERTEX,
                                                 svga_render->vbuf_size);
          assert(svga_render->vbuf);
@@ -123,7 +122,9 @@ svga_vbuf_render_map_vertices( struct vbuf_render *render )
    char *ptr = (char*)pipe_buffer_map(screen,
                                       svga_render->vbuf,
                                       PIPE_BUFFER_USAGE_CPU_WRITE | 
-                                      PIPE_BUFFER_USAGE_FLUSH_EXPLICIT);
+                                      PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
+                                      PIPE_BUFFER_USAGE_DISCARD |
+                                      PIPE_BUFFER_USAGE_UNSYNCHRONIZED);
    return ptr + svga_render->vbuf_offset;
 }
 
@@ -259,14 +260,14 @@ svga_vbuf_render_draw( struct vbuf_render *render,
    if (!svga_render->ibuf) {
       svga_render->ibuf_size = MAX2(size, svga_render->ibuf_alloc_size);
       svga_render->ibuf = pipe_buffer_create(screen,
-                                             0,
+                                             2,
                                              PIPE_BUFFER_USAGE_VERTEX,
                                              svga_render->ibuf_size);
       svga_render->ibuf_offset = 0;
    }
 
-   pipe_buffer_write(screen, svga_render->ibuf,
-                     svga_render->ibuf_offset, 2 * nr_indices, indices);
+   pipe_buffer_write_nooverlap(screen, svga_render->ibuf,
+                                 svga_render->ibuf_offset, 2 * nr_indices, indices);
 
 
    /* off to hardware */
diff --git a/src/gallium/drivers/svga/svga_swtnl_draw.c b/src/gallium/drivers/svga/svga_swtnl_draw.c
index 8b14c91..6729cc7 100644
--- a/src/gallium/drivers/svga/svga_swtnl_draw.c
+++ b/src/gallium/drivers/svga/svga_swtnl_draw.c
@@ -27,7 +27,6 @@
 #include "draw/draw_vbuf.h"
 #include "pipe/p_inlines.h"
 #include "pipe/p_state.h"
-#include "util/u_memory.h"
 
 #include "svga_context.h"
 #include "svga_swtnl.h"
diff --git a/src/gallium/drivers/svga/svga_swtnl_state.c b/src/gallium/drivers/svga/svga_swtnl_state.c
index 1616312..d57ed82 100644
--- a/src/gallium/drivers/svga/svga_swtnl_state.c
+++ b/src/gallium/drivers/svga/svga_swtnl_state.c
@@ -27,7 +27,6 @@
 #include "draw/draw_vbuf.h"
 #include "pipe/p_inlines.h"
 #include "pipe/p_state.h"
-#include "util/u_memory.h"
 
 #include "svga_context.h"
 #include "svga_swtnl.h"
diff --git a/src/gallium/drivers/svga/svga_tgsi.c b/src/gallium/drivers/svga/svga_tgsi.c
index b8ef137..0cd6201 100644
--- a/src/gallium/drivers/svga/svga_tgsi.c
+++ b/src/gallium/drivers/svga/svga_tgsi.c
@@ -31,6 +31,7 @@
 #include "tgsi/tgsi_dump.h"
 #include "tgsi/tgsi_scan.h"
 #include "util/u_memory.h"
+#include "util/u_bitmask.h"
 
 #include "svgadump/svga_shader_dump.h"
 
@@ -221,6 +222,7 @@ svga_tgsi_translate( const struct svga_shader *shader,
    result->tokens = (const unsigned *)emit.buf;
    result->nr_tokens = (emit.ptr - emit.buf) / sizeof(unsigned);
    memcpy(&result->key, &key, sizeof key);
+   result->id = UTIL_BITMASK_INVALID_INDEX;
 
    if (SVGA_DEBUG & DEBUG_TGSI) 
    {
diff --git a/src/gallium/drivers/svga/svga_tgsi_decl_sm20.c b/src/gallium/drivers/svga/svga_tgsi_decl_sm20.c
index 5445708..0c34301 100644
--- a/src/gallium/drivers/svga/svga_tgsi_decl_sm20.c
+++ b/src/gallium/drivers/svga/svga_tgsi_decl_sm20.c
@@ -29,9 +29,6 @@
 #include "util/u_memory.h"
 
 #include "svga_tgsi_emit.h"
-#include "svga_context.h"
-
-
 
 
 static boolean ps20_input( struct svga_shader_emitter *emit,
diff --git a/src/gallium/drivers/svga/svga_tgsi_decl_sm30.c b/src/gallium/drivers/svga/svga_tgsi_decl_sm30.c
index 08e7dfb..2291cf1 100644
--- a/src/gallium/drivers/svga/svga_tgsi_decl_sm30.c
+++ b/src/gallium/drivers/svga/svga_tgsi_decl_sm30.c
@@ -29,7 +29,6 @@
 #include "util/u_memory.h"
 
 #include "svga_tgsi_emit.h"
-#include "svga_context.h"
 
 static boolean translate_vs_ps_semantic( struct tgsi_declaration_semantic semantic,
                                          unsigned *usage,
diff --git a/src/gallium/drivers/svga/svga_winsys.h b/src/gallium/drivers/svga/svga_winsys.h
index 59f299c..27b99fe 100644
--- a/src/gallium/drivers/svga/svga_winsys.h
+++ b/src/gallium/drivers/svga/svga_winsys.h
@@ -296,4 +296,10 @@ svga_screen_buffer_from_texture(struct pipe_texture *texture,
 				struct pipe_buffer **buffer,
 				unsigned *stride);
 
+struct pipe_texture *
+svga_screen_texture_wrap_surface(struct pipe_screen *screen,
+				 struct pipe_texture *base,
+				 enum SVGA3dSurfaceFormat format,
+				 struct svga_winsys_surface *srf);
+
 #endif /* SVGA_WINSYS_H_ */
diff --git a/src/gallium/drivers/trace/tr_context.c b/src/gallium/drivers/trace/tr_context.c
index bf470b4..540855c 100644
--- a/src/gallium/drivers/trace/tr_context.c
+++ b/src/gallium/drivers/trace/tr_context.c
@@ -52,6 +52,7 @@ trace_buffer_unwrap(struct trace_context *tr_ctx,
 
    assert(tr_buf->buffer);
    assert(tr_buf->buffer->screen == tr_scr->screen);
+   (void) tr_scr;
    return tr_buf->buffer;
 }
 
@@ -90,6 +91,7 @@ trace_surface_unwrap(struct trace_context *tr_ctx,
 
    assert(tr_surf->surface);
    assert(tr_surf->surface->texture->screen == tr_scr->screen);
+   (void) tr_scr;
    return tr_surf->surface;
 }
 
diff --git a/src/gallium/drivers/trace/tr_drm.c b/src/gallium/drivers/trace/tr_drm.c
index 48d1c40..e7ca3a8 100644
--- a/src/gallium/drivers/trace/tr_drm.c
+++ b/src/gallium/drivers/trace/tr_drm.c
@@ -173,6 +173,7 @@ trace_drm_create(struct drm_api *api)
    if (!tr_api)
       goto error;
 
+   tr_api->base.driver_name = api->driver_name;
    tr_api->base.create_screen = trace_drm_create_screen;
    tr_api->base.create_context = trace_drm_create_context;
    tr_api->base.texture_from_shared_handle = trace_drm_texture_from_shared_handle;
diff --git a/src/gallium/drivers/trace/tr_dump.c b/src/gallium/drivers/trace/tr_dump.c
index 7e2ccbc..0f45e21 100644
--- a/src/gallium/drivers/trace/tr_dump.c
+++ b/src/gallium/drivers/trace/tr_dump.c
@@ -40,7 +40,7 @@
 
 #include "pipe/p_config.h"
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE)
 #include <stdlib.h>
 #endif
 
@@ -258,7 +258,7 @@ boolean trace_dump_trace_begin()
       trace_dump_writes("<?xml-stylesheet type='text/xsl' href='trace.xsl'?>\n");
       trace_dump_writes("<trace version='0.1'>\n");
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE)
       /* Linux applications rarely cleanup GL / Gallium resources so catch
        * application exit here */
       atexit(trace_dump_trace_close);
diff --git a/src/gallium/drivers/trace/tr_rbug.c b/src/gallium/drivers/trace/tr_rbug.c
index 81e0a6f..0372d92 100644
--- a/src/gallium/drivers/trace/tr_rbug.c
+++ b/src/gallium/drivers/trace/tr_rbug.c
@@ -44,7 +44,7 @@
 
 #if defined(PIPE_SUBSYSTEM_WINDOWS_USER)
 #  define sleep Sleep
-#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD)
+#elif defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE)
 void usleep(int);
 #  define sleep usleep
 #else
@@ -179,7 +179,7 @@ static int
 trace_rbug_texture_info(struct trace_rbug *tr_rbug, struct rbug_header *header, uint32_t serial)
 {
    struct trace_screen *tr_scr = tr_rbug->tr_scr;
-   struct trace_texture *tr_tex;
+   struct trace_texture *tr_tex = NULL;
    struct rbug_proto_texture_info *gpti = (struct rbug_proto_texture_info *)header;
    struct tr_list *ptr;
    struct pipe_texture *t;
@@ -220,7 +220,7 @@ trace_rbug_texture_read(struct trace_rbug *tr_rbug, struct rbug_header *header,
    struct rbug_proto_texture_read *gptr = (struct rbug_proto_texture_read *)header;
 
    struct trace_screen *tr_scr = tr_rbug->tr_scr;
-   struct trace_texture *tr_tex;
+   struct trace_texture *tr_tex = NULL;
    struct tr_list *ptr;
 
    struct pipe_screen *screen = tr_scr->screen;
diff --git a/src/gallium/drivers/trace/tr_state.h b/src/gallium/drivers/trace/tr_state.h
index 1c16042..e2f981d 100644
--- a/src/gallium/drivers/trace/tr_state.h
+++ b/src/gallium/drivers/trace/tr_state.h
@@ -32,7 +32,7 @@ struct tgsi_token;
 enum trace_shader_type {
    TRACE_SHADER_FRAGMENT = 0,
    TRACE_SHADER_VERTEX   = 1,
-   TRACE_SHADER_GEOMETRY = 2,
+   TRACE_SHADER_GEOMETRY = 2
 };
 
 struct trace_shader
diff --git a/src/gallium/include/pipe/p_inlines.h b/src/gallium/include/pipe/p_inlines.h
index 5fbd62a..72f5c1d 100644
--- a/src/gallium/include/pipe/p_inlines.h
+++ b/src/gallium/include/pipe/p_inlines.h
@@ -63,13 +63,6 @@ pipe_buffer_map(struct pipe_screen *screen,
    if(screen->buffer_map_range) {
       unsigned offset = 0;
       unsigned length = buf->size;
-
-      /* XXX: Actually we should be using/detecting DISCARD
-       * instead of assuming that WRITE implies discard */
-      if((usage & PIPE_BUFFER_USAGE_CPU_WRITE) &&
-         !(usage & PIPE_BUFFER_USAGE_DISCARD))
-         usage |= PIPE_BUFFER_USAGE_CPU_READ;
-
       return screen->buffer_map_range(screen, buf, offset, length, usage);
    }
    else
@@ -126,7 +119,39 @@ pipe_buffer_write(struct pipe_screen *screen,
 
    map = pipe_buffer_map_range(screen, buf, offset, size, 
                                PIPE_BUFFER_USAGE_CPU_WRITE | 
-                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT);
+                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
+                               PIPE_BUFFER_USAGE_DISCARD);
+   assert(map);
+   if(map) {
+      memcpy((uint8_t *)map + offset, data, size);
+      pipe_buffer_flush_mapped_range(screen, buf, offset, size);
+      pipe_buffer_unmap(screen, buf);
+   }
+}
+
+/**
+ * Special case for writing non-overlapping ranges.
+ *
+ * We can avoid GPU/CPU synchronization when writing range that has never
+ * been written before.
+ */
+static INLINE void
+pipe_buffer_write_nooverlap(struct pipe_screen *screen,
+                            struct pipe_buffer *buf,
+                            unsigned offset, unsigned size,
+                            const void *data)
+{
+   void *map;
+
+   assert(offset < buf->size);
+   assert(offset + size <= buf->size);
+   assert(size);
+
+   map = pipe_buffer_map_range(screen, buf, offset, size,
+                               PIPE_BUFFER_USAGE_CPU_WRITE |
+                               PIPE_BUFFER_USAGE_FLUSH_EXPLICIT |
+                               PIPE_BUFFER_USAGE_DISCARD |
+                               PIPE_BUFFER_USAGE_UNSYNCHRONIZED);
    assert(map);
    if(map) {
       memcpy((uint8_t *)map + offset, data, size);
diff --git a/src/gallium/include/pipe/p_screen.h b/src/gallium/include/pipe/p_screen.h
index f0a4de5..b8e001a 100644
--- a/src/gallium/include/pipe/p_screen.h
+++ b/src/gallium/include/pipe/p_screen.h
@@ -266,6 +266,11 @@ struct pipe_screen {
 
    void (*video_surface_destroy)( struct pipe_video_surface *vsfc );
 
+   /**
+    * Do any special operations to ensure buffer size is correct
+    */
+   void (*update_buffer)( struct pipe_screen *ws,
+                          void *context_private );
 
    /**
     * Do any special operations to ensure frontbuffer contents are
diff --git a/src/gallium/include/state_tracker/drm_api.h b/src/gallium/include/state_tracker/drm_api.h
index 4d1259e..78882f3 100644
--- a/src/gallium/include/state_tracker/drm_api.h
+++ b/src/gallium/include/state_tracker/drm_api.h
@@ -29,6 +29,11 @@ struct drm_create_screen_arg {
 struct drm_api
 {
 	/**
+	 * Kernel driver name, as accepted by drmOpenByName.
+	 */
+	const char *driver_name;
+
+	/**
 	 * Special buffer functions
 	 */
 	/*@{*/
diff --git a/src/gallium/state_trackers/dri/dri_context.c b/src/gallium/state_trackers/dri/dri_context.c
index 8819936..cd9d8b6 100644
--- a/src/gallium/state_trackers/dri/dri_context.c
+++ b/src/gallium/state_trackers/dri/dri_context.c
@@ -101,6 +101,12 @@ dri_destroy_context(__DRIcontextPrivate * cPriv)
 {
    struct dri_context *ctx = dri_context(cPriv);
 
+   /* note: we are freeing values and nothing more because
+    * driParseConfigFiles allocated values only - the rest
+    * is owned by screen optionCache.
+    */
+   FREE(ctx->optionCache.values);
+
    /* No particular reason to wait for command completion before
     * destroying a context, but it is probably worthwhile flushing it
     * to avoid having to add code elsewhere to cope with flushing a
diff --git a/src/gallium/state_trackers/dri/dri_drawable.c b/src/gallium/state_trackers/dri/dri_drawable.c
index 5625ff5..c20b71e 100644
--- a/src/gallium/state_trackers/dri/dri_drawable.c
+++ b/src/gallium/state_trackers/dri/dri_drawable.c
@@ -123,11 +123,12 @@ dri_get_buffers(__DRIdrawablePrivate * dPriv)
 
    struct dri_drawable *drawable = dri_drawable(dPriv);
    struct pipe_surface *surface = NULL;
-   struct pipe_screen *screen = dri_screen(drawable->sPriv)->pipe_screen;
+   struct dri_screen *st_screen = dri_screen(drawable->sPriv);
+   struct pipe_screen *screen = st_screen->pipe_screen;
    __DRIbuffer *buffers = NULL;
    __DRIscreen *dri_screen = drawable->sPriv;
    __DRIdrawable *dri_drawable = drawable->dPriv;
-   struct drm_api *api = ((struct dri_screen*)(dri_screen->private))->api;
+   struct drm_api *api = st_screen->api;
    boolean have_depth = FALSE;
    int i, count;
 
@@ -180,6 +181,9 @@ dri_get_buffers(__DRIdrawablePrivate * dPriv)
 
       switch (buffers[i].attachment) {
       case __DRI_BUFFER_FRONT_LEFT:
+	 if (!st_screen->auto_fake_front)
+	    continue;
+	 /* fallthrough */
       case __DRI_BUFFER_FAKE_FRONT_LEFT:
 	 index = ST_SURFACE_FRONT_LEFT;
 	 format = drawable->color_format;
@@ -268,6 +272,14 @@ void dri2_set_tex_buffer(__DRIcontext *pDRICtx, GLint target,
 }
 
 void
+dri_update_buffer(struct pipe_screen *screen, void *context_private)
+{
+   struct dri_context *ctx = (struct dri_context *)context_private;
+
+   dri_get_buffers(ctx->dPriv);
+}
+
+void
 dri_flush_frontbuffer(struct pipe_screen *screen,
 		      struct pipe_surface *surf, void *context_private)
 {
@@ -364,7 +376,8 @@ dri_create_buffer(__DRIscreenPrivate * sPriv,
    /* TODO incase of double buffer visual, delay fake creation */
    i = 0;
    drawable->attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
-
+   if (!screen->auto_fake_front)
+      drawable->attachments[i++] = __DRI_BUFFER_FAKE_FRONT_LEFT;
    if (visual->doubleBufferMode)
       drawable->attachments[i++] = __DRI_BUFFER_BACK_LEFT;
    if (visual->depthBits && visual->stencilBits)
diff --git a/src/gallium/state_trackers/dri/dri_drawable.h b/src/gallium/state_trackers/dri/dri_drawable.h
index b910930..a0fb05d 100644
--- a/src/gallium/state_trackers/dri/dri_drawable.h
+++ b/src/gallium/state_trackers/dri/dri_drawable.h
@@ -81,6 +81,9 @@ dri_create_buffer(__DRIscreenPrivate * sPriv,
 		  const __GLcontextModes * visual, boolean isPixmap);
 
 void
+dri_update_buffer(struct pipe_screen *screen, void *context_private);
+
+void
 dri_flush_frontbuffer(struct pipe_screen *screen,
 		      struct pipe_surface *surf, void *context_private);
 
diff --git a/src/gallium/state_trackers/dri/dri_screen.c b/src/gallium/state_trackers/dri/dri_screen.c
index cb864d4..25c392e 100644
--- a/src/gallium/state_trackers/dri/dri_screen.c
+++ b/src/gallium/state_trackers/dri/dri_screen.c
@@ -289,6 +289,8 @@ dri_init_screen2(__DRIscreenPrivate * sPriv)
 {
    struct dri_screen *screen;
    struct drm_create_screen_arg arg;
+   const __DRIdri2LoaderExtension *dri2_ext =
+     sPriv->dri2.loader;
 
    screen = CALLOC_STRUCT(dri_screen);
    if (!screen)
@@ -308,11 +310,15 @@ dri_init_screen2(__DRIscreenPrivate * sPriv)
    }
 
    /* We need to hook in here */
+   screen->pipe_screen->update_buffer = dri_update_buffer;
    screen->pipe_screen->flush_frontbuffer = dri_flush_frontbuffer;
 
    driParseOptionInfo(&screen->optionCache,
 		      __driConfigOptions, __driNConfigOptions);
 
+   screen->auto_fake_front = dri2_ext->base.version >= 3 &&
+      dri2_ext->getBuffersWithFormat != NULL;
+
    return dri_fill_in_modes(screen, 32);
  fail:
    return NULL;
@@ -322,8 +328,18 @@ static void
 dri_destroy_screen(__DRIscreenPrivate * sPriv)
 {
    struct dri_screen *screen = dri_screen(sPriv);
+   int i;
 
    screen->pipe_screen->destroy(screen->pipe_screen);
+   
+   for (i = 0; i < (1 << screen->optionCache.tableSize); ++i) {
+      FREE(screen->optionCache.info[i].name);
+      FREE(screen->optionCache.info[i].ranges);
+   }
+
+   FREE(screen->optionCache.info);
+   FREE(screen->optionCache.values);
+
    FREE(screen);
    sPriv->private = NULL;
 }
diff --git a/src/gallium/state_trackers/dri/dri_screen.h b/src/gallium/state_trackers/dri/dri_screen.h
index f6c56d0..10319f8 100644
--- a/src/gallium/state_trackers/dri/dri_screen.h
+++ b/src/gallium/state_trackers/dri/dri_screen.h
@@ -59,6 +59,7 @@ struct dri_screen
    struct pipe_screen *pipe_screen;
    boolean d_depth_bits_last;
    boolean sd_depth_bits_last;
+   boolean auto_fake_front;
 };
 
 /** cast wrapper */
diff --git a/src/gallium/state_trackers/egl/egl_surface.c b/src/gallium/state_trackers/egl/egl_surface.c
index 91615ab..61b7f98 100644
--- a/src/gallium/state_trackers/egl/egl_surface.c
+++ b/src/gallium/state_trackers/egl/egl_surface.c
@@ -171,9 +171,9 @@ drm_takedown_shown_screen(_EGLDisplay *dpy, struct drm_screen *screen)
 	drmModeSetCrtc(
 		dev->drmFD,
 		screen->crtcID,
-		0, // FD
+		0, /* FD */
 		0, 0,
-		NULL, 0, // List of output ids
+		NULL, 0, /* List of output ids */
 		NULL);
 
 	drmModeRmFB(dev->drmFD, screen->fbID);
diff --git a/src/gallium/state_trackers/egl/egl_tracker.c b/src/gallium/state_trackers/egl/egl_tracker.c
index 745803c..9345b0f 100644
--- a/src/gallium/state_trackers/egl/egl_tracker.c
+++ b/src/gallium/state_trackers/egl/egl_tracker.c
@@ -152,6 +152,7 @@ drm_initialize(_EGLDriver *drv, _EGLDisplay *disp, EGLint *major, EGLint *minor)
 	int num_screens = 0;
 	EGLint i;
 	int fd;
+	_EGLConfig *config;
 
 	dev = (struct drm_device *) calloc(1, sizeof(struct drm_device));
 	if (!dev)
@@ -206,7 +207,7 @@ drm_initialize(_EGLDriver *drv, _EGLDisplay *disp, EGLint *major, EGLint *minor)
 	disp->DriverData = dev;
 
 	/* for now we only have one config */
-	_EGLConfig *config = calloc(1, sizeof(*config));
+	config = calloc(1, sizeof(*config));
 	memset(config, 1, sizeof(*config));
 	_eglInitConfig(config, 1);
 	_eglSetConfigAttrib(config, EGL_RED_SIZE, 8);
diff --git a/src/gallium/state_trackers/glx/xlib/glx_api.c b/src/gallium/state_trackers/glx/xlib/glx_api.c
index f2881b9..228ac9a 100644
--- a/src/gallium/state_trackers/glx/xlib/glx_api.c
+++ b/src/gallium/state_trackers/glx/xlib/glx_api.c
@@ -644,6 +644,7 @@ register_with_display(Display *dpy)
       XExtCodes *c = XAddExtension(dpy);
       ext = dpy->ext_procs;  /* new extension is at head of list */
       assert(c->extension == ext->codes.extension);
+      (void) c;
       ext->name = _mesa_strdup(extName);
       ext->close_display = close_display_callback;
    }
diff --git a/src/gallium/state_trackers/python/SConscript b/src/gallium/state_trackers/python/SConscript
index ec385e7..e121d4d 100644
--- a/src/gallium/state_trackers/python/SConscript
+++ b/src/gallium/state_trackers/python/SConscript
@@ -21,6 +21,7 @@ if 'python' in env['statetrackers']:
             'gdi32',
             'user32',
             'kernel32',
+            'ws2_32',
         ])
     else:
         env.Append(LIBS = [
diff --git a/src/gallium/state_trackers/vega/api_path.c b/src/gallium/state_trackers/vega/api_path.c
index a6b7a2b..15ac190 100644
--- a/src/gallium/state_trackers/vega/api_path.c
+++ b/src/gallium/state_trackers/vega/api_path.c
@@ -164,8 +164,7 @@ void vgAppendPathData(VGPath dstPath,
       return;
    }
    for (i = 0; i < numSegments; ++i) {
-      if (pathSegments[i] < VG_CLOSE_PATH ||
-          pathSegments[i] > VG_LCWARC_TO_REL) {
+      if (pathSegments[i] > VG_LCWARC_TO_REL) {
          vg_set_error(ctx, VG_ILLEGAL_ARGUMENT_ERROR);
          return;
       }
diff --git a/src/gallium/state_trackers/vega/arc.c b/src/gallium/state_trackers/vega/arc.c
index 8b04d21..2d12340 100644
--- a/src/gallium/state_trackers/vega/arc.c
+++ b/src/gallium/state_trackers/vega/arc.c
@@ -528,7 +528,6 @@ static INLINE int num_beziers_needed(struct arc *arc)
    double threshold = 0.05;
    VGboolean found = VG_FALSE;
    int n = 1;
-   int i;
    double min_eta, max_eta;
 
    min_eta = MIN2(arc->eta1, arc->eta2);
@@ -538,6 +537,7 @@ static INLINE int num_beziers_needed(struct arc *arc)
       double d_eta = (max_eta - min_eta) / n;
       if (d_eta <= 0.5 * M_PI) {
          double eta_b = min_eta;
+         int i;
          found = VG_TRUE;
          for (i = 0; found && (i < n); ++i) {
             double etaA = eta_b;
diff --git a/src/gallium/state_trackers/vega/bezier.c b/src/gallium/state_trackers/vega/bezier.c
index 0d55040..5769e8e 100644
--- a/src/gallium/state_trackers/vega/bezier.c
+++ b/src/gallium/state_trackers/vega/bezier.c
@@ -256,7 +256,6 @@ static enum shift_result good_offset(const struct bezier *b1,
    const float max_dist_normal = threshold*offset;
    const float spacing = 0.25;
    float i;
-
    for (i = spacing; i < 0.99; i += spacing) {
       float p1[2],p2[2], d, l;
       float normal[2];
diff --git a/src/gallium/state_trackers/vega/shader.c b/src/gallium/state_trackers/vega/shader.c
index d9074a3..91909da 100644
--- a/src/gallium/state_trackers/vega/shader.c
+++ b/src/gallium/state_trackers/vega/shader.c
@@ -135,8 +135,8 @@ static VGint blend_bind_samplers(struct vg_context *ctx,
       textures[2] = stfb->blend_texture;
 
       if (!samplers[0] || !textures[0]) {
-         samplers[1] = samplers[2];
-         textures[1] = textures[2];
+         samplers[0] = samplers[2];
+         textures[0] = textures[2];
       }
       if (!samplers[1] || !textures[1]) {
          samplers[1] = samplers[0];
diff --git a/src/gallium/state_trackers/vega/stroker.c b/src/gallium/state_trackers/vega/stroker.c
index 1b92d2b..68a5202 100644
--- a/src/gallium/state_trackers/vega/stroker.c
+++ b/src/gallium/state_trackers/vega/stroker.c
@@ -476,7 +476,7 @@ static enum intersection_type line_intersect(const VGfloat *l1,
                                              const VGfloat *l2,
                                              float *intersection_point)
 {
-   VGfloat isect[2];
+   VGfloat isect[2] = { 0 };
    enum intersection_type type;
    VGboolean dx_zero, ldx_zero;
 
@@ -649,7 +649,7 @@ static void create_joins(struct stroker *stroker,
       VGfloat prev_line[] = {stroker->back2_x, stroker->back2_y,
                              stroker->back1_x, stroker->back1_y};
 
-      VGfloat isect[2];
+      VGfloat isect[2] = { 0 };
       enum intersection_type type = line_intersect(prev_line, next_line, isect);
 
       if (join == SquareJoin) {
diff --git a/src/gallium/state_trackers/vega/vg_tracker.c b/src/gallium/state_trackers/vega/vg_tracker.c
index c4da01e..a8ab939 100644
--- a/src/gallium/state_trackers/vega/vg_tracker.c
+++ b/src/gallium/state_trackers/vega/vg_tracker.c
@@ -33,6 +33,7 @@
 #include "pipe/p_screen.h"
 #include "util/u_memory.h"
 #include "util/u_math.h"
+#include "util/u_rect.h"
 
 static struct pipe_texture *
 create_texture(struct pipe_context *pipe, enum pipe_format format,
diff --git a/src/gallium/state_trackers/wgl/stw_pixelformat.c b/src/gallium/state_trackers/wgl/stw_pixelformat.c
index 7abe5d9..95e1957 100644
--- a/src/gallium/state_trackers/wgl/stw_pixelformat.c
+++ b/src/gallium/state_trackers/wgl/stw_pixelformat.c
@@ -94,8 +94,6 @@ stw_pf_depth_stencil[] = {
    { PIPE_FORMAT_Z24X8_UNORM, {24, 0} },
    { PIPE_FORMAT_X8Z24_UNORM, {24, 0} },
    { PIPE_FORMAT_Z16_UNORM,   {16, 0} },
-   /* pure stencil */
-   { PIPE_FORMAT_S8_UNORM,    { 0, 8} },
    /* combined depth-stencil */
    { PIPE_FORMAT_S8Z24_UNORM, {24, 8} },
    { PIPE_FORMAT_Z24S8_UNORM, {24, 8} }
@@ -221,7 +219,8 @@ stw_pixelformat_init( void )
          const struct stw_pf_color_info *color = &stw_pf_color[j];
          
          if(!screen->is_format_supported(screen, color->format, PIPE_TEXTURE_2D, 
-                                         PIPE_TEXTURE_USAGE_RENDER_TARGET, 0))
+                                         PIPE_TEXTURE_USAGE_RENDER_TARGET |
+                                         PIPE_TEXTURE_USAGE_DISPLAY_TARGET, 0))
             continue;
          
          for(k = 0; k < Elements(stw_pf_doublebuffer); ++k) {
diff --git a/src/gallium/state_trackers/xorg/xorg_composite.c b/src/gallium/state_trackers/xorg/xorg_composite.c
index a5975aa..89d462d 100644
--- a/src/gallium/state_trackers/xorg/xorg_composite.c
+++ b/src/gallium/state_trackers/xorg/xorg_composite.c
@@ -4,10 +4,7 @@
 #include "xorg_exa_tgsi.h"
 
 #include "cso_cache/cso_context.h"
-#include "util/u_draw_quad.h"
-#include "util/u_math.h"
 
-#include "pipe/p_inlines.h"
 
 /*XXX also in Xrender.h but the including it here breaks compilition */
 #define XFixedToDouble(f)    (((double) (f)) / 65536.)
diff --git a/src/gallium/state_trackers/xorg/xorg_crtc.c b/src/gallium/state_trackers/xorg/xorg_crtc.c
index 337449a..0160b1a 100644
--- a/src/gallium/state_trackers/xorg/xorg_crtc.c
+++ b/src/gallium/state_trackers/xorg/xorg_crtc.c
@@ -70,6 +70,8 @@ struct crtc_private
 static void
 crtc_dpms(xf86CrtcPtr crtc, int mode)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     switch (mode) {
     case DPMSModeOn:
     case DPMSModeStandby:
@@ -120,7 +122,8 @@ crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
     drm_mode.vrefresh = mode->VRefresh;
     if (!mode->name)
 	xf86SetModeDefaultName(mode);
-    strncpy(drm_mode.name, mode->name, DRM_DISPLAY_MODE_LEN);
+    strncpy(drm_mode.name, mode->name, DRM_DISPLAY_MODE_LEN - 1);
+    drm_mode.name[DRM_DISPLAY_MODE_LEN - 1] = '\0';
 
     ret = drmModeSetCrtc(ms->fd, drm_crtc->crtc_id, ms->fb_id, x, y,
 			 &drm_connector->connector_id, 1, &drm_mode);
@@ -146,18 +149,23 @@ crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green, CARD16 * blue,
 static void *
 crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     return NULL;
 }
 
 static PixmapPtr
 crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
+
     return NULL;
 }
 
 static void
 crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
 {
+    /* ScrnInfoPtr pScrn = crtc->scrn; */
 }
 
 /*
diff --git a/src/gallium/state_trackers/xorg/xorg_dri2.c b/src/gallium/state_trackers/xorg/xorg_dri2.c
index 4fa4754..83dc92e 100644
--- a/src/gallium/state_trackers/xorg/xorg_dri2.c
+++ b/src/gallium/state_trackers/xorg/xorg_dri2.c
@@ -40,12 +40,14 @@
 #include "pipe/p_state.h"
 #include "pipe/p_inlines.h"
 
-#include "util/u_rect.h"
 
 /* Make all the #if cases in the code esier to read */
-/* XXX can it be set to 1? */
 #ifndef DRI2INFOREC_VERSION
-#define DRI2INFOREC_VERSION 0
+#define DRI2INFOREC_VERSION 1
+#endif
+
+#if DRI2INFOREC_VERSION == 2
+static Bool set_format_in_do_create_buffer;
 #endif
 
 typedef struct {
@@ -147,7 +149,9 @@ dri2_do_create_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer, unsigned int form
     buffer->driverPrivate = private;
     buffer->flags = 0; /* not tiled */
 #if DRI2INFOREC_VERSION == 2
-    ((DRI2Buffer2Ptr)buffer)->format = 0;
+    /* ABI forwards/backwards compatibility */
+    if (set_format_in_do_create_buffer)
+	((DRI2Buffer2Ptr)buffer)->format = 0;
 #elif DRI2INFOREC_VERSION >= 3
     buffer->format = 0;
 #endif
@@ -211,7 +215,9 @@ dri2_destroy_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer)
     xfree(buffer);
 }
 
-#else /* DRI2INFOREC_VERSION < 2 */
+#endif /* DRI2INFOREC_VERSION >= 2 */
+
+#if DRI2INFOREC_VERSION <= 2
 
 static DRI2BufferPtr
 dri2_create_buffers(DrawablePtr pDraw, unsigned int *attachments, int count)
@@ -261,7 +267,7 @@ dri2_destroy_buffers(DrawablePtr pDraw, DRI2BufferPtr buffers, int count)
     }
 }
 
-#endif /* DRI2INFOREC_VERSION >= 2 */
+#endif /* DRI2INFOREC_VERSION <= 2 */
 
 static void
 dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
@@ -369,12 +375,19 @@ xorg_dri2_init(ScreenPtr pScreen)
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
     modesettingPtr ms = modesettingPTR(pScrn);
     DRI2InfoRec dri2info;
-
 #if DRI2INFOREC_VERSION >= 2
-    dri2info.version = DRI2INFOREC_VERSION;
-#else
-    dri2info.version = 1;
+    int major, minor;
+
+    if (xf86LoaderCheckSymbol("DRI2Version")) {
+	DRI2Version(&major, &minor);
+    } else {
+	/* Assume version 1.0 */
+	major = 1;
+	minor = 0;
+    }
 #endif
+
+    dri2info.version = DRI2INFOREC_VERSION;
     dri2info.fd = ms->fd;
 
     dri2info.driverName = pScrn->driverName;
@@ -383,7 +396,22 @@ xorg_dri2_init(ScreenPtr pScreen)
 #if DRI2INFOREC_VERSION >= 2
     dri2info.CreateBuffer = dri2_create_buffer;
     dri2info.DestroyBuffer = dri2_destroy_buffer;
-#else
+#endif
+
+    /* For X servers in the 1.6.x series there where two DRI2 version.
+     * This allows us to build one binary that works on both servers.
+     */
+#if DRI2INFOREC_VERSION == 2
+    if (minor == 0) {
+	set_format_in_do_create_buffer = FALSE;
+	dri2info.CreateBuffers = dri2_create_buffers;
+	dri2info.DestroyBuffers = dri2_destroy_buffers;
+    } else
+	set_format_in_do_create_buffer = FALSE;
+#endif
+
+    /* For version 1 set these unconditionaly. */
+#if DRI2INFOREC_VERSION == 1
     dri2info.CreateBuffers = dri2_create_buffers;
     dri2info.DestroyBuffers = dri2_destroy_buffers;
 #endif
diff --git a/src/gallium/state_trackers/xorg/xorg_driver.c b/src/gallium/state_trackers/xorg/xorg_driver.c
index 8a24aa1..e4ad789 100644
--- a/src/gallium/state_trackers/xorg/xorg_driver.c
+++ b/src/gallium/state_trackers/xorg/xorg_driver.c
@@ -45,7 +45,6 @@
 #include "miscstruct.h"
 #include "dixstruct.h"
 #include "xf86xv.h"
-#include <X11/extensions/Xv.h>
 #ifndef XSERVER_LIBPCIACCESS
 #error "libpciaccess needed"
 #endif
@@ -79,11 +78,13 @@ typedef enum
 {
     OPTION_SW_CURSOR,
     OPTION_2D_ACCEL,
+    OPTION_DEBUG_FALLBACK,
 } drv_option_enums;
 
 static const OptionInfoRec drv_options[] = {
     {OPTION_SW_CURSOR, "SWcursor", OPTV_BOOLEAN, {0}, FALSE},
     {OPTION_2D_ACCEL, "2DAccel", OPTV_BOOLEAN, {0}, FALSE},
+    {OPTION_DEBUG_FALLBACK, "DebugFallback", OPTV_BOOLEAN, {0}, FALSE},
     {-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
@@ -111,6 +112,28 @@ xorg_tracker_set_functions(ScrnInfoPtr scrn)
     scrn->ValidMode = drv_valid_mode;
 }
 
+Bool
+xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device)
+{
+    char *BusID = xalloc(64);
+    sprintf(BusID, "pci:%04x:%02x:%02x.%d",
+	    device->domain, device->bus,
+	    device->dev, device->func);
+
+    if (drmCheckModesettingSupported(BusID)) {
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
+		       "Drm modesetting not supported %s\n", BusID);
+	xfree(BusID);
+	return FALSE;
+    }
+
+    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
+		   "Drm modesetting supported on %s\n", BusID);
+
+    xfree(BusID);
+    return TRUE;
+}
+
 
 /*
  * Internal function definitions
@@ -181,8 +204,7 @@ drv_crtc_resize(ScrnInfoPtr pScrn, int width, int height)
     if (!pScreen->ModifyPixmapHeader(rootPixmap, width, height, -1, -1, -1, NULL))
 	return FALSE;
 
-    /* HW dependent - FIXME */
-    pScrn->displayWidth = pScrn->virtualX;
+    pScrn->displayWidth = rootPixmap->devKind / (rootPixmap->drawable.bitsPerPixel / 8);
 
     /* now create new frontbuffer */
     return ms->create_front_buffer(pScrn) && ms->bind_front_buffer(pScrn);
@@ -207,24 +229,54 @@ drv_init_drm(ScrnInfoPtr pScrn)
 		ms->PciInfo->dev, ms->PciInfo->func
 	    );
 
-	ms->fd = drmOpen(NULL, BusID);
 
-	if (ms->fd < 0)
-	    return FALSE;
+	ms->api = drm_api_create();
+	ms->fd = drmOpen(ms->api ? ms->api->driver_name : NULL, BusID);
+	xfree(BusID);
+
+	if (ms->fd >= 0)
+	    return TRUE;
+
+	if (ms->api && ms->api->destroy)
+	    ms->api->destroy(ms->api);
+
+	ms->api = NULL;
+
+	return FALSE;
     }
 
     return TRUE;
 }
 
 static Bool
+drv_close_drm(ScrnInfoPtr pScrn)
+{
+    modesettingPtr ms = modesettingPTR(pScrn);
+
+    if (ms->api && ms->api->destroy)
+	ms->api->destroy(ms->api);
+    ms->api = NULL;
+
+    drmClose(ms->fd);
+    ms->fd = -1;
+
+    return TRUE;
+}
+
+static Bool
 drv_init_resource_management(ScrnInfoPtr pScrn)
 {
     modesettingPtr ms = modesettingPTR(pScrn);
+    /*
+    ScreenPtr pScreen = pScrn->pScreen;
+    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
+    Bool fbAccessDisabled;
+    CARD8 *fbstart;
+     */
 
     if (ms->screen || ms->kms)
 	return TRUE;
 
-    ms->api = drm_api_create();
     if (ms->api) {
 	ms->screen = ms->api->create_screen(ms->api, ms->fd, NULL);
 
@@ -249,15 +301,21 @@ static Bool
 drv_close_resource_management(ScrnInfoPtr pScrn)
 {
     modesettingPtr ms = modesettingPTR(pScrn);
+    int i;
 
-    if (ms->screen)
+    if (ms->screen) {
+	assert(ms->ctx == NULL);
+
+	for (i = 0; i < XORG_NR_FENCES; i++) {
+	    if (ms->fence[i]) {
+		ms->screen->fence_finish(ms->screen, ms->fence[i], 0);
+		ms->screen->fence_reference(ms->screen, &ms->fence[i], NULL);
+	    }
+	}
 	ms->screen->destroy(ms->screen);
+    }
     ms->screen = NULL;
 
-    if (ms->api && ms->api->destroy)
-	ms->api->destroy(ms->api);
-    ms->api = NULL;
-
 #ifdef HAVE_LIBKMS
     if (ms->kms)
 	kms_destroy(&ms->kms);
@@ -461,7 +519,7 @@ static void drv_block_handler(int i, pointer blockData, pointer pTimeout,
         * quite small.  Let us get a fair way ahead of hardware before
         * throttling.
         */
-       for (j = 0; j < XORG_NR_FENCES; j++)
+       for (j = 0; j < XORG_NR_FENCES - 1; j++)
           ms->screen->fence_reference(ms->screen,
                                       &ms->fence[j],
                                       ms->fence[j+1]);
@@ -614,10 +672,11 @@ drv_screen_init(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
     xf86SetBlackWhitePixels(pScreen);
 
+    ms->accelerate_2d = xf86ReturnOptValBool(ms->Options, OPTION_2D_ACCEL, FALSE);
+    ms->debug_fallback = xf86ReturnOptValBool(ms->Options, OPTION_DEBUG_FALLBACK, TRUE);
+
     if (ms->screen) {
-	ms->exa = xorg_exa_init(pScrn, xf86ReturnOptValBool(ms->Options,
-							    OPTION_2D_ACCEL, TRUE));
-	ms->debug_fallback = debug_get_bool_option("XORG_DEBUG_FALLBACK", TRUE);
+	ms->exa = xorg_exa_init(pScrn, ms->accelerate_2d);
 
 	xorg_xv_init(pScreen);
 #ifdef DRI2
@@ -625,6 +684,17 @@ drv_screen_init(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 #endif
     }
 
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D Acceleration is %s\n",
+	       ms->screen && ms->accelerate_2d ? "enabled" : "disabled");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Fallback debugging is %s\n",
+	       ms->debug_fallback ? "enabled" : "disabled");
+#ifdef DRI2
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "3D Acceleration is %s\n",
+	       ms->screen ? "enabled" : "disabled");
+#else
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "3D Acceleration is disabled\n");
+#endif
+
     miInitializeBackingStore(pScreen);
     xf86SetBackingStore(pScreen);
     xf86SetSilkenMouse(pScreen);
@@ -808,8 +878,7 @@ drv_close_screen(int scrnIndex, ScreenPtr pScreen)
 
     drv_close_resource_management(pScrn);
 
-    drmClose(ms->fd);
-    ms->fd = -1;
+    drv_close_drm(pScrn);
 
     pScrn->vtSema = FALSE;
     pScreen->CloseScreen = ms->CloseScreen;
@@ -915,6 +984,12 @@ drv_destroy_front_buffer_kms(ScrnInfoPtr pScrn)
     ScreenPtr pScreen = pScrn->pScreen;
     PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
 
+    /* XXX Do something with the rootPixmap.
+     * This currently works fine but if we are getting crashes in
+     * the fb functions after VT switches maybe look more into it.
+     */
+    (void)rootPixmap;
+
     if (!ms->root_bo)
 	return TRUE;
 
@@ -991,12 +1066,22 @@ drv_bind_front_buffer_kms(ScrnInfoPtr pScrn)
 	goto err_destroy;
 
     pScreen->ModifyPixmapHeader(rootPixmap,
-				pScreen->width,
-				pScreen->height,
+				pScrn->virtualX,
+				pScrn->virtualY,
 				pScreen->rootDepth,
 				pScrn->bitsPerPixel,
 				stride,
 				ptr);
+
+    /* This a hack to work around EnableDisableFBAccess setting the pointer
+     * the real fix would be to replace pScrn->EnableDisableFBAccess hook
+     * and set the rootPixmap->devPrivate.ptr to something valid before that.
+     *
+     * But in its infinit visdome something uses either this some times before
+     * that, so our hook doesn't get called before the crash happens.
+     */
+    pScrn->pixmapPrivate.ptr = ptr;
+
     return TRUE;
 
 err_destroy:
diff --git a/src/gallium/state_trackers/xorg/xorg_exa.c b/src/gallium/state_trackers/xorg/xorg_exa.c
index 17a032e..6d89fca 100644
--- a/src/gallium/state_trackers/xorg/xorg_exa.c
+++ b/src/gallium/state_trackers/xorg/xorg_exa.c
@@ -41,7 +41,6 @@
 #include "pipe/p_format.h"
 #include "pipe/p_context.h"
 #include "pipe/p_state.h"
-#include "pipe/p_inlines.h"
 
 #include "util/u_rect.h"
 #include "util/u_math.h"
@@ -515,6 +514,7 @@ ExaCopy(PixmapPtr pDstPixmap, int srcX, int srcY, int dstX, int dstY,
 #endif
 
    debug_assert(priv == exa->copy.dst);
+   (void) priv;
 
    if (exa->copy.use_surface_copy) {
       /* XXX: consider exposing >1 box in surface_copy interface.
@@ -1020,6 +1020,9 @@ xorg_exa_close(ScrnInfoPtr pScrn)
 
    if (exa->pipe)
       exa->pipe->destroy(exa->pipe);
+   exa->pipe = NULL;
+   /* Since this was shared be proper with the pointer */
+   ms->ctx = NULL;
 
    exaDriverFini(pScrn->pScreen);
    xfree(exa);
diff --git a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
index 13a9840..3e5e6bd 100644
--- a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
+++ b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
@@ -6,11 +6,9 @@
 #include "pipe/p_format.h"
 #include "pipe/p_context.h"
 #include "pipe/p_state.h"
-#include "pipe/p_inlines.h"
 #include "pipe/p_shader_tokens.h"
 
 #include "util/u_memory.h"
-#include "util/u_simple_shaders.h"
 
 #include "tgsi/tgsi_ureg.h"
 
@@ -47,22 +45,22 @@ static void
 print_fs_traits(int fs_traits)
 {
    const char *strings[] = {
-      "FS_COMPOSITE",       // = 1 << 0,
-      "FS_MASK",            // = 1 << 1,
-      "FS_SOLID_FILL",      // = 1 << 2,
-      "FS_LINGRAD_FILL",    // = 1 << 3,
-      "FS_RADGRAD_FILL",    // = 1 << 4,
-      "FS_CA_FULL",         // = 1 << 5, /* src.rgba * mask.rgba */
-      "FS_CA_SRCALPHA",     // = 1 << 6, /* src.aaaa * mask.rgba */
-      "FS_YUV",             // = 1 << 7,
-      "FS_SRC_REPEAT_NONE", // = 1 << 8,
-      "FS_MASK_REPEAT_NONE",// = 1 << 9,
-      "FS_SRC_SWIZZLE_RGB", // = 1 << 10,
-      "FS_MASK_SWIZZLE_RGB",// = 1 << 11,
-      "FS_SRC_SET_ALPHA",   // = 1 << 12,
-      "FS_MASK_SET_ALPHA",  // = 1 << 13,
-      "FS_SRC_LUMINANCE",   // = 1 << 14,
-      "FS_MASK_LUMINANCE",  // = 1 << 15,
+      "FS_COMPOSITE",       /* = 1 << 0, */
+      "FS_MASK",            /* = 1 << 1, */
+      "FS_SOLID_FILL",      /* = 1 << 2, */
+      "FS_LINGRAD_FILL",    /* = 1 << 3, */
+      "FS_RADGRAD_FILL",    /* = 1 << 4, */
+      "FS_CA_FULL",         /* = 1 << 5, */ /* src.rgba * mask.rgba */
+      "FS_CA_SRCALPHA",     /* = 1 << 6, */ /* src.aaaa * mask.rgba */
+      "FS_YUV",             /* = 1 << 7, */
+      "FS_SRC_REPEAT_NONE", /* = 1 << 8, */
+      "FS_MASK_REPEAT_NONE",/* = 1 << 9, */
+      "FS_SRC_SWIZZLE_RGB", /* = 1 << 10, */
+      "FS_MASK_SWIZZLE_RGB",/* = 1 << 11, */
+      "FS_SRC_SET_ALPHA",   /* = 1 << 12, */
+      "FS_MASK_SET_ALPHA",  /* = 1 << 13, */
+      "FS_SRC_LUMINANCE",   /* = 1 << 14, */
+      "FS_MASK_LUMINANCE",  /* = 1 << 15, */
    };
    int i, k;
    debug_printf("%s: ", __func__);
@@ -492,6 +490,7 @@ create_fs(struct pipe_context *pipe,
 
    /* it has to be either a fill, a composite op or a yuv conversion */
    debug_assert((is_fill ^ is_composite) ^ is_yuv);
+   (void) is_yuv;
 
    out = ureg_DECL_output(ureg,
                           TGSI_SEMANTIC_COLOR,
diff --git a/src/gallium/state_trackers/xorg/xorg_output.c b/src/gallium/state_trackers/xorg/xorg_output.c
index 251f331..13c3fb9 100644
--- a/src/gallium/state_trackers/xorg/xorg_output.c
+++ b/src/gallium/state_trackers/xorg/xorg_output.c
@@ -49,8 +49,6 @@
 #include <X11/extensions/dpms.h>
 #endif
 
-#include "X11/Xatom.h"
-
 #include "xorg_tracker.h"
 
 static char *output_enum_list[] = {
diff --git a/src/gallium/state_trackers/xorg/xorg_renderer.c b/src/gallium/state_trackers/xorg/xorg_renderer.c
index cbb84a8..37c8942 100644
--- a/src/gallium/state_trackers/xorg/xorg_renderer.c
+++ b/src/gallium/state_trackers/xorg/xorg_renderer.c
@@ -437,6 +437,7 @@ void renderer_copy_prepare(struct xorg_renderer *r,
                                       PIPE_TEXTURE_2D,
                                       PIPE_TEXTURE_USAGE_RENDER_TARGET,
                                       0));
+   (void) screen;
 
 
    /* set misc state we care about */
diff --git a/src/gallium/state_trackers/xorg/xorg_tracker.h b/src/gallium/state_trackers/xorg/xorg_tracker.h
index c0cfbe6..b5915d2 100644
--- a/src/gallium/state_trackers/xorg/xorg_tracker.h
+++ b/src/gallium/state_trackers/xorg/xorg_tracker.h
@@ -112,6 +112,7 @@ typedef struct _modesettingRec
     /* exa */
     struct exa_context *exa;
     Bool noEvict;
+    Bool accelerate_2d;
     Bool debug_fallback;
 
     /* winsys hocks */
diff --git a/src/gallium/state_trackers/xorg/xorg_winsys.h b/src/gallium/state_trackers/xorg/xorg_winsys.h
index 47ee4b9..865733b 100644
--- a/src/gallium/state_trackers/xorg/xorg_winsys.h
+++ b/src/gallium/state_trackers/xorg/xorg_winsys.h
@@ -45,5 +45,6 @@
 
 void xorg_tracker_set_functions(ScrnInfoPtr scrn);
 const OptionInfoRec * xorg_tracker_available_options(int chipid, int busid);
+Bool xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device);
 
 #endif
diff --git a/src/gallium/state_trackers/xorg/xorg_xv.c b/src/gallium/state_trackers/xorg/xorg_xv.c
index 19c5005..5f6d749 100644
--- a/src/gallium/state_trackers/xorg/xorg_xv.c
+++ b/src/gallium/state_trackers/xorg/xorg_xv.c
@@ -11,7 +11,6 @@
 #include "cso_cache/cso_context.h"
 
 #include "pipe/p_screen.h"
-#include "pipe/p_inlines.h"
 
 /*XXX get these from pipe's texture limits */
 #define IMAGE_MAX_WIDTH		2048
@@ -485,8 +484,11 @@ display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
    int dxo, dyo;
    Bool hdtv;
    int x, y, w, h;
-   struct exa_pixmap_priv *dst = exaGetPixmapDriverPrivate(pPixmap);
-   struct pipe_surface *dst_surf = xorg_gpu_surface(pPriv->r->pipe->screen, dst);
+   struct exa_pixmap_priv *dst;
+   struct pipe_surface *dst_surf = NULL;
+
+   exaMoveInPixmap(pPixmap);
+   dst = exaGetPixmapDriverPrivate(pPixmap);
 
    if (dst && !dst->tex) {
 	xorg_exa_set_shared_usage(pPixmap);
@@ -496,6 +498,7 @@ display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
    if (!dst || !dst->tex)
       XORG_FALLBACK("Xv destination %s", !dst ? "!dst" : "!dst->tex");
 
+   dst_surf = xorg_gpu_surface(pPriv->r->pipe->screen, dst);
    hdtv = ((src_w >= RES_720P_X) && (src_h >= RES_720P_Y));
 
    REGION_TRANSLATE(pScrn->pScreen, dstRegion, -pPixmap->screen_x,
@@ -515,7 +518,6 @@ display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
    bind_samplers(pPriv);
    setup_fs_video_constants(pPriv->r, hdtv);
 
-   exaMoveInPixmap(pPixmap);
    DamageDamageRegion(&pPixmap->drawable, dstRegion);
 
    while (nbox--) {
diff --git a/src/gallium/winsys/drm/intel/gem/intel_drm_api.c b/src/gallium/winsys/drm/intel/gem/intel_drm_api.c
index 5ed2a10..89b72fd 100644
--- a/src/gallium/winsys/drm/intel/gem/intel_drm_api.c
+++ b/src/gallium/winsys/drm/intel/gem/intel_drm_api.c
@@ -195,6 +195,7 @@ destroy(struct drm_api *api)
 
 struct drm_api intel_drm_api =
 {
+   .driver_name = "i915",
    .create_context = intel_drm_create_context,
    .create_screen = intel_drm_create_screen,
    .texture_from_shared_handle = intel_drm_texture_from_shared_handle,
diff --git a/src/gallium/winsys/drm/nouveau/drm/nouveau_drm_api.c b/src/gallium/winsys/drm/nouveau/drm/nouveau_drm_api.c
index 317dc44..6fccc35 100644
--- a/src/gallium/winsys/drm/nouveau/drm/nouveau_drm_api.c
+++ b/src/gallium/winsys/drm/nouveau/drm/nouveau_drm_api.c
@@ -252,6 +252,7 @@ nouveau_drm_handle_from_pt(struct drm_api *api, struct pipe_screen *pscreen,
 }
 
 struct drm_api drm_api_hooks = {
+	.driver_name = "nouveau",
 	.create_screen = nouveau_drm_create_screen,
 	.create_context = nouveau_drm_create_context,
 	.texture_from_shared_handle = nouveau_drm_pt_from_name,
diff --git a/src/gallium/winsys/drm/radeon/core/radeon_drm.c b/src/gallium/winsys/drm/radeon/core/radeon_drm.c
index 69f14e5..4d962c3 100644
--- a/src/gallium/winsys/drm/radeon/core/radeon_drm.c
+++ b/src/gallium/winsys/drm/radeon/core/radeon_drm.c
@@ -176,6 +176,7 @@ static boolean radeon_local_handle_from_texture(struct drm_api *api,
 }
 
 struct drm_api drm_api_hooks = {
+    .driver_name = "radeon",
     .create_screen = radeon_create_screen,
     .create_context = radeon_create_context,
     .texture_from_shared_handle = radeon_texture_from_shared_handle,
diff --git a/src/gallium/winsys/drm/vmware/core/vmw_context.c b/src/gallium/winsys/drm/vmware/core/vmw_context.c
index b699758..b5fd4f5 100644
--- a/src/gallium/winsys/drm/vmware/core/vmw_context.c
+++ b/src/gallium/winsys/drm/vmware/core/vmw_context.c
@@ -41,9 +41,18 @@
 
 #define VMW_COMMAND_SIZE (64*1024)
 #define VMW_SURFACE_RELOCS (1024)
+#define VMW_REGION_RELOCS (512)
 
 #define VMW_MUST_FLUSH_STACK 8
 
+struct vmw_region_relocation
+{
+   struct SVGAGuestPtr *where;
+   struct pb_buffer *buffer;
+   /* TODO: put offset info inside where */
+   uint32 offset;
+};
+
 struct vmw_svga_winsys_context
 {
    struct svga_winsys_context base;
@@ -69,10 +78,31 @@ struct vmw_svga_winsys_context
       uint32_t staged;
       uint32_t reserved;
    } surface;
+   
+   struct {
+      struct vmw_region_relocation relocs[VMW_REGION_RELOCS];
+      uint32_t size;
+      uint32_t used;
+      uint32_t staged;
+      uint32_t reserved;
+   } region;
 
    struct pb_validate *validate;
 
    uint32_t last_fence;
+
+   /**
+    * The amount of GMR that is referred by the commands currently batched
+    * in the context.
+    */
+   uint32_t seen_regions;
+
+   /**
+    * Whether this context should fail to reserve more commands, not because it
+    * ran out of command space, but because a substantial ammount of GMR was
+    * referred.
+    */
+   boolean preemptive_flush;
 };
 
 
@@ -96,6 +126,19 @@ vmw_swc_flush(struct svga_winsys_context *swc,
    ret = pb_validate_validate(vswc->validate);
    assert(ret == PIPE_OK);
    if(ret == PIPE_OK) {
+   
+      /* Apply relocations */
+      for(i = 0; i < vswc->region.used; ++i) {
+         struct vmw_region_relocation *reloc = &vswc->region.relocs[i];
+         struct SVGAGuestPtr ptr;
+
+         if(!vmw_gmr_bufmgr_region_ptr(reloc->buffer, &ptr))
+            assert(0);
+
+         ptr.offset += reloc->offset;
+
+         *reloc->where = ptr;
+      }
 
       if (vswc->command.used)
          vmw_ioctl_command(vswc->vws,
@@ -121,9 +164,18 @@ vmw_swc_flush(struct svga_winsys_context *swc,
    vswc->surface.used = 0;
    vswc->surface.reserved = 0;
 
+   for(i = 0; i < vswc->region.used + vswc->region.staged; ++i) {
+      pb_reference(&vswc->region.relocs[i].buffer, NULL);
+   }
+
+   vswc->region.used = 0;
+   vswc->region.reserved = 0;
+
 #ifdef DEBUG
    vswc->must_flush = FALSE;
 #endif
+   vswc->preemptive_flush = FALSE;
+   vswc->seen_regions = 0;
 
    if(pfence)
       *pfence = fence;
@@ -151,8 +203,10 @@ vmw_swc_reserve(struct svga_winsys_context *swc,
    if(nr_bytes > vswc->command.size)
       return NULL;
 
-   if(vswc->command.used + nr_bytes > vswc->command.size ||
-      vswc->surface.used + nr_relocs > vswc->surface.size) {
+   if(vswc->preemptive_flush ||
+      vswc->command.used + nr_bytes > vswc->command.size ||
+      vswc->surface.used + nr_relocs > vswc->surface.size ||
+      vswc->region.used + nr_relocs > vswc->region.size) {
 #ifdef DEBUG
       vswc->must_flush = TRUE;
       debug_backtrace_capture(vswc->must_flush_stack, 1,
@@ -163,11 +217,14 @@ vmw_swc_reserve(struct svga_winsys_context *swc,
 
    assert(vswc->command.used + nr_bytes <= vswc->command.size);
    assert(vswc->surface.used + nr_relocs <= vswc->surface.size);
-
+   assert(vswc->region.used + nr_relocs <= vswc->region.size);
+   
    vswc->command.reserved = nr_bytes;
    vswc->surface.reserved = nr_relocs;
    vswc->surface.staged = 0;
-
+   vswc->region.reserved = nr_relocs;
+   vswc->region.staged = 0;
+   
    return vswc->command.buffer + vswc->command.used;
 }
 
@@ -206,20 +263,41 @@ vmw_swc_region_relocation(struct svga_winsys_context *swc,
                           unsigned flags)
 {
    struct vmw_svga_winsys_context *vswc = vmw_svga_winsys_context(swc);
-   struct SVGAGuestPtr ptr;
-   struct pb_buffer *buf = vmw_pb_buffer(buffer);
+   struct vmw_region_relocation *reloc;
    enum pipe_error ret;
+   
+   assert(vswc->region.staged < vswc->region.reserved);
 
-   if(!vmw_gmr_bufmgr_region_ptr(buf, &ptr))
-      assert(0);
-
-   ptr.offset += offset;
+   reloc = &vswc->region.relocs[vswc->region.used + vswc->region.staged];
+   reloc->where = where;
+   pb_reference(&reloc->buffer, vmw_pb_buffer(buffer));
+   reloc->offset = offset;
 
-   *where = ptr;
+   ++vswc->region.staged;
 
-   ret = pb_validate_add_buffer(vswc->validate, buf, flags);
+   ret = pb_validate_add_buffer(vswc->validate, reloc->buffer, flags);
    /* TODO: Update pipebuffer to reserve buffers and not fail here */
    assert(ret == PIPE_OK);
+
+   /*
+    * Flush preemptively the FIFO commands to keep the GMR working set within
+    * the GMR pool size.
+    *
+    * This is necessary for applications like SPECviewperf that generate huge
+    * amounts of immediate vertex data, so that we don't pile up too much of
+    * that vertex data neither in the guest nor in the host.
+    *
+    * Note that in the current implementation if a region is referred twice in
+    * a command stream, it will be accounted twice. We could detect repeated
+    * regions and count only once, but there is no incentive to do that, since
+    * regions are typically short-lived; always referred in a single command;
+    * and at the worst we just flush the commands a bit sooner, which for the
+    * SVGA virtual device it's not a performance issue since flushing commands
+    * to the FIFO won't cause flushing in the host.
+    */
+   vswc->seen_regions += reloc->buffer->base.size;
+   if(vswc->seen_regions >= VMW_GMR_POOL_SIZE/2)
+      vswc->preemptive_flush = TRUE;
 }
 
 
@@ -238,6 +316,12 @@ vmw_swc_commit(struct svga_winsys_context *swc)
    vswc->surface.used += vswc->surface.staged;
    vswc->surface.staged = 0;
    vswc->surface.reserved = 0;
+
+   assert(vswc->region.staged <= vswc->region.reserved);
+   assert(vswc->region.used + vswc->region.staged <= vswc->region.size);
+   vswc->region.used += vswc->region.staged;
+   vswc->region.staged = 0;
+   vswc->region.reserved = 0;
 }
 
 
@@ -246,6 +330,11 @@ vmw_swc_destroy(struct svga_winsys_context *swc)
 {
    struct vmw_svga_winsys_context *vswc = vmw_svga_winsys_context(swc);
    unsigned i;
+
+   for(i = 0; i < vswc->region.used; ++i) {
+      pb_reference(&vswc->region.relocs[i].buffer, NULL);
+   }
+
    for(i = 0; i < vswc->surface.used; ++i) {
       p_atomic_dec(&vswc->surface.handles[i]->validated);
       vmw_svga_winsys_surface_reference(&vswc->surface.handles[i], NULL);
@@ -279,6 +368,7 @@ vmw_svga_winsys_context_create(struct svga_winsys_screen *sws)
 
    vswc->command.size = VMW_COMMAND_SIZE;
    vswc->surface.size = VMW_SURFACE_RELOCS;
+   vswc->region.size = VMW_REGION_RELOCS;
 
    vswc->validate = pb_validate_create();
    if(!vswc->validate) {
diff --git a/src/gallium/winsys/drm/vmware/core/vmw_screen.h b/src/gallium/winsys/drm/vmware/core/vmw_screen.h
index a875107..f1d6986 100644
--- a/src/gallium/winsys/drm/vmware/core/vmw_screen.h
+++ b/src/gallium/winsys/drm/vmware/core/vmw_screen.h
@@ -40,6 +40,10 @@
 
 #include "svga_winsys.h"
 
+
+#define VMW_GMR_POOL_SIZE (16*1024*1024)
+
+
 struct pb_manager;
 struct vmw_region;
 
diff --git a/src/gallium/winsys/drm/vmware/core/vmw_screen_dri.c b/src/gallium/winsys/drm/vmware/core/vmw_screen_dri.c
index 5995eee..60491cb 100644
--- a/src/gallium/winsys/drm/vmware/core/vmw_screen_dri.c
+++ b/src/gallium/winsys/drm/vmware/core/vmw_screen_dri.c
@@ -85,6 +85,23 @@ vmw_drm_create_screen(struct drm_api *drm_api,
    struct pipe_screen *screen;
    struct dri1_create_screen_arg *dri1;
 
+   if (!arg || arg->mode == DRM_CREATE_NORMAL) {
+      struct dri1_api_version drm_ver;
+      drmVersionPtr ver;
+
+      ver = drmGetVersion(fd);
+      if (ver == NULL)
+	 return NULL;
+
+      drm_ver.major = ver->version_major;
+      drm_ver.minor = ver->version_minor;
+
+      drmFreeVersion(ver);
+      if (!vmw_dri1_check_version(&drm_ver, &drm_required,
+				  &drm_compat, "vmwgfx drm driver"))
+	 return NULL;
+   }
+
    if (arg != NULL) {
       switch (arg->mode) {
       case DRM_CREATE_NORMAL:
@@ -220,22 +237,19 @@ vmw_dri1_present_locked(struct pipe_context *locked_pipe,
    vmw_svga_winsys_surface_reference(&vsrf, NULL);
 }
 
-/**
- * FIXME: We'd probably want to cache these buffers in the
- * screen, based on handle.
- */
-
-static struct pipe_buffer *
-vmw_drm_buffer_from_handle(struct drm_api *drm_api,
-                           struct pipe_screen *screen,
-			   const char *name,
-			   unsigned handle)
+static struct pipe_texture *
+vmw_drm_texture_from_handle(struct drm_api *drm_api,
+			    struct pipe_screen *screen,
+			    struct pipe_texture *templat,
+			    const char *name,
+			    unsigned stride,
+			    unsigned handle)
 {
     struct vmw_svga_winsys_surface *vsrf;
     struct svga_winsys_surface *ssrf;
     struct vmw_winsys_screen *vws =
 	vmw_winsys_screen(svga_winsys_screen(screen));
-    struct pipe_buffer *buf;
+    struct pipe_texture *tex;
     union drm_vmw_surface_reference_arg arg;
     struct drm_vmw_surface_arg *req = &arg.req;
     struct drm_vmw_surface_create_req *rep = &arg.rep;
@@ -282,43 +296,28 @@ vmw_drm_buffer_from_handle(struct drm_api *drm_api,
 
     pipe_reference_init(&vsrf->refcnt, 1);
     p_atomic_set(&vsrf->validated, 0);
+    vsrf->screen = vws;
     vsrf->sid = handle;
     ssrf = svga_winsys_surface(vsrf);
-    buf = svga_screen_buffer_wrap_surface(screen, rep->format, ssrf);
-    if (!buf)
+    tex = svga_screen_texture_wrap_surface(screen, templat, rep->format, ssrf);
+    if (!tex)
 	vmw_svga_winsys_surface_reference(&vsrf, NULL);
 
-    return buf;
+    return tex;
   out_mip:
     vmw_ioctl_surface_destroy(vws, handle);
     return NULL;
 }
 
-static struct pipe_texture *
-vmw_drm_texture_from_handle(struct drm_api *drm_api,
-			    struct pipe_screen *screen,
-			    struct pipe_texture *templat,
-			    const char *name,
-			    unsigned stride,
-			    unsigned handle)
-{
-    struct pipe_buffer *buffer;
-    buffer = vmw_drm_buffer_from_handle(drm_api, screen, name, handle);
-
-    if (!buffer)
-	return NULL;
-
-    return screen->texture_blanket(screen, templat, &stride, buffer);
-}
-
 static boolean
-vmw_drm_handle_from_buffer(struct drm_api *drm_api,
+vmw_drm_handle_from_texture(struct drm_api *drm_api,
                            struct pipe_screen *screen,
-			   struct pipe_buffer *buffer,
+			   struct pipe_texture *texture,
+			   unsigned *stride,
 			   unsigned *handle)
 {
     struct svga_winsys_surface *surface =
-	svga_screen_buffer_get_winsys_surface(buffer);
+	svga_screen_texture_get_winsys_surface(texture);
     struct vmw_svga_winsys_surface *vsrf;
 
     if (!surface)
@@ -326,25 +325,13 @@ vmw_drm_handle_from_buffer(struct drm_api *drm_api,
 
     vsrf = vmw_svga_winsys_surface(surface);
     *handle = vsrf->sid;
+    *stride = pf_get_nblocksx(&texture->block, texture->width[0]) *
+	texture->block.size;
+
     vmw_svga_winsys_surface_reference(&vsrf, NULL);
     return TRUE;
 }
 
-static boolean
-vmw_drm_handle_from_texture(struct drm_api *drm_api,
-			    struct pipe_screen *screen,
-			    struct pipe_texture *texture,
-			    unsigned *stride,
-			    unsigned *handle)
-{
-    struct pipe_buffer *buffer;
-
-    if (!svga_screen_buffer_from_texture(texture, &buffer, stride))
-	return FALSE;
-
-    return vmw_drm_handle_from_buffer(drm_api, screen, buffer, handle);
-}
-
 static struct pipe_context*
 vmw_drm_create_context(struct drm_api *drm_api,
                        struct pipe_screen *screen)
@@ -358,6 +345,7 @@ static struct dri1_api dri1_api_hooks = {
 };
 
 static struct drm_api vmw_drm_api_hooks = {
+   .driver_name = "vmwgfx",
    .create_screen = vmw_drm_create_screen,
    .create_context = vmw_drm_create_context,
    .texture_from_shared_handle = vmw_drm_texture_from_handle,
diff --git a/src/gallium/winsys/drm/vmware/core/vmw_screen_pools.c b/src/gallium/winsys/drm/vmware/core/vmw_screen_pools.c
index b1c24b0..b9823d7 100644
--- a/src/gallium/winsys/drm/vmware/core/vmw_screen_pools.c
+++ b/src/gallium/winsys/drm/vmware/core/vmw_screen_pools.c
@@ -53,14 +53,32 @@ vmw_pools_init(struct vmw_winsys_screen *vws)
       goto error;
 
    vws->pools.gmr_mm = mm_bufmgr_create(vws->pools.gmr,
-                                        16*1024*1024,
+                                        VMW_GMR_POOL_SIZE,
                                         12 /* 4096 alignment */);
    if(!vws->pools.gmr_mm)
       goto error;
 
+   /*
+    * GMR buffers are typically shortlived, but it's possible that at a given
+    * instance a buffer is mapped. So to avoid stalling we tell pipebuffer to
+    * forbid creation of buffers beyond half the GMR pool size,
+    *
+    * XXX: It is unclear weather we want to limit the total amount of temporary
+    * malloc memory used to backup unvalidated GMR buffers. On one hand it is
+    * preferrable to fail an allocation than exhausting the guest memory with
+    * temporary data, but on the other hand it is possible that a stupid
+    * application creates large vertex buffers and does not use them for a long
+    * time -- since the svga pipe driver only emits the DMA uploads when a
+    * buffer is used for drawing this would effectively disabling swapping GMR
+    * buffers to memory. So far, the preemptively flush already seems to keep
+    * total allocated memory within relatively small numbers, so we don't
+    * limit.
+    */
    vws->pools.gmr_fenced = fenced_bufmgr_create(
       vws->pools.gmr_mm,
-      vmw_fence_ops_create(vws));
+      vmw_fence_ops_create(vws),
+      VMW_GMR_POOL_SIZE/2,
+      ~0);
 
 #ifdef DEBUG
    vws->pools.gmr_fenced = pb_debug_manager_create(vws->pools.gmr_fenced,
diff --git a/src/gallium/winsys/drm/vmware/xorg/vmw_video.c b/src/gallium/winsys/drm/vmware/xorg/vmw_video.c
index b065b96..ff3b992 100644
--- a/src/gallium/winsys/drm/vmware/xorg/vmw_video.c
+++ b/src/gallium/winsys/drm/vmware/xorg/vmw_video.c
@@ -649,7 +649,8 @@ vmw_video_port_play(ScrnInfoPtr pScrn, struct vmw_video_port *port,
 	return XvBadAlloc;
     }
 
-    port->currBuf = ++port->currBuf & (VMWARE_VID_NUM_BUFFERS - 1);
+    if (++(port->currBuf) >= VMWARE_VID_NUM_BUFFERS)
+	port->currBuf = 0;
 
     return Success;
 }
diff --git a/src/gallium/winsys/drm/vmware/xorg/vmw_xorg.c b/src/gallium/winsys/drm/vmware/xorg/vmw_xorg.c
index 4b20871..cd273d0 100644
--- a/src/gallium/winsys/drm/vmware/xorg/vmw_xorg.c
+++ b/src/gallium/winsys/drm/vmware/xorg/vmw_xorg.c
@@ -34,10 +34,10 @@
 #include "vmw_hook.h"
 
 static void vmw_xorg_identify(int flags);
-static Bool vmw_xorg_pci_probe(DriverPtr driver,
-			       int entity_num,
-			       struct pci_device *device,
-			       intptr_t match_data);
+_X_EXPORT Bool vmw_xorg_pci_probe(DriverPtr driver,
+				  int entity_num,
+				  struct pci_device *device,
+				  intptr_t match_data);
 
 static const struct pci_id_match vmw_xorg_device_match[] = {
     {0x15ad, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, 0},
@@ -126,7 +126,7 @@ vmw_xorg_identify(int flags)
 		      vmw_xorg_chipsets);
 }
 
-static Bool
+_X_EXPORT Bool
 vmw_xorg_pci_probe(DriverPtr driver,
 	  int entity_num, struct pci_device *device, intptr_t match_data)
 {
diff --git a/src/gallium/winsys/gdi/SConscript b/src/gallium/winsys/gdi/SConscript
index 8f556da..917a81c 100644
--- a/src/gallium/winsys/gdi/SConscript
+++ b/src/gallium/winsys/gdi/SConscript
@@ -42,6 +42,8 @@ if env['platform'] == 'windows':
         
     drivers += [trace]
 
+    env['no_import_lib'] = 1
+
     env.SharedLibrary(
         target ='opengl32',
         source = sources,
diff --git a/src/gallium/winsys/xlib/xlib_brw_context.c b/src/gallium/winsys/xlib/xlib_brw_context.c
new file mode 100644
index 0000000..fc9addd
--- /dev/null
+++ b/src/gallium/winsys/xlib/xlib_brw_context.c
@@ -0,0 +1,209 @@
+/**************************************************************************
+ * 
+ * Copyright 2007 Tungsten Graphics, Inc., Bismarck, ND., USA
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * 
+ **************************************************************************/
+
+/*
+ * Authors:
+ *   Keith Whitwell
+ *   Brian Paul
+ */
+
+
+/* #include "glxheader.h" */
+/* #include "xmesaP.h" */
+
+#include "pipe/internal/p_winsys_screen.h"
+#include "pipe/p_inlines.h"
+#include "util/u_math.h"
+#include "util/u_memory.h"
+#include "i965simple/brw_winsys.h"
+#include "xlib_brw_aub.h"
+#include "xlib_brw.h"
+
+
+
+
+#define XBCWS_BATCHBUFFER_SIZE 1024
+
+
+/* The backend to the brw driver (ie struct brw_winsys) is actually a
+ * per-context entity.
+ */
+struct xlib_brw_context_winsys {
+   struct brw_winsys brw_context_winsys;   /**< batch buffer funcs */
+   struct aub_context *aub;
+                         
+   struct pipe_winsys *pipe_winsys;
+
+   unsigned batch_data[XBCWS_BATCHBUFFER_SIZE];
+   unsigned batch_nr;
+   unsigned batch_size;
+   unsigned batch_alloc;
+};
+
+
+/* Turn a brw_winsys into an xlib_brw_context_winsys:
+ */
+static inline struct xlib_brw_context_winsys *
+xlib_brw_context_winsys( struct brw_winsys *sws )
+{
+   return (struct xlib_brw_context_winsys *)sws;
+}
+
+
+/* Simple batchbuffer interface:
+ */
+
+static unsigned *xbcws_batch_start( struct brw_winsys *sws,
+					 unsigned dwords,
+					 unsigned relocs )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   if (xbcws->batch_size < xbcws->batch_nr + dwords)
+      return NULL;
+
+   xbcws->batch_alloc = xbcws->batch_nr + dwords;
+   return (void *)1;			/* not a valid pointer! */
+}
+
+static void xbcws_batch_dword( struct brw_winsys *sws,
+				    unsigned dword )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr < xbcws->batch_alloc);
+   xbcws->batch_data[xbcws->batch_nr++] = dword;
+}
+
+static void xbcws_batch_reloc( struct brw_winsys *sws,
+			     struct pipe_buffer *buf,
+			     unsigned access_flags,
+			     unsigned delta )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr < xbcws->batch_alloc);
+   xbcws->batch_data[xbcws->batch_nr++] = 
+      ( xlib_brw_get_buffer_offset( NULL, buf, access_flags ) +
+        delta );
+}
+
+static void xbcws_batch_end( struct brw_winsys *sws )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   assert(xbcws->batch_nr <= xbcws->batch_alloc);
+   xbcws->batch_alloc = 0;
+}
+
+static void xbcws_batch_flush( struct brw_winsys *sws,
+				    struct pipe_fence_handle **fence )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+   assert(xbcws->batch_nr <= xbcws->batch_size);
+
+   if (xbcws->batch_nr) {
+      xlib_brw_commands_aub( xbcws->pipe_winsys,
+                             xbcws->batch_data,
+                             xbcws->batch_nr );
+   }
+
+   xbcws->batch_nr = 0;
+}
+
+  
+
+/* Really a per-device function, just pass through:
+ */
+static unsigned xbcws_get_buffer_offset( struct brw_winsys *sws,
+                                         struct pipe_buffer *buf,
+                                         unsigned access_flags )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   return xlib_brw_get_buffer_offset( xbcws->pipe_winsys,
+                                      buf,
+                                      access_flags );
+}
+
+
+/* Really a per-device function, just pass through:
+ */
+static void xbcws_buffer_subdata_typed( struct brw_winsys *sws,
+                                       struct pipe_buffer *buf,
+                                       unsigned long offset, 
+                                       unsigned long size, 
+                                       const void *data,
+                                       unsigned data_type )
+{
+   struct xlib_brw_context_winsys *xbcws = xlib_brw_context_winsys(sws);
+
+   xlib_brw_buffer_subdata_typed( xbcws->pipe_winsys,
+                                  buf,
+                                  offset,
+                                  size,
+                                  data,
+                                  data_type );
+}
+
+
+/**
+ * Create i965 hardware rendering context, but plugged into a
+ * dump-to-aubfile backend.
+ */
+struct pipe_context *
+xlib_create_brw_context( struct pipe_screen *screen,
+                         void *unused )
+{
+   struct xlib_brw_context_winsys *xbcws = CALLOC_STRUCT( xlib_brw_context_winsys );
+   
+   /* Fill in this struct with callbacks that i965simple will need to
+    * communicate with the window system, buffer manager, etc. 
+    */
+   xbcws->brw_context_winsys.batch_start = xbcws_batch_start;
+   xbcws->brw_context_winsys.batch_dword = xbcws_batch_dword;
+   xbcws->brw_context_winsys.batch_reloc = xbcws_batch_reloc;
+   xbcws->brw_context_winsys.batch_end = xbcws_batch_end;
+   xbcws->brw_context_winsys.batch_flush = xbcws_batch_flush;
+   xbcws->brw_context_winsys.buffer_subdata_typed = xbcws_buffer_subdata_typed;
+   xbcws->brw_context_winsys.get_buffer_offset = xbcws_get_buffer_offset;
+
+   xbcws->pipe_winsys = screen->winsys; /* redundant */
+
+   xbcws->batch_size = XBCWS_BATCHBUFFER_SIZE;
+
+   /* Create the i965simple context:
+    */
+#ifdef GALLIUM_CELL
+   return NULL;
+#else
+   return brw_create( screen,
+		      &xbcws->brw_context_winsys,
+		      0 );
+#endif
+}
diff --git a/src/gallium/winsys/xlib/xlib_softpipe.c b/src/gallium/winsys/xlib/xlib_softpipe.c
index 260b39e..9769eb0 100644
--- a/src/gallium/winsys/xlib/xlib_softpipe.c
+++ b/src/gallium/winsys/xlib/xlib_softpipe.c
@@ -62,7 +62,7 @@ struct xm_buffer
 
    XImage *tempImage;
 #ifdef USE_XSHM
-   int shm;
+   boolean shm;         /** Is this a shared memory buffer? */
    XShmSegmentInfo shminfo;
 #endif
 };
@@ -151,7 +151,7 @@ alloc_shm_ximage(struct xm_buffer *b, struct xmesa_buffer *xmb,
                                   &b->shminfo,
                                   width, height);
    if (b->tempImage == NULL) {
-      b->shm = 0;
+      b->shm = FALSE;
       return;
    }
 
@@ -168,12 +168,12 @@ alloc_shm_ximage(struct xm_buffer *b, struct xmesa_buffer *xmb,
       mesaXErrorFlag = 0;
       XDestroyImage(b->tempImage);
       b->tempImage = NULL;
-      b->shm = 0;
+      b->shm = FALSE;
       (void) XSetErrorHandler(old_handler);
       return;
    }
 
-   b->shm = 1;
+   b->shm = TRUE;
 }
 
 #endif /* USE_XSHM */
@@ -203,6 +203,14 @@ xm_buffer_destroy(struct pipe_buffer *buf)
 {
    struct xm_buffer *oldBuf = xm_buffer(buf);
 
+   /*
+    * Note oldBuf->data may point to one of three things:
+    * 1. XShm shared memory image data
+    * 2. User-provided (wrapped) memory, see xm_user_buffer_create()
+    * 3. Regular, malloc'd memory
+    * We need to be careful with freeing that data now.
+    */
+
    if (oldBuf->data) {
 #ifdef USE_XSHM
       if (oldBuf->shminfo.shmid >= 0) {
@@ -212,12 +220,20 @@ xm_buffer_destroy(struct pipe_buffer *buf)
          oldBuf->shminfo.shmid = -1;
          oldBuf->shminfo.shmaddr = (char *) -1;
       }
-      else
+
+      if (oldBuf->shm) {
+         oldBuf->data = NULL;
+      }
+
+      if (oldBuf->tempImage) {
+         XDestroyImage(oldBuf->tempImage);
+         oldBuf->tempImage = NULL;
+      }
 #endif
-      {
-         if (!oldBuf->userBuffer) {
-            align_free(oldBuf->data);
-         }
+
+      if (oldBuf->data && !oldBuf->userBuffer) {
+         /* this was regular malloc'd memory */
+         align_free(oldBuf->data);
       }
 
       oldBuf->data = NULL;
@@ -326,10 +342,8 @@ xm_buffer_create(struct pipe_winsys *pws,
    buffer->base.usage = usage;
    buffer->base.size = size;
 
-   if (buffer->data == NULL) {
-      /* align to 16-byte multiple for Cell */
-      buffer->data = align_malloc(size, max(alignment, 16));
-   }
+   /* align to 16-byte multiple for Cell */
+   buffer->data = align_malloc(size, max(alignment, 16));
 
    return &buffer->base;
 }
diff --git a/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h b/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
index 4493296..ba6868a 100644
--- a/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
+++ b/src/glu/sgi/libnurbs/interface/bezierPatchMesh.h
@@ -33,6 +33,7 @@
 #ifndef _BEZIERPATCHMESH_H
 #define _BEZIERPATCHMESH_H
 
+#include <GL/gl.h>
 #include "bezierPatch.h"
 
 typedef struct bezierPatchMesh{
diff --git a/src/glu/sgi/libnurbs/interface/glsurfeval.h b/src/glu/sgi/libnurbs/interface/glsurfeval.h
index 1567c6b..621e593 100644
--- a/src/glu/sgi/libnurbs/interface/glsurfeval.h
+++ b/src/glu/sgi/libnurbs/interface/glsurfeval.h
@@ -83,7 +83,7 @@ typedef struct surfEvalMachine{
 
 class StoredVertex {
 public:
-    		StoredVertex() { type = 0; }
+    		StoredVertex() { type = 0; coord[0] = 0; coord[1] = 0; point[0] = 0; point[1] = 0; }
 		~StoredVertex(void) {}
     void	saveEvalCoord(REAL x, REAL y) 
 		    {coord[0] = x; coord[1] = y; type = TYPECOORD; }
diff --git a/src/glu/sgi/libnurbs/internals/arcsorter.h b/src/glu/sgi/libnurbs/internals/arcsorter.h
index d72dd1e..a55df92 100644
--- a/src/glu/sgi/libnurbs/internals/arcsorter.h
+++ b/src/glu/sgi/libnurbs/internals/arcsorter.h
@@ -37,7 +37,6 @@
 #define __gluarcsorter_h_
 
 #include "sorter.h"
-#include "arcsorter.h"
 
 class Arc;
 class Subdivider;
diff --git a/src/glu/sgi/libnurbs/internals/displaylist.h b/src/glu/sgi/libnurbs/internals/displaylist.h
index 22cbec3..d009a42 100644
--- a/src/glu/sgi/libnurbs/internals/displaylist.h
+++ b/src/glu/sgi/libnurbs/internals/displaylist.h
@@ -59,6 +59,7 @@ Dlnode::Dlnode( PFVS _work, void *_arg, PFVS _cleanup )
     work = _work;
     arg = _arg;
     cleanup = _cleanup;
+    next = 0;
 }
 
 class DisplayList {
diff --git a/src/glu/sgi/libnurbs/internals/gridvertex.h b/src/glu/sgi/libnurbs/internals/gridvertex.h
index 36a65c7..2e27436 100644
--- a/src/glu/sgi/libnurbs/internals/gridvertex.h
+++ b/src/glu/sgi/libnurbs/internals/gridvertex.h
@@ -38,7 +38,7 @@
 
 struct GridVertex {
     long 		gparam[2];
-			GridVertex( void ) {}
+			GridVertex( void ) { gparam[0] = 0, gparam[1] = 0; }
 			GridVertex( long u, long v ) { gparam[0] = u, gparam[1] = v; }
     void		set( long u, long v ) { gparam[0] = u, gparam[1] = v; }
     long		nextu() { return gparam[0]++; }
diff --git a/src/glu/sgi/libnurbs/internals/knotvector.cc b/src/glu/sgi/libnurbs/internals/knotvector.cc
index 9eb5cba..dcbf006 100644
--- a/src/glu/sgi/libnurbs/internals/knotvector.cc
+++ b/src/glu/sgi/libnurbs/internals/knotvector.cc
@@ -61,6 +61,9 @@ void Knotvector::init( long _knotcount, long _stride, long _order, INREAL *_knot
 
 Knotvector::Knotvector( void )
 {
+    knotcount = 0;
+    stride = 0;
+    order = 0;
     knotlist = 0;
 }
 
diff --git a/src/glu/sgi/libnurbs/internals/mesher.cc b/src/glu/sgi/libnurbs/internals/mesher.cc
index 9cc436a..b2d83f4 100644
--- a/src/glu/sgi/libnurbs/internals/mesher.cc
+++ b/src/glu/sgi/libnurbs/internals/mesher.cc
@@ -58,6 +58,9 @@ Mesher::Mesher( Backend& b )
 {
     stacksize = 0;
     vdata = 0;
+    last[0] = 0;
+    last[1] = 0;
+    itop = 0;
     lastedge = 0; //needed to prevent purify UMR 
 }
 
diff --git a/src/glu/sgi/libnurbs/internals/reader.cc b/src/glu/sgi/libnurbs/internals/reader.cc
index 6135eef..c59240d 100644
--- a/src/glu/sgi/libnurbs/internals/reader.cc
+++ b/src/glu/sgi/libnurbs/internals/reader.cc
@@ -64,6 +64,7 @@ O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride,
     owner = 0;
     pts = trimpts;
     npts = (int) count;
+    save = 0;
     int i;
 
     /* copy user data into internal trimming data structures */
@@ -115,6 +116,7 @@ O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride,
     owner = 0;
     pts = trimpts;
     npts = (int) count;
+    save = 0;
 
     /* copy user data into internal trimming data structures */
     switch( _type ) {
diff --git a/src/glu/sgi/libnurbs/internals/reader.h b/src/glu/sgi/libnurbs/internals/reader.h
index 8a8dceb..cae6cad 100644
--- a/src/glu/sgi/libnurbs/internals/reader.h
+++ b/src/glu/sgi/libnurbs/internals/reader.h
@@ -64,7 +64,7 @@ struct O_curve : public PooledObj {
     int			save;		/* 1 if in display list		*/
     long		nuid;
     			O_curve() { next = 0; used = 0; owner = 0; 
-				    curve.o_pwlcurve = 0; }
+				    curve.o_pwlcurve = 0; curvetype = ct_none; save = 0; nuid = 0; }
     };
 
 struct O_nurbscurve : public PooledObj {
@@ -77,7 +77,7 @@ struct O_nurbscurve : public PooledObj {
     int			save;		/* 1 if in display list		*/
     O_curve *		owner;		/* owning curve 		*/
 			O_nurbscurve( long _type ) 
-			   { type = _type; owner = 0; next = 0; used = 0; }
+			   { bezier_curves = 0; type = _type; tesselation = 0; method = 0; next = 0; used = 0; save = 0; owner = 0; }
     };
  
 class O_pwlcurve : public PooledObj {
@@ -95,7 +95,7 @@ struct O_trim : public PooledObj {
     O_curve		*o_curve;	/* closed trim loop	 	*/
     O_trim *		next;		/* next loop along trim 	*/
     int			save;		/* 1 if in display list		*/
-			O_trim() { next = 0; o_curve = 0; }
+			O_trim() { next = 0; o_curve = 0; save = 0; }
     };
 
 struct O_nurbssurface : public PooledObj {
@@ -106,7 +106,7 @@ struct O_nurbssurface : public PooledObj {
     int			save;		/* 1 if in display list		*/
     int			used;		/* 1 if prev called in block	*/
 			O_nurbssurface( long _type ) 
-			   { type = _type; owner = 0; next = 0; used = 0; }
+			   { bezier_patches = 0; type = _type; owner = 0; next = 0; save = 0; used = 0; }
     };
 
 struct O_surface : public PooledObj {
@@ -114,7 +114,7 @@ struct O_surface : public PooledObj {
     O_trim *		o_trim;		/* list of trim loops		*/
     int			save;		/* 1 if in display list		*/
     long		nuid;
-			O_surface() { o_trim = 0; o_nurbssurface = 0; }
+			O_surface() { o_trim = 0; o_nurbssurface = 0; save = 0; nuid = 0; }
     };
 
 struct Property : public PooledObj {
@@ -123,9 +123,9 @@ struct Property : public PooledObj {
     REAL		value;
     int			save;		/* 1 if in display list		*/
 			Property( long _type, long _tag, INREAL _value )
-			{ type = _type; tag = _tag; value = (REAL) _value; }
+			{ type = _type; tag = _tag; value = (REAL) _value; save = 0; }
 			Property( long _tag, INREAL _value )
-			{ type = 0; tag = _tag; value = (REAL) _value; }
+			{ type = 0; tag = _tag; value = (REAL) _value; save = 0; }
     };
 
 class NurbsTessellator;
diff --git a/src/glu/sgi/libnurbs/internals/renderhints.cc b/src/glu/sgi/libnurbs/internals/renderhints.cc
index a3aa62d..7025f74 100644
--- a/src/glu/sgi/libnurbs/internals/renderhints.cc
+++ b/src/glu/sgi/libnurbs/internals/renderhints.cc
@@ -54,6 +54,10 @@ Renderhints::Renderhints()
     errorchecking 	= N_MSG;
     subdivisions 	= 6.0;
     tmp1 		= 0.0;
+    displaydomain 	= 0;
+    maxsubdivisions 	= (int) subdivisions;
+    wiretris	 	= 0;
+    wirequads	 	= 0;
 }
 
 void
diff --git a/src/glu/sgi/libnurbs/internals/simplemath.h b/src/glu/sgi/libnurbs/internals/simplemath.h
index 0a060c5..d00062d 100644
--- a/src/glu/sgi/libnurbs/internals/simplemath.h
+++ b/src/glu/sgi/libnurbs/internals/simplemath.h
@@ -38,6 +38,8 @@
 
 /* simple inline routines */
 
+#include "types.h"
+
 inline int 
 max( int x, int y ) { return ( x < y ) ? y : x; }
 
diff --git a/src/glu/sgi/libnurbs/internals/slicer.cc b/src/glu/sgi/libnurbs/internals/slicer.cc
index 27d2a65..1b18d73 100644
--- a/src/glu/sgi/libnurbs/internals/slicer.cc
+++ b/src/glu/sgi/libnurbs/internals/slicer.cc
@@ -1181,6 +1181,10 @@ void Slicer::slice(Arc_ptr loop)
 Slicer::Slicer( Backend &b ) 
 	: CoveAndTiler( b ), Mesher( b ), backend( b )
 {
+    oneOverDu = 0;
+    du = 0;
+    dv = 0;
+    isolines = 0;
     ulinear = 0;
     vlinear = 0;
 }
diff --git a/src/glu/sgi/libnurbs/internals/subdivider.cc b/src/glu/sgi/libnurbs/internals/subdivider.cc
index cc0b514..ccddc27 100644
--- a/src/glu/sgi/libnurbs/internals/subdivider.cc
+++ b/src/glu/sgi/libnurbs/internals/subdivider.cc
@@ -531,16 +531,18 @@ Subdivider::nonSamplingSplit(
 		     patchlist.pspec[param].range[1] ) * 0.5;
 	split( source, left, right, param, mid );
 	Patchlist subpatchlist( patchlist, param, mid );
-	if( left.isnonempty() )
+	if( left.isnonempty() ) {
 	    if( subpatchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
 		freejarcs( left );
 	    else
 	        nonSamplingSplit( left, subpatchlist, subdivisions-1, param );
-	if( right.isnonempty() ) 
+	}
+	if( right.isnonempty() ) {
 	    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
 		freejarcs( right );
 	    else
 	        nonSamplingSplit( right, patchlist, subdivisions-1, param );
+	}
 
     } else {
 	// make bbox calls
diff --git a/src/glu/sgi/libnurbs/internals/varray.cc b/src/glu/sgi/libnurbs/internals/varray.cc
index 31cc73a..1cb2354 100644
--- a/src/glu/sgi/libnurbs/internals/varray.cc
+++ b/src/glu/sgi/libnurbs/internals/varray.cc
@@ -53,8 +53,16 @@ inline long sgn( REAL x )
 
 Varray::Varray( void )
 {
+    int i;
+
     varray = 0;
     size = 0;
+    numquads = 0;
+
+    for (i = 0; i < 1000; i++) {
+        vval[i] = 0;
+        voffset[i] = 0;
+    }
 }
 
 Varray::~Varray( void )
diff --git a/src/glu/sgi/libnurbs/nurbtess/directedLine.cc b/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
index 7445035..d942db7 100644
--- a/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/directedLine.cc
@@ -309,6 +309,8 @@ directedLine::directedLine()
   nextPolygon = NULL;
   rootBit = 0;/*important to initilzae to 0 meaning not root yet*/
   rootLink = NULL;
+  direction = INCREASING;
+  sline = NULL;
 }
 
 directedLine::~directedLine()
@@ -791,22 +793,30 @@ directedLine* readAllPolygons(char* filename)
 {
   Int i,j;
   FILE* fp = fopen(filename, "r");
-  assert(fp);
   Int nPolygons;
-  fscanf(fp, "%i", &nPolygons);
+  int result;
+
+  assert(fp);
+  result = fscanf(fp, "%i", &nPolygons);
+  assert(result != EOF);
   directedLine *ret = NULL;
 
   for(i=0; i<nPolygons; i++)
     {
       Int nEdges;
-      fscanf(fp, "%i", &nEdges);
-      Real vert[2][2];
+      result = fscanf(fp, "%i", &nEdges);
+      assert(result != EOF);
+      Real vert[2][2] = { { 0 } };
       Real VV[2][2];
       /*the first two vertices*/
-      fscanf(fp, "%f", &(vert[0][0]));
-      fscanf(fp, "%f", &(vert[0][1]));
-      fscanf(fp, "%f", &(vert[1][0]));
-      fscanf(fp, "%f", &(vert[1][1]));
+      result = fscanf(fp, "%f", &(vert[0][0]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[0][1]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[1][0]));
+      assert(result != EOF);
+      result = fscanf(fp, "%f", &(vert[1][1]));
+      assert(result != EOF);
       VV[1][0] = vert[0][0];
       VV[1][1] = vert[0][1];
       sampledLine *sLine = new sampledLine(2, vert);
@@ -818,8 +828,10 @@ thisPoly->rootLinkSet(NULL);
 	{
 	  vert[0][0]=vert[1][0];
 	  vert[0][1]=vert[1][1];
-	  fscanf(fp, "%f", &(vert[1][0]));
-	  fscanf(fp, "%f", &(vert[1][1]));
+	  result = fscanf(fp, "%f", &(vert[1][0]));
+	  assert(result != EOF);
+	  result = fscanf(fp, "%f", &(vert[1][1]));
+	  assert(result != EOF);
 	  sLine = new sampledLine(2,vert);
 	  dLine = new directedLine(INCREASING, sLine);
 dLine->rootLinkSet(thisPoly);
diff --git a/src/glu/sgi/libnurbs/nurbtess/monoChain.cc b/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
index 814bf32..b17b940 100644
--- a/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/monoChain.cc
@@ -127,6 +127,7 @@ monoChain::monoChain(directedLine* cHead, directedLine* cTail)
     current = chainTail;
 
   isKey = 0;
+  keyY = 0;
 }
 
 //insert a new line between prev and this
diff --git a/src/glu/sgi/libnurbs/nurbtess/partitionY.cc b/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
index 297c629..e097461 100644
--- a/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/partitionY.cc
@@ -111,8 +111,8 @@ Int isCusp(directedLine *v)
   else if(A[1] > B[1] && C[1] > B[1])
     return 1;
 
-  if(isAbove(v, v) && isAbove(v, v->getPrev()) ||
-     isBelow(v, v) && isBelow(v, v->getPrev()))
+  if((isAbove(v, v) && isAbove(v, v->getPrev())) ||
+     (isBelow(v, v) && isBelow(v, v->getPrev())))
     return 1;
   else
     return 0;
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc b/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
index e12f88b..2e70f83 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampleCompBot.cc
@@ -207,7 +207,7 @@ void sampleBotRightWithGridLine(Real* botVertex,
     return;
   }
 
-  Int segIndexMono, segIndexPass;
+  Int segIndexMono = 0, segIndexPass;
   findBotRightSegment(rightChain,
 		      rightEnd,
 		      rightCorner,
@@ -293,7 +293,7 @@ void sampleBotLeftWithGridLine(Real* botVertex,
     return;
   }
 
-  Int segIndexPass, segIndexMono;
+  Int segIndexPass, segIndexMono = 0;
   findBotLeftSegment(leftChain, leftEnd, leftCorner, grid->get_u_value(leftU), segIndexMono, segIndexPass);
 
   sampleBotLeftWithGridLinePost(botVertex,
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc b/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
index b7b9296..951e937 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampleCompTop.cc
@@ -172,7 +172,7 @@ void sampleTopRightWithGridLine(Real* topVertex,
     return;
   }
 
-  Int segIndexSmall, segIndexLarge;
+  Int segIndexSmall = 0, segIndexLarge;
   findTopRightSegment(rightChain,
                       rightStart,
                       rightEnd,
@@ -294,7 +294,7 @@ void sampleTopLeftWithGridLine(Real* topVertex,
                                 primStream* pStream
                                 )
 {
-  Int segIndexSmall, segIndexLarge;
+  Int segIndexSmall = 0, segIndexLarge;
   //if left chain is empty, then there is only one top vertex with one grid 
   //  line
   if(leftEnd < leftStart) {
diff --git a/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc b/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
index 6253a7c..89f6c6e 100644
--- a/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
+++ b/src/glu/sgi/libnurbs/nurbtess/sampledLine.cc
@@ -107,6 +107,9 @@ sampledLine::sampledLine(Real pt1[2], Real pt2[2])
 //needs tp call init to setup
 sampledLine::sampledLine()
 {
+  npoints = 0;
+  points = NULL;
+  next = NULL;
 }
 
 //warning: ONLY pointer is copies!!!
diff --git a/src/glx/x11/dri2.c b/src/glx/x11/dri2.c
index e144ed3..dad0447 100644
--- a/src/glx/x11/dri2.c
+++ b/src/glx/x11/dri2.c
@@ -31,6 +31,8 @@
  */
 
 
+#ifdef GLX_DIRECT_RENDERING
+
 #define NEED_REPLIES
 #include <X11/Xlibint.h>
 #include <X11/extensions/Xext.h>
@@ -377,3 +379,5 @@ DRI2CopyRegion(Display * dpy, XID drawable, XserverRegion region,
    UnlockDisplay(dpy);
    SyncHandle();
 }
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/glx/x11/dri_glx.c b/src/glx/x11/dri_glx.c
index 4f7acb6..88487b6 100644
--- a/src/glx/x11/dri_glx.c
+++ b/src/glx/x11/dri_glx.c
@@ -280,8 +280,6 @@ static const __DRIextension *loader_extensions[] = {
    NULL
 };
 
-#ifndef GLX_USE_APPLEGL
-
 /**
  * Perform the required libGL-side initialization and call the client-side
  * driver's \c __driCreateNewScreen function.
@@ -475,17 +473,6 @@ CallCreateNewScreen(Display * dpy, int scrn, __GLXscreenConfigs * psc,
    return NULL;
 }
 
-#else /* !GLX_USE_APPLEGL */
-
-static void *
-CallCreateNewScreen(Display * dpy, int scrn, __GLXscreenConfigs * psc,
-                    __GLXDRIdisplayPrivate * driDpy)
-{
-   return NULL;
-}
-
-#endif /* !GLX_USE_APPLEGL */
-
 static void
 driDestroyContext(__GLXDRIcontext * context,
                   __GLXscreenConfigs * psc, Display * dpy)
diff --git a/src/glx/x11/glxcmds.c b/src/glx/x11/glxcmds.c
index daa9076..d1c68dd 100644
--- a/src/glx/x11/glxcmds.c
+++ b/src/glx/x11/glxcmds.c
@@ -2575,7 +2575,7 @@ glXAllocateMemoryMESA(Display * dpy, int scrn,
    (void) readFreq;
    (void) writeFreq;
    (void) priority;
-#endif /* GLX_DIRECT_RENDERING */
+#endif /* __DRI_ALLOCATE */
 
    return NULL;
 }
@@ -2594,7 +2594,7 @@ glXFreeMemoryMESA(Display * dpy, int scrn, void *pointer)
    (void) dpy;
    (void) scrn;
    (void) pointer;
-#endif /* GLX_DIRECT_RENDERING */
+#endif /* __DRI_ALLOCATE */
 }
 
 
diff --git a/src/glx/x11/glxcurrent.c b/src/glx/x11/glxcurrent.c
index f1e3e16..50de7d6 100644
--- a/src/glx/x11/glxcurrent.c
+++ b/src/glx/x11/glxcurrent.c
@@ -162,6 +162,7 @@ __glXSetCurrentContextNull(void)
    __glXSetCurrentContext(&dummyContext);
 #ifdef GLX_DIRECT_RENDERING
    _glapi_set_dispatch(NULL);   /* no-op functions */
+   _glapi_set_context(NULL);
 #endif
 }
 
@@ -475,13 +476,6 @@ MakeContextCurrent(Display * dpy, GLXDrawable draw,
                IndirectAPI = __glXNewIndirectAPI();
             _glapi_set_dispatch(IndirectAPI);
 
-#ifdef GLX_USE_APPLEGL
-            do {
-               extern void XAppleDRIUseIndirectDispatch(void);
-               XAppleDRIUseIndirectDispatch();
-            } while (0);
-#endif
-
             state = (__GLXattribute *) (gc->client_state_private);
 
             gc->currentContextTag = reply.contextTag;
diff --git a/src/glx/x11/glxext.c b/src/glx/x11/glxext.c
index e5553cb..5633a3e 100644
--- a/src/glx/x11/glxext.c
+++ b/src/glx/x11/glxext.c
@@ -150,8 +150,9 @@ FreeScreenConfigs(__GLXdisplayPrivate * priv)
 
 #ifdef GLX_DIRECT_RENDERING
       if (psc->driver_configs) {
-         for (unsigned int i = 0; psc->driver_configs[i]; i++)
-            free((__DRIconfig *) psc->driver_configs[i]);
+         unsigned int j;
+         for (j = 0; psc->driver_configs[j]; j++)
+            free((__DRIconfig *) psc->driver_configs[j]);
          free(psc->driver_configs);
          psc->driver_configs = NULL;
       }
diff --git a/src/glx/x11/xf86dri.h b/src/glx/x11/xf86dri.h
index f2d0dd5..ba26600 100644
--- a/src/glx/x11/xf86dri.h
+++ b/src/glx/x11/xf86dri.h
@@ -115,6 +115,10 @@ Bool XF86DRIGetDeviceInfo(Display * dpy, int screen,
                           int *fbSize, int *fbStride, int *devPrivateSize,
                           void **pDevPrivate);
 
+Bool XF86DRIOpenFullScreen(Display * dpy, int screen, Drawable drawable);
+
+Bool XF86DRICloseFullScreen(Display * dpy, int screen, Drawable drawable);
+
 _XFUNCPROTOEND
 #endif /* _XF86DRI_SERVER_ */
 #endif /* _XF86DRI_H_ */
diff --git a/src/mesa/Makefile b/src/mesa/Makefile
index 6f58ad6..96b4ff8 100644
--- a/src/mesa/Makefile
+++ b/src/mesa/Makefile
@@ -43,7 +43,7 @@ libglapi.a: $(GLAPI_OBJECTS)
 
 ######################################################################
 # Device drivers
-driver_subdirs: libmesa.a libglapi.a
+driver_subdirs: libmesa.a libglapi.a libmesagallium.a
 	@ (cd drivers && $(MAKE))
 
 
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index cd9075b..28abcc4 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -500,9 +500,9 @@ _mesa_meta_begin(GLcontext *ctx, GLbitfield state)
       _mesa_LoadIdentity();
       _mesa_MatrixMode(GL_PROJECTION);
       _mesa_LoadIdentity();
-      _mesa_Ortho(0.0F, ctx->DrawBuffer->Width,
-                  0.0F, ctx->DrawBuffer->Height,
-                  -1.0F, 1.0F);
+      _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
+                  0.0, ctx->DrawBuffer->Height,
+                  -1.0, 1.0);
       save->ClipPlanesEnabled = ctx->Transform.ClipPlanesEnabled;
       if (ctx->Transform.ClipPlanesEnabled) {
          GLuint i;
@@ -2289,6 +2289,26 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
 
    _mesa_set_enable(ctx, target, GL_TRUE);
 
+   /* setup vertex positions */
+   {
+      verts[0].x = 0.0F;
+      verts[0].y = 0.0F;
+      verts[1].x = 1.0F;
+      verts[1].y = 0.0F;
+      verts[2].x = 1.0F;
+      verts[2].y = 1.0F;
+      verts[3].x = 0.0F;
+      verts[3].y = 1.0F;
+      
+      /* upload new vertex data */
+      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
+   }
+
+   /* setup projection matrix */
+   _mesa_MatrixMode(GL_PROJECTION);
+   _mesa_LoadIdentity();
+   _mesa_Ortho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
+
    /* texture is already locked, unlock now */
    _mesa_unlock_texture(ctx, texObj);
 
@@ -2355,21 +2375,6 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
          }
       }
 
-      /* setup vertex positions */
-      {
-         verts[0].x = 0.0F;
-         verts[0].y = 0.0F;
-         verts[1].x = (GLfloat) dstWidth;
-         verts[1].y = 0.0F;
-         verts[2].x = (GLfloat) dstWidth;
-         verts[2].y = (GLfloat) dstHeight;
-         verts[3].x = 0.0F;
-         verts[3].y = (GLfloat) dstHeight;
-
-         /* upload new vertex data */
-         _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
-      }
-
       /* limit sampling to src level */
       _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, srcLevel);
       _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);
@@ -2408,6 +2413,12 @@ _mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
          break;
       }
 
+      assert(dstWidth == ctx->DrawBuffer->Width);
+      assert(dstHeight == ctx->DrawBuffer->Height);
+
+      /* setup viewport */
+      _mesa_set_viewport(ctx, 0, 0, dstWidth, dstHeight);
+
       _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
    }
 
diff --git a/src/mesa/drivers/dri/common/spantmp2.h b/src/mesa/drivers/dri/common/spantmp2.h
index 447f3d1..c152226 100644
--- a/src/mesa/drivers/dri/common/spantmp2.h
+++ b/src/mesa/drivers/dri/common/spantmp2.h
@@ -400,7 +400,7 @@
 #  define READ_RGBA( rgba, _x, _y )				        \
      do {								\
         GLuint p = GET_VALUE(_x, _y);					\
-        *((uint32_t *) rgba) = (t << 8) | 0xff;				\
+        *((uint32_t *) rgba) = (p << 8) | 0xff;				\
      } while (0)
 # else
 #  define READ_RGBA( rgba, _x, _y )				        \
diff --git a/src/mesa/drivers/dri/ffb/ffb_bitmap.c b/src/mesa/drivers/dri/ffb/ffb_bitmap.c
index f89c041..1240f1c 100644
--- a/src/mesa/drivers/dri/ffb/ffb_bitmap.c
+++ b/src/mesa/drivers/dri/ffb/ffb_bitmap.c
@@ -30,7 +30,6 @@
 #include "ffb_lock.h"
 #include "ffb_bitmap.h"
 #include "swrast/swrast.h"
-#include "main/image.h"
 #include "main/macros.h"
 
 /* Compute ceiling of integer quotient of A divided by B: */
diff --git a/src/mesa/drivers/dri/ffb/ffb_clear.c b/src/mesa/drivers/dri/ffb/ffb_clear.c
index 776fb48..6239a4e 100644
--- a/src/mesa/drivers/dri/ffb/ffb_clear.c
+++ b/src/mesa/drivers/dri/ffb/ffb_clear.c
@@ -26,15 +26,12 @@
  */
 
 #include "main/mtypes.h"
-#include "main/extensions.h"
 
 #include "main/mm.h"
 #include "ffb_dd.h"
 #include "ffb_span.h"
-#include "ffb_depth.h"
 #include "ffb_context.h"
 #include "ffb_vb.h"
-#include "ffb_tris.h"
 #include "ffb_clear.h"
 #include "ffb_lock.h"
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_dd.c b/src/mesa/drivers/dri/ffb/ffb_dd.c
index cf83b91..91b6d31 100644
--- a/src/mesa/drivers/dri/ffb/ffb_dd.c
+++ b/src/mesa/drivers/dri/ffb/ffb_dd.c
@@ -27,13 +27,9 @@
 
 #include "main/mtypes.h"
 #include "main/mm.h"
-#include "main/extensions.h"
 #include "ffb_dd.h"
 #include "ffb_span.h"
-#include "ffb_depth.h"
 #include "ffb_context.h"
-#include "ffb_vb.h"
-#include "ffb_tris.h"
 #include "ffb_clear.h"
 #include "ffb_lock.h"
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_depth.c b/src/mesa/drivers/dri/ffb/ffb_depth.c
index 71f204d..e82c241 100644
--- a/src/mesa/drivers/dri/ffb/ffb_depth.c
+++ b/src/mesa/drivers/dri/ffb/ffb_depth.c
@@ -26,7 +26,6 @@
  */
 
 #include "main/mtypes.h"
-#include "swrast/swrast.h"
 #include "ffb_dd.h"
 #include "ffb_span.h"
 #include "ffb_context.h"
diff --git a/src/mesa/drivers/dri/ffb/ffb_lines.c b/src/mesa/drivers/dri/ffb/ffb_lines.c
index 19dff50..6dca4ed 100644
--- a/src/mesa/drivers/dri/ffb/ffb_lines.c
+++ b/src/mesa/drivers/dri/ffb/ffb_lines.c
@@ -27,15 +27,11 @@
 
 #include "main/mtypes.h"
 #include "main/mm.h"
-#include "main/extensions.h"
 #include "ffb_dd.h"
 #include "ffb_span.h"
-#include "ffb_depth.h"
 #include "ffb_context.h"
 #include "ffb_vb.h"
 #include "ffb_lines.h"
-#include "ffb_tris.h"
-#include "ffb_lock.h"
 
 #undef FFB_LINE_TRACE
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_points.c b/src/mesa/drivers/dri/ffb/ffb_points.c
index 9c37a47..5bf4f8f 100644
--- a/src/mesa/drivers/dri/ffb/ffb_points.c
+++ b/src/mesa/drivers/dri/ffb/ffb_points.c
@@ -30,8 +30,6 @@
 #include "ffb_context.h"
 #include "ffb_vb.h"
 #include "ffb_points.h"
-#include "ffb_tris.h"
-#include "ffb_lock.h"
 
 
 #undef FFB_POINT_TRACE
diff --git a/src/mesa/drivers/dri/ffb/ffb_span.c b/src/mesa/drivers/dri/ffb/ffb_span.c
index 0d3d604..c4cb386 100644
--- a/src/mesa/drivers/dri/ffb/ffb_span.c
+++ b/src/mesa/drivers/dri/ffb/ffb_span.c
@@ -31,8 +31,6 @@
 #include "ffb_context.h"
 #include "ffb_lock.h"
 
-#include "swrast/swrast.h"
-
 #define DBG 0
 
 #define HW_LOCK()						\
diff --git a/src/mesa/drivers/dri/ffb/ffb_state.c b/src/mesa/drivers/dri/ffb/ffb_state.c
index 5eb8f41..81341cb 100644
--- a/src/mesa/drivers/dri/ffb/ffb_state.c
+++ b/src/mesa/drivers/dri/ffb/ffb_state.c
@@ -27,8 +27,6 @@
 
 #include "main/mtypes.h"
 #include "main/colormac.h"
-#include "main/mm.h"
-#include "main/extensions.h"
 #include "main/enums.h"
 
 #include "vbo/vbo.h"
@@ -39,12 +37,9 @@
 
 #include "ffb_dd.h"
 #include "ffb_span.h"
-#include "ffb_depth.h"
 #include "ffb_context.h"
-#include "ffb_vb.h"
 #include "ffb_tris.h"
 #include "ffb_state.h"
-#include "ffb_lock.h"
 
 #undef STATE_TRACE
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_stencil.c b/src/mesa/drivers/dri/ffb/ffb_stencil.c
index 921a83d..2be5a40 100644
--- a/src/mesa/drivers/dri/ffb/ffb_stencil.c
+++ b/src/mesa/drivers/dri/ffb/ffb_stencil.c
@@ -32,8 +32,6 @@
 #include "ffb_stencil.h"
 #include "ffb_lock.h"
 
-#include "swrast/swrast.h"
-
 #undef STENCIL_TRACE
 
 static void FFBWriteStencilSpan( GLcontext *ctx,
diff --git a/src/mesa/drivers/dri/ffb/ffb_tris.c b/src/mesa/drivers/dri/ffb/ffb_tris.c
index d785c15..e7dd960 100644
--- a/src/mesa/drivers/dri/ffb/ffb_tris.c
+++ b/src/mesa/drivers/dri/ffb/ffb_tris.c
@@ -352,7 +352,7 @@ static struct {
 #define LOCAL_VARS(n)				\
    ffbContextPtr fmesa = FFB_CONTEXT(ctx);	\
    __DRIdrawablePrivate *dPriv = fmesa->driDrawable; \
-   ffb_color color[n];				\
+   ffb_color color[n] = { { 0 } };		\
    (void) color; (void) dPriv;
 
 /***********************************************************************
diff --git a/src/mesa/drivers/dri/ffb/ffb_vb.c b/src/mesa/drivers/dri/ffb/ffb_vb.c
index f9c6fd1..ca8ffb2 100644
--- a/src/mesa/drivers/dri/ffb/ffb_vb.c
+++ b/src/mesa/drivers/dri/ffb/ffb_vb.c
@@ -30,8 +30,6 @@
 #include "ffb_vb.h"
 #include "main/imports.h"
 #include "tnl/t_context.h"
-#include "swrast_setup/swrast_setup.h"
-#include "math/m_translate.h"
 
 #undef VB_DEBUG
 
diff --git a/src/mesa/drivers/dri/ffb/ffb_xmesa.c b/src/mesa/drivers/dri/ffb/ffb_xmesa.c
index 09cc26d..28f8e53 100644
--- a/src/mesa/drivers/dri/ffb/ffb_xmesa.c
+++ b/src/mesa/drivers/dri/ffb/ffb_xmesa.c
@@ -28,7 +28,6 @@
 #include "ffb_xmesa.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
-#include "main/matrix.h"
 #include "main/renderbuffer.h"
 #include "main/simple_list.h"
 #include "main/imports.h"
@@ -52,7 +51,6 @@
 #include "ffb_lines.h"
 #include "ffb_points.h"
 #include "ffb_state.h"
-#include "ffb_tex.h"
 #include "ffb_lock.h"
 #include "ffb_vtxfmt.h"
 #include "ffb_bitmap.h"
diff --git a/src/mesa/drivers/dri/i810/i810context.c b/src/mesa/drivers/dri/i810/i810context.c
index 7311b2e..350c2e3 100644
--- a/src/mesa/drivers/dri/i810/i810context.c
+++ b/src/mesa/drivers/dri/i810/i810context.c
@@ -34,10 +34,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "main/glheader.h"
 #include "main/context.h"
-#include "main/matrix.h"
 #include "main/simple_list.h"
-#include "main/extensions.h"
-#include "main/framebuffer.h"
 #include "main/imports.h"
 #include "main/points.h"
 
diff --git a/src/mesa/drivers/dri/i810/i810render.c b/src/mesa/drivers/dri/i810/i810render.c
index 1d98e00..b543d4f 100644
--- a/src/mesa/drivers/dri/i810/i810render.c
+++ b/src/mesa/drivers/dri/i810/i810render.c
@@ -44,7 +44,6 @@
 
 #include "i810context.h"
 #include "i810tris.h"
-#include "i810state.h"
 #include "i810vb.h"
 #include "i810ioctl.h"
 
diff --git a/src/mesa/drivers/dri/i810/i810screen.c b/src/mesa/drivers/dri/i810/i810screen.c
index 2f6b863..b653958 100644
--- a/src/mesa/drivers/dri/i810/i810screen.c
+++ b/src/mesa/drivers/dri/i810/i810screen.c
@@ -36,8 +36,6 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/imports.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
-#include "main/fbobject.h"
-#include "main/matrix.h"
 #include "main/renderbuffer.h"
 #include "main/simple_list.h"
 #include "utils.h"
@@ -48,8 +46,6 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "i810state.h"
 #include "i810tex.h"
 #include "i810span.h"
-#include "i810tris.h"
-#include "i810ioctl.h"
 
 #include "GL/internal/dri_interface.h"
 
diff --git a/src/mesa/drivers/dri/i810/i810state.c b/src/mesa/drivers/dri/i810/i810state.c
index 1e7a6cf..a4b1477 100644
--- a/src/mesa/drivers/dri/i810/i810state.c
+++ b/src/mesa/drivers/dri/i810/i810state.c
@@ -20,8 +20,6 @@
 #include "i810context.h"
 #include "i810state.h"
 #include "i810tex.h"
-#include "i810vb.h"
-#include "i810tris.h"
 #include "i810ioctl.h"
 
 
diff --git a/src/mesa/drivers/dri/i810/i810tex.c b/src/mesa/drivers/dri/i810/i810tex.c
index 2f6978f..5c53032 100644
--- a/src/mesa/drivers/dri/i810/i810tex.c
+++ b/src/mesa/drivers/dri/i810/i810tex.c
@@ -33,7 +33,6 @@
 #include "main/colormac.h"
 #include "main/texobj.h"
 #include "main/mm.h"
-#include "swrast/swrast.h"
 
 #include "texmem.h"
 
@@ -42,7 +41,6 @@
 
 #include "i810context.h"
 #include "i810tex.h"
-#include "i810state.h"
 #include "i810ioctl.h"
 
 
diff --git a/src/mesa/drivers/dri/i810/i810tex.h b/src/mesa/drivers/dri/i810/i810tex.h
index d980927..28958dc 100644
--- a/src/mesa/drivers/dri/i810/i810tex.h
+++ b/src/mesa/drivers/dri/i810/i810tex.h
@@ -29,7 +29,6 @@
 #include "main/mtypes.h"
 #include "main/mm.h"
 
-#include "i810context.h"
 #include "i810_3d_reg.h"
 #include "texmem.h"
 
diff --git a/src/mesa/drivers/dri/i810/i810texmem.c b/src/mesa/drivers/dri/i810/i810texmem.c
index d93afbf..bb426a4 100644
--- a/src/mesa/drivers/dri/i810/i810texmem.c
+++ b/src/mesa/drivers/dri/i810/i810texmem.c
@@ -35,7 +35,6 @@
 #include "i810_dri.h"
 #include "i810context.h"
 #include "i810tex.h"
-#include "i810state.h"
 #include "i810ioctl.h"
 
 
diff --git a/src/mesa/drivers/dri/i810/i810vb.c b/src/mesa/drivers/dri/i810/i810vb.c
index 30890dc..09a7722 100644
--- a/src/mesa/drivers/dri/i810/i810vb.c
+++ b/src/mesa/drivers/dri/i810/i810vb.c
@@ -38,7 +38,6 @@
 #include "i810context.h"
 #include "i810vb.h"
 #include "i810ioctl.h"
-#include "i810tris.h"
 #include "i810state.h"
 
 
diff --git a/src/mesa/drivers/dri/i915/i830_context.c b/src/mesa/drivers/dri/i915/i830_context.c
index 840946f..7be18cb 100644
--- a/src/mesa/drivers/dri/i915/i830_context.c
+++ b/src/mesa/drivers/dri/i915/i830_context.c
@@ -28,14 +28,11 @@
 #include "i830_context.h"
 #include "main/imports.h"
 #include "texmem.h"
-#include "intel_tex.h"
 #include "tnl/tnl.h"
 #include "tnl/t_vertex.h"
 #include "tnl/t_context.h"
 #include "tnl/t_pipeline.h"
-#include "utils.h"
 #include "intel_span.h"
-#include "intel_pixel.h"
 #include "intel_tris.h"
 
 /***************************************
diff --git a/src/mesa/drivers/dri/i915/i915_context.c b/src/mesa/drivers/dri/i915/i915_context.c
index 7d4c7cf..4767016 100644
--- a/src/mesa/drivers/dri/i915/i915_context.c
+++ b/src/mesa/drivers/dri/i915/i915_context.c
@@ -28,7 +28,6 @@
 #include "i915_context.h"
 #include "main/imports.h"
 #include "main/macros.h"
-#include "intel_tex.h"
 #include "intel_tris.h"
 #include "tnl/t_context.h"
 #include "tnl/t_pipeline.h"
@@ -38,15 +37,11 @@
 #include "swrast_setup/swrast_setup.h"
 #include "tnl/tnl.h"
 
-#include "utils.h"
 #include "i915_reg.h"
 #include "i915_program.h"
 
-#include "intel_regions.h"
-#include "intel_batchbuffer.h"
 #include "intel_tris.h"
 #include "intel_span.h"
-#include "intel_pixel.h"
 
 /***************************************
  * Mesa's Driver Functions
diff --git a/src/mesa/drivers/dri/i915/i915_debug_fp.c b/src/mesa/drivers/dri/i915/i915_debug_fp.c
index 84347a0..bf500e5 100644
--- a/src/mesa/drivers/dri/i915/i915_debug_fp.c
+++ b/src/mesa/drivers/dri/i915/i915_debug_fp.c
@@ -30,9 +30,6 @@
 #include "i915_reg.h"
 #include "i915_debug.h"
 #include "main/imports.h"
-#include "shader/program.h"
-#include "shader/prog_instruction.h"
-#include "shader/prog_print.h"
 
 #define PRINTF( ... ) _mesa_printf( __VA_ARGS__ )
 
diff --git a/src/mesa/drivers/dri/i915/i915_program.c b/src/mesa/drivers/dri/i915/i915_program.c
index e7908bd..3902c69 100644
--- a/src/mesa/drivers/dri/i915/i915_program.c
+++ b/src/mesa/drivers/dri/i915/i915_program.c
@@ -245,7 +245,7 @@ GLuint i915_emit_texld( struct i915_fragment_program *p,
    }
    else {
       assert(GET_UREG_TYPE(dest) != REG_TYPE_CONST);
-      assert(dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
+      assert(dest == UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
       /* Can't use unsaved temps for coords, as the phase boundary would result
        * in the contents becoming undefined.
        */
diff --git a/src/mesa/drivers/dri/i915/i915_texstate.c b/src/mesa/drivers/dri/i915/i915_texstate.c
index de25848..825f1db 100644
--- a/src/mesa/drivers/dri/i915/i915_texstate.c
+++ b/src/mesa/drivers/dri/i915/i915_texstate.c
@@ -196,10 +196,11 @@ i915_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
 	 state[I915_TEXREG_MS3] |= MS3_TILE_WALK;
    }
 
-   /* We get one field with fraction bits to cover the maximum addressable (smallest
-    * resolution) LOD.  Use it to cover both MAX_LEVEL and MAX_LOD.
+   /* We get one field with fraction bits for the maximum addressable
+    * (lowest resolution) LOD.  Use it to cover both MAX_LEVEL and
+    * MAX_LOD.
     */
-   maxlod = MIN2(tObj->MaxLod, tObj->MaxLevel - tObj->BaseLevel);
+   maxlod = MIN2(tObj->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
    state[I915_TEXREG_MS4] =
       ((((pitch / 4) - 1) << MS4_PITCH_SHIFT) |
        MS4_CUBE_FACE_ENA_MASK |
diff --git a/src/mesa/drivers/dri/i915/i915_vtbl.c b/src/mesa/drivers/dri/i915/i915_vtbl.c
index ff97e5a..668e02e 100644
--- a/src/mesa/drivers/dri/i915/i915_vtbl.c
+++ b/src/mesa/drivers/dri/i915/i915_vtbl.c
@@ -37,7 +37,6 @@
 #include "tnl/t_vertex.h"
 
 #include "intel_batchbuffer.h"
-#include "intel_tex.h"
 #include "intel_regions.h"
 #include "intel_tris.h"
 #include "intel_fbo.h"
diff --git a/src/mesa/drivers/dri/i915/intel_render.c b/src/mesa/drivers/dri/i915/intel_render.c
index 410052b..ec20939 100644
--- a/src/mesa/drivers/dri/i915/intel_render.c
+++ b/src/mesa/drivers/dri/i915/intel_render.c
@@ -117,7 +117,7 @@ intelDmaPrimitive(struct intel_context *intel, GLenum prim)
    intel_set_prim(intel, hw_prim[prim]);
 }
 
-static inline GLuint intel_get_vb_max(struct intel_context *intel)
+static INLINE GLuint intel_get_vb_max(struct intel_context *intel)
 {
    GLuint ret;
 
@@ -129,7 +129,7 @@ static inline GLuint intel_get_vb_max(struct intel_context *intel)
    return ret;
 }
 
-static inline GLuint intel_get_current_max(struct intel_context *intel)
+static INLINE GLuint intel_get_current_max(struct intel_context *intel)
 {
 
    if (intel->intelScreen->no_vbo)
diff --git a/src/mesa/drivers/dri/i915/intel_tris.c b/src/mesa/drivers/dri/i915/intel_tris.c
index bc527aa..65db947 100644
--- a/src/mesa/drivers/dri/i915/intel_tris.c
+++ b/src/mesa/drivers/dri/i915/intel_tris.c
@@ -52,7 +52,6 @@
 #include "intel_buffers.h"
 #include "intel_reg.h"
 #include "intel_span.h"
-#include "intel_tex.h"
 #include "intel_chipset.h"
 #include "i830_context.h"
 #include "i830_reg.h"
diff --git a/src/mesa/drivers/dri/i965/brw_cc.c b/src/mesa/drivers/dri/i965/brw_cc.c
index bac1c3a..9a38631 100644
--- a/src/mesa/drivers/dri/i965/brw_cc.c
+++ b/src/mesa/drivers/dri/i965/brw_cc.c
@@ -34,9 +34,7 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 #include "brw_util.h"
-#include "intel_fbo.h"
 #include "main/macros.h"
-#include "main/enums.h"
 
 static void prepare_cc_vp( struct brw_context *brw )
 {
diff --git a/src/mesa/drivers/dri/i965/brw_clip_line.c b/src/mesa/drivers/dri/i965/brw_clip_line.c
index fa9648f..67861ac 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_line.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_line.c
@@ -39,7 +39,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_clip.h"
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_clip_point.c b/src/mesa/drivers/dri/i965/brw_clip_point.c
index 8458f61..7f47634 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_point.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_point.c
@@ -39,7 +39,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_clip.h"
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_clip_state.c b/src/mesa/drivers/dri/i965/brw_clip_state.c
index 234b374..79ae5c7 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_state.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_state.c
@@ -32,7 +32,6 @@
 #include "brw_context.h"
 #include "brw_state.h"
 #include "brw_defines.h"
-#include "main/macros.h"
 
 struct brw_clip_unit_key {
    unsigned int total_grf;
diff --git a/src/mesa/drivers/dri/i965/brw_clip_tri.c b/src/mesa/drivers/dri/i965/brw_clip_tri.c
index cf79224..8d5ca41 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_tri.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_tri.c
@@ -39,7 +39,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_clip.h"
 
 static void release_tmps( struct brw_clip_compile *c )
diff --git a/src/mesa/drivers/dri/i965/brw_clip_unfilled.c b/src/mesa/drivers/dri/i965/brw_clip_unfilled.c
index ad1bfa4..f36d22f 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_unfilled.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_unfilled.c
@@ -39,7 +39,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_clip.h"
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_clip_util.c b/src/mesa/drivers/dri/i965/brw_clip_util.c
index 5a73abd..b7f8c25 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_util.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_util.c
@@ -40,7 +40,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_clip.h"
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 48685c0..6b5c3be 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -33,24 +33,15 @@
 #include "main/imports.h"
 #include "main/api_noop.h"
 #include "main/macros.h"
-#include "main/vtxfmt.h"
 #include "main/simple_list.h"
 #include "shader/shader_api.h"
 
 #include "brw_context.h"
-#include "brw_defines.h"
 #include "brw_draw.h"
 #include "brw_state.h"
-#include "brw_vs.h"
-#include "intel_tex.h"
-#include "intel_blit.h"
-#include "intel_batchbuffer.h"
-#include "intel_pixel.h"
 #include "intel_span.h"
 #include "tnl/t_pipeline.h"
 
-#include "utils.h"
-
 
 /***************************************
  * Mesa's Driver Functions
diff --git a/src/mesa/drivers/dri/i965/brw_disasm.c b/src/mesa/drivers/dri/i965/brw_disasm.c
index 9fef230..130bd0f 100644
--- a/src/mesa/drivers/dri/i965/brw_disasm.c
+++ b/src/mesa/drivers/dri/i965/brw_disasm.c
@@ -365,6 +365,7 @@ static int format (FILE *f, char *format, ...)
     va_start (args, format);
 
     vsnprintf (buf, sizeof (buf) - 1, format, args);
+    va_end (args);
     string (f, buf);
     return 0;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_draw.c b/src/mesa/drivers/dri/i965/brw_draw.c
index 8bcb608..e17680a 100644
--- a/src/mesa/drivers/dri/i965/brw_draw.c
+++ b/src/mesa/drivers/dri/i965/brw_draw.c
@@ -39,10 +39,8 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_state.h"
-#include "brw_fallback.h"
 
 #include "intel_batchbuffer.h"
-#include "intel_buffer_objects.h"
 
 #define FILE_DEBUG_FLAG DEBUG_BATCH
 
diff --git a/src/mesa/drivers/dri/i965/brw_draw_upload.c b/src/mesa/drivers/dri/i965/brw_draw_upload.c
index 271a88d..16b2529 100644
--- a/src/mesa/drivers/dri/i965/brw_draw_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_draw_upload.c
@@ -29,19 +29,15 @@
 #include "main/glheader.h"
 #include "main/bufferobj.h"
 #include "main/context.h"
-#include "main/state.h"
-#include "main/api_validate.h"
 #include "main/enums.h"
 
 #include "brw_draw.h"
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_state.h"
-#include "brw_fallback.h"
 
 #include "intel_batchbuffer.h"
 #include "intel_buffer_objects.h"
-#include "intel_tex.h"
 
 static GLuint double_types[5] = {
    0,
@@ -249,8 +245,10 @@ static void wrap_buffers( struct brw_context *brw,
     */
    /* DON'T DO THIS AS IF WE HAVE TO RE-ORG MEMORY WE NEED SOMEWHERE WITH
       FAKE TO PUSH THIS STUFF */
-//   if (!brw->intel.ttm)
-//      dri_bo_fake_disable_backing_store(brw->vb.upload.bo, NULL, NULL);
+   /*
+   if (!brw->intel.ttm)
+      dri_bo_fake_disable_backing_store(brw->vb.upload.bo, NULL, NULL);
+    */
 }
 
 static void get_space( struct brw_context *brw,
diff --git a/src/mesa/drivers/dri/i965/brw_eu_emit.c b/src/mesa/drivers/dri/i965/brw_eu_emit.c
index 7ceabba..c8fb0a2 100644
--- a/src/mesa/drivers/dri/i965/brw_eu_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_eu_emit.c
@@ -199,7 +199,7 @@ void brw_set_src1( struct brw_instruction *insn,
        * in the future:
        */
       assert (reg.address_mode == BRW_ADDRESS_DIRECT);
-      //assert (reg.file == BRW_GENERAL_REGISTER_FILE);
+      /* assert (reg.file == BRW_GENERAL_REGISTER_FILE); */
 
       if (insn->header.access_mode == BRW_ALIGN_1) {
 	 insn->bits3.da1.src1_subreg_nr = reg.subnr;
@@ -853,7 +853,7 @@ void brw_land_fwd_jump(struct brw_compile *p,
        jmpi = 2;
 
    assert(jmp_insn->header.opcode == BRW_OPCODE_JMPI);
-   assert(jmp_insn->bits1.da1.src1_reg_file = BRW_IMMEDIATE_VALUE);
+   assert(jmp_insn->bits1.da1.src1_reg_file == BRW_IMMEDIATE_VALUE);
 
    jmp_insn->bits3.ud = jmpi * ((landing - jmp_insn) - 1);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_fallback.c b/src/mesa/drivers/dri/i965/brw_fallback.c
index 562a178..1914feb 100644
--- a/src/mesa/drivers/dri/i965/brw_fallback.c
+++ b/src/mesa/drivers/dri/i965/brw_fallback.c
@@ -36,7 +36,6 @@
 #include "swrast/swrast.h"
 #include "tnl/tnl.h"
 #include "brw_context.h"
-#include "brw_fallback.h"
 #include "intel_chipset.h"
 #include "intel_fbo.h"
 #include "intel_regions.h"
diff --git a/src/mesa/drivers/dri/i965/brw_gs_emit.c b/src/mesa/drivers/dri/i965/brw_gs_emit.c
index 0fc5b02..e9b71ed 100644
--- a/src/mesa/drivers/dri/i965/brw_gs_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_gs_emit.c
@@ -40,7 +40,6 @@
 #include "brw_defines.h"
 #include "brw_context.h"
 #include "brw_eu.h"
-#include "brw_util.h"
 #include "brw_gs.h"
 
 static void brw_gs_alloc_regs( struct brw_gs_compile *c,
diff --git a/src/mesa/drivers/dri/i965/brw_gs_state.c b/src/mesa/drivers/dri/i965/brw_gs_state.c
index ed9d2ff..d291f5b 100644
--- a/src/mesa/drivers/dri/i965/brw_gs_state.c
+++ b/src/mesa/drivers/dri/i965/brw_gs_state.c
@@ -34,7 +34,6 @@
 #include "brw_context.h"
 #include "brw_state.h"
 #include "brw_defines.h"
-#include "main/macros.h"
 
 struct brw_gs_unit_key {
    unsigned int total_grf;
diff --git a/src/mesa/drivers/dri/i965/brw_program.c b/src/mesa/drivers/dri/i965/brw_program.c
index bac6918..e3b6fcc 100644
--- a/src/mesa/drivers/dri/i965/brw_program.c
+++ b/src/mesa/drivers/dri/i965/brw_program.c
@@ -37,7 +37,6 @@
 #include "tnl/tnl.h"
 
 #include "brw_context.h"
-#include "brw_util.h"
 #include "brw_wm.h"
 
 static void brwBindProgram( GLcontext *ctx,
diff --git a/src/mesa/drivers/dri/i965/brw_sf_state.c b/src/mesa/drivers/dri/i965/brw_sf_state.c
index bb69435..b76ed98 100644
--- a/src/mesa/drivers/dri/i965/brw_sf_state.c
+++ b/src/mesa/drivers/dri/i965/brw_sf_state.c
@@ -35,7 +35,6 @@
 #include "brw_state.h"
 #include "brw_defines.h"
 #include "main/macros.h"
-#include "intel_fbo.h"
 
 static void upload_sf_vp(struct brw_context *brw)
 {
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index b129b1f..14d5319 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -35,7 +35,7 @@
 
 #include "brw_context.h"
 
-static inline void
+static INLINE void
 brw_add_validated_bo(struct brw_context *brw, dri_bo *bo)
 {
    assert(brw->state.validated_bo_count < ARRAY_SIZE(brw->state.validated_bos));
diff --git a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
index 3bc9840..22ff341 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
@@ -35,7 +35,6 @@
 
 #include "brw_context.h"
 #include "brw_state.h"
-#include "brw_defines.h"
 
 /* Creates a new VS constant buffer reflecting the current VS program's
  * constants, if needed by the VS program.
diff --git a/src/mesa/drivers/dri/i965/brw_vtbl.c b/src/mesa/drivers/dri/i965/brw_vtbl.c
index 34aaea3..daf1964 100644
--- a/src/mesa/drivers/dri/i965/brw_vtbl.c
+++ b/src/mesa/drivers/dri/i965/brw_vtbl.c
@@ -44,7 +44,6 @@
 #include "brw_state.h"
 #include "brw_draw.h"
 #include "brw_state.h"
-#include "brw_fallback.h"
 #include "brw_vs.h"
 #include "brw_wm.h"
 
diff --git a/src/mesa/drivers/dri/i965/brw_wm.c b/src/mesa/drivers/dri/i965/brw_wm.c
index 6895f64..802236e 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.c
+++ b/src/mesa/drivers/dri/i965/brw_wm.c
@@ -30,7 +30,6 @@
   */
              
 #include "brw_context.h"
-#include "brw_util.h"
 #include "brw_wm.h"
 #include "brw_state.h"
 
diff --git a/src/mesa/drivers/dri/i965/brw_wm_emit.c b/src/mesa/drivers/dri/i965/brw_wm_emit.c
index 5390fd2..c6d10f5 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_emit.c
@@ -692,7 +692,7 @@ void emit_xpd(struct brw_compile *p,
 {
    GLuint i;
 
-   assert(!(mask & WRITEMASK_W) == WRITEMASK_X);
+   assert((mask & WRITEMASK_W) != WRITEMASK_W);
    
    for (i = 0 ; i < 3; i++) {
       if (mask & (1<<i)) {
@@ -1084,7 +1084,7 @@ static void emit_kil_nv( struct brw_wm_compile *c )
 
    brw_push_insn_state(p);
    brw_set_mask_control(p, BRW_MASK_DISABLE);
-   brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); //IMASK
+   brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); /* IMASK */
    brw_AND(p, r0uw, c->emit_mask_reg, r0uw);
    brw_pop_insn_state(p);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm_glsl.c b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
index e8c2cb6..7e5533e 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_glsl.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
@@ -743,7 +743,7 @@ static void emit_kil(struct brw_wm_compile *c)
     struct brw_reg depth = retype(brw_vec1_grf(0, 0), BRW_REGISTER_TYPE_UW);
     brw_push_insn_state(p);
     brw_set_mask_control(p, BRW_MASK_DISABLE);
-    brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); //IMASK
+    brw_NOT(p, c->emit_mask_reg, brw_mask_reg(1)); /* IMASK */
     brw_AND(p, depth, c->emit_mask_reg, depth);
     brw_pop_insn_state(p);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
index 8335e5a..afb36b7 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
@@ -522,7 +522,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       GLubyte color_mask[4];
       GLboolean color_blend;
       uint32_t tiling;
-      uint32_t draw_offset;
+      uint32_t draw_x;
+      uint32_t draw_y;
    } key;
 
    memset(&key, 0, sizeof(key));
@@ -564,7 +565,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       }
       key.pitch = region->pitch;
       key.cpp = region->cpp;
-      key.draw_offset = region->draw_offset; /* cur 3d or cube face offset */
+      key.draw_x = region->draw_x;
+      key.draw_y = region->draw_y;
    } else {
       key.surface_type = BRW_SURFACE_NULL;
       key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
@@ -572,7 +574,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       key.width = 1;
       key.height = 1;
       key.cpp = 4;
-      key.draw_offset = 0;
+      key.draw_x = 0;
+      key.draw_y = 0;
    }
    /* _NEW_COLOR */
    memcpy(key.color_mask, ctx->Color.ColorMask,
@@ -602,25 +605,32 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
       surf.ss0.surface_format = key.surface_format;
       surf.ss0.surface_type = key.surface_type;
       if (key.tiling == I915_TILING_NONE) {
-	 surf.ss1.base_addr = key.draw_offset;
+	 surf.ss1.base_addr = (key.draw_x + key.draw_y * key.pitch) * key.cpp;
       } else {
-	 uint32_t tile_offset = key.draw_offset % 4096;
-
-	 surf.ss1.base_addr = key.draw_offset - tile_offset;
-
-	 assert(BRW_IS_G4X(brw) || tile_offset == 0);
-	 if (BRW_IS_G4X(brw)) {
-	    if (key.tiling == I915_TILING_X) {
-	       /* Note that the low bits of these fields are missing, so
-		* there's the possibility of getting in trouble.
-		*/
-	       surf.ss5.x_offset = (tile_offset % 512) / key.cpp / 4;
-	       surf.ss5.y_offset = tile_offset / 512 / 2;
-	    } else {
-	       surf.ss5.x_offset = (tile_offset % 128) / key.cpp / 4;
-	       surf.ss5.y_offset = tile_offset / 128 / 2;
-	    }
+	 uint32_t tile_base, tile_x, tile_y;
+	 uint32_t pitch = key.pitch * key.cpp;
+
+	 if (key.tiling == I915_TILING_X) {
+	    tile_x = key.draw_x % (512 / key.cpp);
+	    tile_y = key.draw_y % 8;
+	    tile_base = ((key.draw_y / 8) * (8 * pitch));
+	    tile_base += (key.draw_x - tile_x) / (512 / key.cpp) * 4096;
+	 } else {
+	    /* Y */
+	    tile_x = key.draw_x % (128 / key.cpp);
+	    tile_y = key.draw_y % 32;
+	    tile_base = ((key.draw_y / 32) * (32 * pitch));
+	    tile_base += (key.draw_x - tile_x) / (128 / key.cpp) * 4096;
 	 }
+	 assert(BRW_IS_G4X(brw) || (tile_x == 0 && tile_y == 0));
+	 assert(tile_x % 4 == 0);
+	 assert(tile_y % 2 == 0);
+	 /* Note that the low bits of these fields are missing, so
+	  * there's the possibility of getting in trouble.
+	  */
+	 surf.ss1.base_addr = tile_base;
+	 surf.ss5.x_offset = tile_x / 4;
+	 surf.ss5.y_offset = tile_y / 2;
       }
       if (region_bo != NULL)
 	 surf.ss1.base_addr += region_bo->offset; /* reloc */
diff --git a/src/mesa/drivers/dri/intel/intel_blit.c b/src/mesa/drivers/dri/intel/intel_blit.c
index 9f638b0..5b94d05 100644
--- a/src/mesa/drivers/dri/intel/intel_blit.c
+++ b/src/mesa/drivers/dri/intel/intel_blit.c
@@ -38,7 +38,6 @@
 #include "intel_reg.h"
 #include "intel_regions.h"
 #include "intel_batchbuffer.h"
-#include "intel_chipset.h"
 
 #define FILE_DEBUG_FLAG DEBUG_BLIT
 
diff --git a/src/mesa/drivers/dri/intel/intel_buffers.c b/src/mesa/drivers/dri/intel/intel_buffers.c
index 0564318..78ea6eb 100644
--- a/src/mesa/drivers/dri/intel/intel_buffers.c
+++ b/src/mesa/drivers/dri/intel/intel_buffers.c
@@ -28,10 +28,8 @@
 #include "intel_context.h"
 #include "intel_buffers.h"
 #include "intel_fbo.h"
-#include "intel_regions.h"
 #include "intel_batchbuffer.h"
 #include "main/framebuffer.h"
-#include "drirenderbuffer.h"
 
 
 /**
diff --git a/src/mesa/drivers/dri/intel/intel_clear.c b/src/mesa/drivers/dri/intel/intel_clear.c
index f682ee3..583976f 100644
--- a/src/mesa/drivers/dri/intel/intel_clear.c
+++ b/src/mesa/drivers/dri/intel/intel_clear.c
@@ -33,12 +33,9 @@
 
 #include "intel_context.h"
 #include "intel_blit.h"
-#include "intel_chipset.h"
 #include "intel_clear.h"
 #include "intel_fbo.h"
-#include "intel_pixel.h"
 #include "intel_regions.h"
-#include "intel_batchbuffer.h"
 
 #define FILE_DEBUG_FLAG DEBUG_BLIT
 
diff --git a/src/mesa/drivers/dri/intel/intel_context.c b/src/mesa/drivers/dri/intel/intel_context.c
index 26ff11b..6275df3 100644
--- a/src/mesa/drivers/dri/intel/intel_context.c
+++ b/src/mesa/drivers/dri/intel/intel_context.c
@@ -28,7 +28,6 @@
 
 #include "main/glheader.h"
 #include "main/context.h"
-#include "main/arrayobj.h"
 #include "main/extensions.h"
 #include "main/framebuffer.h"
 #include "main/imports.h"
diff --git a/src/mesa/drivers/dri/intel/intel_context.h b/src/mesa/drivers/dri/intel/intel_context.h
index eb7be7d..1afec09 100644
--- a/src/mesa/drivers/dri/intel/intel_context.h
+++ b/src/mesa/drivers/dri/intel/intel_context.h
@@ -354,14 +354,14 @@ extern char *__progname;
 #define ALIGN(value, alignment)  ((value + alignment - 1) & ~(alignment - 1))
 #define IS_POWER_OF_TWO(val) (((val) & (val - 1)) == 0)
 
-static inline uint32_t
+static INLINE uint32_t
 U_FIXED(float value, uint32_t frac_bits)
 {
    value *= (1 << frac_bits);
    return value < 0 ? 0 : value;
 }
 
-static inline uint32_t
+static INLINE uint32_t
 S_FIXED(float value, uint32_t frac_bits)
 {
    return value * (1 << frac_bits);
@@ -588,7 +588,7 @@ is_power_of_two(uint32_t value)
    return (value & (value - 1)) == 0;
 }
 
-static inline void
+static INLINE void
 intel_bo_map_gtt_preferred(struct intel_context *intel,
 			   drm_intel_bo *bo,
 			   GLboolean write)
@@ -599,7 +599,7 @@ intel_bo_map_gtt_preferred(struct intel_context *intel,
       drm_intel_bo_map(bo, write);
 }
 
-static inline void
+static INLINE void
 intel_bo_unmap_gtt_preferred(struct intel_context *intel,
 			     drm_intel_bo *bo)
 {
diff --git a/src/mesa/drivers/dri/intel/intel_pixel.c b/src/mesa/drivers/dri/intel/intel_pixel.c
index 993e427..f4e7d4b 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel.c
@@ -29,14 +29,7 @@
 #include "main/state.h"
 #include "main/bufferobj.h"
 #include "main/context.h"
-#include "main/enable.h"
-#include "main/matrix.h"
-#include "main/texstate.h"
-#include "main/varray.h"
-#include "main/viewport.h"
 #include "swrast/swrast.h"
-#include "shader/arbprogram.h"
-#include "shader/program.h"
 
 #include "intel_context.h"
 #include "intel_pixel.h"
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
index 204a233..6bb497b 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
@@ -32,11 +32,11 @@
 #include "main/mtypes.h"
 #include "main/macros.h"
 #include "main/bufferobj.h"
+#include "main/polygon.h"
 #include "main/pixelstore.h"
 #include "main/polygon.h"
 #include "main/state.h"
 #include "main/teximage.h"
-#include "main/texenv.h"
 #include "main/texobj.h"
 #include "main/texstate.h"
 #include "main/texparam.h"
@@ -45,7 +45,6 @@
 #include "main/enable.h"
 #include "main/viewport.h"
 #include "shader/arbprogram.h"
-#include "glapi/dispatch.h"
 #include "swrast/swrast.h"
 
 #include "intel_screen.h"
@@ -53,7 +52,6 @@
 #include "intel_batchbuffer.h"
 #include "intel_blit.h"
 #include "intel_regions.h"
-#include "intel_buffer_objects.h"
 #include "intel_buffers.h"
 #include "intel_pixel.h"
 #include "intel_reg.h"
@@ -165,7 +163,7 @@ static GLuint get_bitmap_rect(GLsizei width, GLsizei height,
  * Returns the low Y value of the vertical range given, flipped according to
  * whether the framebuffer is or not.
  */
-static inline int
+static INLINE int
 y_flip(struct gl_framebuffer *fb, int y, int height)
 {
    if (fb->Name != 0)
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_draw.c b/src/mesa/drivers/dri/intel/intel_pixel_draw.c
index 9b382e3..3a35634 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_draw.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_draw.c
@@ -46,10 +46,7 @@
 #include "drivers/common/meta.h"
 
 #include "intel_context.h"
-#include "intel_batchbuffer.h"
-#include "intel_blit.h"
 #include "intel_buffers.h"
-#include "intel_regions.h"
 #include "intel_pixel.h"
 #include "intel_fbo.h"
 
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_read.c b/src/mesa/drivers/dri/intel/intel_pixel_read.c
index 20424e2..01a0570 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_read.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_read.c
@@ -36,7 +36,6 @@
 
 #include "intel_screen.h"
 #include "intel_context.h"
-#include "intel_batchbuffer.h"
 #include "intel_blit.h"
 #include "intel_buffers.h"
 #include "intel_regions.h"
diff --git a/src/mesa/drivers/dri/intel/intel_regions.c b/src/mesa/drivers/dri/intel/intel_regions.c
index 8097516..d13516a 100644
--- a/src/mesa/drivers/dri/intel/intel_regions.c
+++ b/src/mesa/drivers/dri/intel/intel_regions.c
@@ -48,7 +48,6 @@
 #include "intel_buffer_objects.h"
 #include "intel_bufmgr.h"
 #include "intel_batchbuffer.h"
-#include "intel_chipset.h"
 
 #define FILE_DEBUG_FLAG DEBUG_REGION
 
diff --git a/src/mesa/drivers/dri/intel/intel_screen.c b/src/mesa/drivers/dri/intel/intel_screen.c
index 789135b..f3de7d1 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.c
+++ b/src/mesa/drivers/dri/intel/intel_screen.c
@@ -38,12 +38,9 @@
 #include "intel_buffers.h"
 #include "intel_bufmgr.h"
 #include "intel_chipset.h"
-#include "intel_extensions.h"
 #include "intel_fbo.h"
-#include "intel_regions.h"
 #include "intel_swapbuffers.h"
 #include "intel_screen.h"
-#include "intel_span.h"
 #include "intel_tex.h"
 
 #include "i915_drm.h"
diff --git a/src/mesa/drivers/dri/intel/intel_state.c b/src/mesa/drivers/dri/intel/intel_state.c
index 4ee7423..f18e625 100644
--- a/src/mesa/drivers/dri/intel/intel_state.c
+++ b/src/mesa/drivers/dri/intel/intel_state.c
@@ -35,8 +35,6 @@
 
 #include "intel_screen.h"
 #include "intel_context.h"
-#include "intel_regions.h"
-#include "swrast/swrast.h"
 
 int
 intel_translate_shadow_compare_func(GLenum func)
diff --git a/src/mesa/drivers/dri/intel/intel_swapbuffers.c b/src/mesa/drivers/dri/intel/intel_swapbuffers.c
index 7d035b9..5af2f5f 100644
--- a/src/mesa/drivers/dri/intel/intel_swapbuffers.c
+++ b/src/mesa/drivers/dri/intel/intel_swapbuffers.c
@@ -29,7 +29,6 @@
 #include "intel_buffers.h"
 #include "intel_swapbuffers.h"
 #include "intel_fbo.h"
-#include "intel_batchbuffer.h"
 #include "drirenderbuffer.h"
 #include "vblank.h"
 #include "i915_drm.h"
diff --git a/src/mesa/drivers/dri/intel/intel_tex_copy.c b/src/mesa/drivers/dri/intel/intel_tex_copy.c
index 767d04d..a80cab3 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_copy.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_copy.c
@@ -36,7 +36,6 @@
 
 #include "intel_screen.h"
 #include "intel_context.h"
-#include "intel_batchbuffer.h"
 #include "intel_buffers.h"
 #include "intel_mipmap_tree.h"
 #include "intel_regions.h"
@@ -109,7 +108,7 @@ do_copy_texsubimage(struct intel_context *intel,
       return GL_FALSE;
    }
 
-   //   intelFlush(ctx);
+   /* intelFlush(ctx); */
    LOCK_HARDWARE(intel);
    {
       drm_intel_bo *dst_bo = intel_region_buffer(intel,
@@ -160,13 +159,14 @@ do_copy_texsubimage(struct intel_context *intel,
 			     intelImage->mt->cpp,
 			     src_pitch,
 			     src->buffer,
-			     src->draw_offset,
+			     0,
 			     src->tiling,
 			     intelImage->mt->pitch,
 			     dst_bo,
 			     0,
 			     intelImage->mt->region->tiling,
-			     x, y, image_x + dstx, image_y + dsty,
+			     src->draw_x + x, src->draw_y + y,
+			     image_x + dstx, image_y + dsty,
 			     width, height,
 			     GL_COPY)) {
 	 UNLOCK_HARDWARE(intel);
diff --git a/src/mesa/drivers/dri/intel/intel_tex_image.c b/src/mesa/drivers/dri/intel/intel_tex_image.c
index 66d61f9..fe4806c 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_image.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_image.c
@@ -7,7 +7,6 @@
 #include "main/convolve.h"
 #include "main/context.h"
 #include "main/formats.h"
-#include "main/image.h"
 #include "main/texcompress.h"
 #include "main/texstore.h"
 #include "main/texgetimage.h"
diff --git a/src/mesa/drivers/dri/intel/intel_tex_validate.c b/src/mesa/drivers/dri/intel/intel_tex_validate.c
index c9a24ac..ed5c5d8 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_validate.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_validate.c
@@ -2,10 +2,8 @@
 #include "main/macros.h"
 
 #include "intel_context.h"
-#include "intel_batchbuffer.h"
 #include "intel_mipmap_tree.h"
 #include "intel_tex.h"
-#include "intel_chipset.h"
 
 #define FILE_DEBUG_FLAG DEBUG_TEXTURE
 
diff --git a/src/mesa/drivers/dri/mach64/mach64_context.c b/src/mesa/drivers/dri/mach64/mach64_context.c
index 2bca293..37cea9d 100644
--- a/src/mesa/drivers/dri/mach64/mach64_context.c
+++ b/src/mesa/drivers/dri/mach64/mach64_context.c
@@ -33,8 +33,6 @@
 #include "main/context.h"
 #include "main/simple_list.h"
 #include "main/imports.h"
-#include "main/matrix.h"
-#include "main/extensions.h"
 
 #include "swrast/swrast.h"
 #include "swrast_setup/swrast_setup.h"
diff --git a/src/mesa/drivers/dri/mach64/mach64_dd.c b/src/mesa/drivers/dri/mach64/mach64_dd.c
index e400e9a..ca713e2 100644
--- a/src/mesa/drivers/dri/mach64/mach64_dd.c
+++ b/src/mesa/drivers/dri/mach64/mach64_dd.c
@@ -31,12 +31,9 @@
 
 #include "mach64_context.h"
 #include "mach64_ioctl.h"
-#include "mach64_state.h"
-#include "mach64_vb.h"
 #include "mach64_dd.h"
 
 #include "main/context.h"
-#include "main/framebuffer.h"
 
 #include "utils.h"
 
diff --git a/src/mesa/drivers/dri/mach64/mach64_lock.c b/src/mesa/drivers/dri/mach64/mach64_lock.c
index d018ba4..f7ef4da 100644
--- a/src/mesa/drivers/dri/mach64/mach64_lock.c
+++ b/src/mesa/drivers/dri/mach64/mach64_lock.c
@@ -32,7 +32,6 @@
 #include "mach64_context.h"
 #include "mach64_state.h"
 #include "mach64_lock.h"
-#include "mach64_tex.h"
 #include "drirenderbuffer.h"
 
 #if DEBUG_LOCKING
diff --git a/src/mesa/drivers/dri/mach64/mach64_screen.c b/src/mesa/drivers/dri/mach64/mach64_screen.c
index 3b19cf5..61e1745 100644
--- a/src/mesa/drivers/dri/mach64/mach64_screen.c
+++ b/src/mesa/drivers/dri/mach64/mach64_screen.c
@@ -31,8 +31,6 @@
 
 #include "mach64_context.h"
 #include "mach64_ioctl.h"
-#include "mach64_tris.h"
-#include "mach64_vb.h"
 #include "mach64_span.h"
 
 #include "main/context.h"
diff --git a/src/mesa/drivers/dri/mach64/mach64_span.c b/src/mesa/drivers/dri/mach64/mach64_span.c
index 500319e..d9d1244 100644
--- a/src/mesa/drivers/dri/mach64/mach64_span.c
+++ b/src/mesa/drivers/dri/mach64/mach64_span.c
@@ -31,7 +31,6 @@
 
 #include "mach64_context.h"
 #include "mach64_ioctl.h"
-#include "mach64_state.h"
 #include "mach64_span.h"
 
 #include "swrast/swrast.h"
diff --git a/src/mesa/drivers/dri/mach64/mach64_state.c b/src/mesa/drivers/dri/mach64/mach64_state.c
index 3a02318..754ed86 100644
--- a/src/mesa/drivers/dri/mach64/mach64_state.c
+++ b/src/mesa/drivers/dri/mach64/mach64_state.c
@@ -36,7 +36,6 @@
 #include "mach64_vb.h"
 #include "mach64_tex.h"
 
-#include "main/context.h"
 #include "main/enums.h"
 #include "main/colormac.h"
 #include "swrast/swrast.h"
@@ -44,8 +43,6 @@
 #include "tnl/tnl.h"
 #include "swrast_setup/swrast_setup.h"
 
-#include "tnl/t_pipeline.h"
-
 
 /* =============================================================
  * Alpha blending
diff --git a/src/mesa/drivers/dri/mach64/mach64_tex.c b/src/mesa/drivers/dri/mach64/mach64_tex.c
index a757362..2e85336 100644
--- a/src/mesa/drivers/dri/mach64/mach64_tex.c
+++ b/src/mesa/drivers/dri/mach64/mach64_tex.c
@@ -31,13 +31,8 @@
 
 #include "mach64_context.h"
 #include "mach64_ioctl.h"
-#include "mach64_state.h"
-#include "mach64_vb.h"
-#include "mach64_tris.h"
 #include "mach64_tex.h"
 
-#include "main/context.h"
-#include "main/macros.h"
 #include "main/simple_list.h"
 #include "main/enums.h"
 #include "main/texstore.h"
diff --git a/src/mesa/drivers/dri/mach64/mach64_texmem.c b/src/mesa/drivers/dri/mach64/mach64_texmem.c
index b97e9ee..46cee43 100644
--- a/src/mesa/drivers/dri/mach64/mach64_texmem.c
+++ b/src/mesa/drivers/dri/mach64/mach64_texmem.c
@@ -37,10 +37,7 @@
 #include "main/imports.h"
 
 #include "mach64_context.h"
-#include "mach64_state.h"
 #include "mach64_ioctl.h"
-#include "mach64_vb.h"
-#include "mach64_tris.h"
 #include "mach64_tex.h"
 
 
diff --git a/src/mesa/drivers/dri/mach64/mach64_texstate.c b/src/mesa/drivers/dri/mach64/mach64_texstate.c
index df0a09a..adf774e 100644
--- a/src/mesa/drivers/dri/mach64/mach64_texstate.c
+++ b/src/mesa/drivers/dri/mach64/mach64_texstate.c
@@ -36,8 +36,6 @@
 
 #include "mach64_context.h"
 #include "mach64_ioctl.h"
-#include "mach64_state.h"
-#include "mach64_vb.h"
 #include "mach64_tris.h"
 #include "mach64_tex.h"
 
diff --git a/src/mesa/drivers/dri/mach64/mach64_vb.c b/src/mesa/drivers/dri/mach64/mach64_vb.c
index e58812e..00da835 100644
--- a/src/mesa/drivers/dri/mach64/mach64_vb.c
+++ b/src/mesa/drivers/dri/mach64/mach64_vb.c
@@ -42,7 +42,6 @@
 #include "mach64_vb.h"
 #include "mach64_ioctl.h"
 #include "mach64_tris.h"
-#include "mach64_state.h"
 
 
 #define MACH64_TEX1_BIT       0x1
diff --git a/src/mesa/drivers/dri/mga/mga_xmesa.c b/src/mesa/drivers/dri/mga/mga_xmesa.c
index 2c7f50c..d0902e5 100644
--- a/src/mesa/drivers/dri/mga/mga_xmesa.c
+++ b/src/mesa/drivers/dri/mga/mga_xmesa.c
@@ -35,7 +35,6 @@
 #include "mga_drm.h"
 #include "mga_xmesa.h"
 #include "main/context.h"
-#include "main/matrix.h"
 #include "main/simple_list.h"
 #include "main/imports.h"
 #include "main/framebuffer.h"
@@ -64,7 +63,6 @@
 #include "utils.h"
 #include "vblank.h"
 
-#include "main/extensions.h"
 #include "drirenderbuffer.h"
 
 #include "GL/internal/dri_interface.h"
diff --git a/src/mesa/drivers/dri/mga/mgadd.c b/src/mesa/drivers/dri/mga/mgadd.c
index 3b1ea22..2f23c0e 100644
--- a/src/mesa/drivers/dri/mga/mgadd.c
+++ b/src/mesa/drivers/dri/mga/mgadd.c
@@ -32,11 +32,6 @@
 
 #include "mgacontext.h"
 #include "mgadd.h"
-#include "mgastate.h"
-#include "mgaspan.h"
-#include "mgatex.h"
-#include "mgatris.h"
-#include "mgavb.h"
 #include "mga_xmesa.h"
 #include "utils.h"
 
diff --git a/src/mesa/drivers/dri/mga/mgaioctl.c b/src/mesa/drivers/dri/mga/mgaioctl.c
index 4438bad..3eaa7ec 100644
--- a/src/mesa/drivers/dri/mga/mgaioctl.c
+++ b/src/mesa/drivers/dri/mga/mgaioctl.c
@@ -42,10 +42,7 @@
 #include "mgacontext.h"
 #include "mgadd.h"
 #include "mgastate.h"
-#include "mgatex.h"
-#include "mgavb.h"
 #include "mgaioctl.h"
-#include "mgatris.h"
 
 #include "vblank.h"
 
diff --git a/src/mesa/drivers/dri/mga/mgarender.c b/src/mesa/drivers/dri/mga/mgarender.c
index 517c3b8..8b8fc48 100644
--- a/src/mesa/drivers/dri/mga/mgarender.c
+++ b/src/mesa/drivers/dri/mga/mgarender.c
@@ -48,7 +48,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "mgacontext.h"
 #include "mgatris.h"
-#include "mgastate.h"
 #include "mgaioctl.h"
 #include "mgavb.h"
 
diff --git a/src/mesa/drivers/dri/mga/mgatex.c b/src/mesa/drivers/dri/mga/mgatex.c
index 9163371..45f2ccb 100644
--- a/src/mesa/drivers/dri/mga/mgatex.c
+++ b/src/mesa/drivers/dri/mga/mgatex.c
@@ -40,11 +40,8 @@
 #include "mgacontext.h"
 #include "mgatex.h"
 #include "mgaregs.h"
-#include "mgatris.h"
 #include "mgaioctl.h"
 
-#include "swrast/swrast.h"
-
 #include "xmlpool.h"
 
 /**
diff --git a/src/mesa/drivers/dri/mga/mgatris.c b/src/mesa/drivers/dri/mga/mgatris.c
index c1bcd4b..4c58c3b 100644
--- a/src/mesa/drivers/dri/mga/mgatris.c
+++ b/src/mesa/drivers/dri/mga/mgatris.c
@@ -38,7 +38,6 @@
 #include "mgaioctl.h"
 #include "mgatris.h"
 #include "mgavb.h"
-#include "mgastate.h"
 
 
 static void mgaRenderPrimitive( GLcontext *ctx, GLenum prim );
diff --git a/src/mesa/drivers/dri/mga/mgavb.c b/src/mesa/drivers/dri/mga/mgavb.c
index 1c635b2..def5109 100644
--- a/src/mesa/drivers/dri/mga/mgavb.c
+++ b/src/mesa/drivers/dri/mga/mgavb.c
@@ -39,7 +39,6 @@
 #include "main/colormac.h"
 
 #include "tnl/t_context.h"
-#include "swrast_setup/swrast_setup.h"
 #include "swrast/swrast.h"
 
 
diff --git a/src/mesa/drivers/dri/r200/r200_state_init.c b/src/mesa/drivers/dri/r200/r200_state_init.c
index 6c5a0b7..80b08dc 100644
--- a/src/mesa/drivers/dri/r200/r200_state_init.c
+++ b/src/mesa/drivers/dri/r200/r200_state_init.c
@@ -698,7 +698,8 @@ static void tex_emit_mm(GLcontext *ctx, struct radeon_state_atom *atom)
    uint32_t dwords = atom->check(ctx, atom);
    int i = atom->idx;
    radeonTexObj *t = r200->state.texture.unit[i].texobj;
-   if (!r200->state.texture.unit[i].unitneeded)
+
+   if (!r200->state.texture.unit[i].unitneeded && !(dwords <= atom->cmd_size))
         dwords -= 4;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
 
diff --git a/src/mesa/drivers/dri/r200/r200_vertprog.c b/src/mesa/drivers/dri/r200/r200_vertprog.c
index 11405d7..4f225a2 100644
--- a/src/mesa/drivers/dri/r200/r200_vertprog.c
+++ b/src/mesa/drivers/dri/r200/r200_vertprog.c
@@ -437,7 +437,7 @@ static GLboolean r200_translate_vertex_program(GLcontext *ctx, struct r200_verte
       (1 << VERT_RESULT_TEX2) | (1 << VERT_RESULT_TEX3) | (1 << VERT_RESULT_TEX4) |
       (1 << VERT_RESULT_TEX5) | (1 << VERT_RESULT_PSIZ))) != 0) {
       if (R200_DEBUG & RADEON_FALLBACKS) {
-	 fprintf(stderr, "can't handle vert prog outputs 0x%x\n",
+	 fprintf(stderr, "can't handle vert prog outputs 0x%llx\n",
 	    mesa_vp->Base.OutputsWritten);
       }
       return GL_FALSE;
diff --git a/src/mesa/drivers/dri/r300/compiler/memory_pool.c b/src/mesa/drivers/dri/r300/compiler/memory_pool.c
index 37aa2b6..76c7c60 100644
--- a/src/mesa/drivers/dri/r300/compiler/memory_pool.c
+++ b/src/mesa/drivers/dri/r300/compiler/memory_pool.c
@@ -71,12 +71,14 @@ static void refill_pool(struct memory_pool * pool)
 void * memory_pool_malloc(struct memory_pool * pool, unsigned int bytes)
 {
 	if (bytes < POOL_LARGE_ALLOC) {
+		void * ptr;
+
 		if (pool->head + bytes > pool->end)
 			refill_pool(pool);
 
 		assert(pool->head + bytes <= pool->end);
 
-		void * ptr = pool->head;
+		ptr = pool->head;
 
 		pool->head += bytes;
 		pool->head = (unsigned char*)(((unsigned long)pool->head + POOL_ALIGN - 1) & ~(POOL_ALIGN - 1));
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_code.c b/src/mesa/drivers/dri/r300/compiler/radeon_code.c
index 1a3d8bb..853b2be 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_code.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_code.c
@@ -143,7 +143,8 @@ unsigned rc_constants_add_immediate_scalar(struct rc_constant_list * c, float da
 
 	for(index = 0; index < c->Count; ++index) {
 		if (c->Constants[index].Type == RC_CONSTANT_IMMEDIATE) {
-			for(unsigned comp = 0; comp < c->Constants[index].Size; ++comp) {
+			unsigned comp;
+			for(comp = 0; comp < c->Constants[index].Size; ++comp) {
 				if (c->Constants[index].u.Immediate[comp] == data) {
 					*swizzle = RC_MAKE_SWIZZLE(comp, comp, comp, comp);
 					return index;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c b/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
index c0e7a7f..41ea23e 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_compiler.c
@@ -232,12 +232,16 @@ void rc_copy_output(struct radeon_compiler * c, unsigned output, unsigned dup_ou
 void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsigned new_input)
 {
 	unsigned tempregi = rc_find_free_temporary(c);
+	struct rc_instruction * inst_rcp;
+	struct rc_instruction * inst_mul;
+	struct rc_instruction * inst_mad;
+	struct rc_instruction * inst;
 
 	c->Program.InputsRead &= ~(1 << wpos);
 	c->Program.InputsRead |= 1 << new_input;
 
 	/* perspective divide */
-	struct rc_instruction * inst_rcp = rc_insert_new_instruction(c, &c->Program.Instructions);
+	inst_rcp = rc_insert_new_instruction(c, &c->Program.Instructions);
 	inst_rcp->U.I.Opcode = RC_OPCODE_RCP;
 
 	inst_rcp->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -248,7 +252,7 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_rcp->U.I.SrcReg[0].Index = new_input;
 	inst_rcp->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_WWWW;
 
-	struct rc_instruction * inst_mul = rc_insert_new_instruction(c, inst_rcp);
+	inst_mul = rc_insert_new_instruction(c, inst_rcp);
 	inst_mul->U.I.Opcode = RC_OPCODE_MUL;
 
 	inst_mul->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -263,7 +267,7 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_mul->U.I.SrcReg[1].Swizzle = RC_SWIZZLE_WWWW;
 
 	/* viewport transformation */
-	struct rc_instruction * inst_mad = rc_insert_new_instruction(c, inst_mul);
+	inst_mad = rc_insert_new_instruction(c, inst_mul);
 	inst_mad->U.I.Opcode = RC_OPCODE_MAD;
 
 	inst_mad->U.I.DstReg.File = RC_FILE_TEMPORARY;
@@ -282,7 +286,6 @@ void rc_transform_fragment_wpos(struct radeon_compiler * c, unsigned wpos, unsig
 	inst_mad->U.I.SrcReg[2].Index = inst_mad->U.I.SrcReg[1].Index;
 	inst_mad->U.I.SrcReg[2].Swizzle = RC_MAKE_SWIZZLE(RC_SWIZZLE_X, RC_SWIZZLE_Y, RC_SWIZZLE_Z, RC_SWIZZLE_ZERO);
 
-	struct rc_instruction * inst;
 	for (inst = inst_mad->Next; inst != &c->Program.Instructions; inst = inst->Next) {
 		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);
 		unsigned i;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_program.c b/src/mesa/drivers/dri/r300/compiler/radeon_program.c
index 0dbc538..a3c41d7 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_program.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_program.c
@@ -94,10 +94,11 @@ unsigned int rc_find_free_temporary(struct radeon_compiler * c)
 {
 	char used[RC_REGISTER_MAX_INDEX];
 	unsigned int i;
+	struct rc_instruction * rcinst;
 
 	memset(used, 0, sizeof(used));
 
-	for (struct rc_instruction * rcinst = c->Program.Instructions.Next; rcinst != &c->Program.Instructions; rcinst = rcinst->Next) {
+	for (rcinst = c->Program.Instructions.Next; rcinst != &c->Program.Instructions; rcinst = rcinst->Next) {
 		const struct rc_sub_instruction *inst = &rcinst->U.I;
 		const struct rc_opcode_info *opcode = rc_get_opcode_info(inst->Opcode);
 		unsigned int k;
@@ -168,8 +169,9 @@ void rc_remove_instruction(struct rc_instruction * inst)
 unsigned int rc_recompute_ips(struct radeon_compiler * c)
 {
 	unsigned int ip = 0;
+	struct rc_instruction * inst;
 
-	for(struct rc_instruction * inst = c->Program.Instructions.Next;
+	for(inst = c->Program.Instructions.Next;
 	    inst != &c->Program.Instructions;
 	    inst = inst->Next) {
 		inst->IP = ip++;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c b/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
index ced66af..b5c08ae 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_program_alu.c
@@ -267,9 +267,9 @@ static void transform_LIT(struct radeon_compiler* c,
 	temp = inst->U.I.DstReg.Index;
 	srctemp = srcreg(RC_FILE_TEMPORARY, temp);
 
-	// tmp.x = max(0.0, Src.x);
-	// tmp.y = max(0.0, Src.y);
-	// tmp.w = clamp(Src.z, -128+eps, 128-eps);
+	/* tmp.x = max(0.0, Src.x); */
+	/* tmp.y = max(0.0, Src.y); */
+	/* tmp.w = clamp(Src.z, -128+eps, 128-eps); */
 	emit2(c, inst->Prev, RC_OPCODE_MAX, 0,
 		dstregtmpmask(temp, RC_MASK_XYW),
 		inst->U.I.SrcReg[0],
@@ -280,7 +280,7 @@ static void transform_LIT(struct radeon_compiler* c,
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W),
 		negate(srcregswz(RC_FILE_CONSTANT, constant, constant_swizzle)));
 
-	// tmp.w = Pow(tmp.y, tmp.w)
+	/* tmp.w = Pow(tmp.y, tmp.w) */
 	emit1(c, inst->Prev, RC_OPCODE_LG2, 0,
 		dstregtmpmask(temp, RC_MASK_W),
 		swizzle(srctemp, RC_SWIZZLE_Y, RC_SWIZZLE_Y, RC_SWIZZLE_Y, RC_SWIZZLE_Y));
@@ -292,14 +292,14 @@ static void transform_LIT(struct radeon_compiler* c,
 		dstregtmpmask(temp, RC_MASK_W),
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W));
 
-	// tmp.z = (tmp.x > 0) ? tmp.w : 0.0
+	/* tmp.z = (tmp.x > 0) ? tmp.w : 0.0 */
 	emit3(c, inst->Prev, RC_OPCODE_CMP, inst->U.I.SaturateMode,
 		dstregtmpmask(temp, RC_MASK_Z),
 		negate(swizzle(srctemp, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X)),
 		swizzle(srctemp, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W, RC_SWIZZLE_W),
 		builtin_zero);
 
-	// tmp.x, tmp.y, tmp.w = 1.0, tmp.x, 1.0
+	/* tmp.x, tmp.y, tmp.w = 1.0, tmp.x, 1.0 */
 	emit1(c, inst->Prev, RC_OPCODE_MOV, inst->U.I.SaturateMode,
 		dstregtmpmask(temp, RC_MASK_XYW),
 		swizzle(srctemp, RC_SWIZZLE_ONE, RC_SWIZZLE_X, RC_SWIZZLE_ONE, RC_SWIZZLE_ONE));
@@ -533,16 +533,16 @@ static void sincos_constants(struct radeon_compiler* c, unsigned int *constants)
 {
 	static const float SinCosConsts[2][4] = {
 		{
-			1.273239545,		// 4/PI
-			-0.405284735,		// -4/(PI*PI)
-			3.141592654,		// PI
-			0.2225			// weight
+			1.273239545,		/* 4/PI */
+			-0.405284735,		/* -4/(PI*PI) */
+			3.141592654,		/* PI */
+			0.2225			/* weight */
 		},
 		{
 			0.75,
 			0.5,
-			0.159154943,		// 1/(2*PI)
-			6.283185307		// 2*PI
+			0.159154943,		/* 1/(2*PI) */
+			6.283185307		/* 2*PI */
 		}
 	};
 	int i;
@@ -602,9 +602,9 @@ int radeonTransformTrigSimple(struct radeon_compiler* c,
 	sincos_constants(c, constants);
 
 	if (inst->U.I.Opcode == RC_OPCODE_COS) {
-		// MAD tmp.x, src, 1/(2*PI), 0.75
-		// FRC tmp.x, tmp.x
-		// MAD tmp.z, tmp.x, 2*PI, -PI
+		/* MAD tmp.x, src, 1/(2*PI), 0.75 */
+		/* FRC tmp.x, tmp.x */
+		/* MAD tmp.z, tmp.x, 2*PI, -PI */
 		emit3(c, inst->Prev, RC_OPCODE_MAD, 0, dstregtmpmask(tempreg, RC_MASK_W),
 			swizzle(inst->U.I.SrcReg[0], RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X, RC_SWIZZLE_X),
 			swizzle(srcreg(RC_FILE_CONSTANT, constants[1]), RC_SWIZZLE_Z, RC_SWIZZLE_Z, RC_SWIZZLE_Z, RC_SWIZZLE_Z),
diff --git a/src/mesa/drivers/dri/r300/r300_cmdbuf.c b/src/mesa/drivers/dri/r300/r300_cmdbuf.c
index ad8db6e..96c96d8 100644
--- a/src/mesa/drivers/dri/r300/r300_cmdbuf.c
+++ b/src/mesa/drivers/dri/r300/r300_cmdbuf.c
@@ -39,19 +39,16 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/macros.h"
 #include "main/context.h"
 #include "main/simple_list.h"
-#include "swrast/swrast.h"
 
 #include "drm.h"
 #include "radeon_drm.h"
 
 #include "r300_context.h"
-#include "r300_ioctl.h"
 #include "r300_reg.h"
 #include "r300_cmdbuf.h"
 #include "r300_emit.h"
 #include "radeon_bocs_wrapper.h"
 #include "radeon_mipmap_tree.h"
-#include "r300_state.h"
 #include "radeon_queryobj.h"
 
 /** # of dwords reserved for additional instructions that may need to be written
diff --git a/src/mesa/drivers/dri/r300/r300_context.c b/src/mesa/drivers/dri/r300/r300_context.c
index 5f07b95..2ad5186 100644
--- a/src/mesa/drivers/dri/r300/r300_context.c
+++ b/src/mesa/drivers/dri/r300/r300_context.c
@@ -40,9 +40,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/context.h"
 #include "main/simple_list.h"
 #include "main/imports.h"
-#include "main/matrix.h"
 #include "main/extensions.h"
-#include "main/state.h"
 #include "main/bufferobj.h"
 #include "main/texobj.h"
 
@@ -52,12 +50,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "tnl/tnl.h"
 #include "tnl/t_pipeline.h"
-#include "tnl/t_vp_build.h"
 
 #include "drivers/common/driverfuncs.h"
 
 #include "r300_context.h"
-#include "radeon_context.h"
 #include "radeon_span.h"
 #include "r300_cmdbuf.h"
 #include "r300_state.h"
@@ -69,7 +65,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "radeon_buffer_objects.h"
 #include "radeon_queryobj.h"
 
-#include "vblank.h"
 #include "utils.h"
 #include "xmlpool.h"		/* for symbolic values of enum-type options */
 
diff --git a/src/mesa/drivers/dri/r300/r300_draw.c b/src/mesa/drivers/dri/r300/r300_draw.c
index e9968f9..1d1d41f 100644
--- a/src/mesa/drivers/dri/r300/r300_draw.c
+++ b/src/mesa/drivers/dri/r300/r300_draw.c
@@ -29,7 +29,6 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/state.h"
-#include "main/api_validate.h"
 #include "main/enums.h"
 #include "main/simple_list.h"
 
@@ -47,8 +46,6 @@
 #include "tnl/tnl.h"
 #include "tnl/t_vp_build.h"
 #include "vbo/vbo_context.h"
-#include "swrast/swrast.h"
-#include "swrast_setup/swrast_setup.h"
 
 
 static int getTypeSize(GLenum type)
diff --git a/src/mesa/drivers/dri/r300/r300_emit.c b/src/mesa/drivers/dri/r300/r300_emit.c
index 07e6223..7128751 100644
--- a/src/mesa/drivers/dri/r300/r300_emit.c
+++ b/src/mesa/drivers/dri/r300/r300_emit.c
@@ -39,19 +39,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/colormac.h"
 #include "main/imports.h"
 #include "main/macros.h"
-#include "main/image.h"
 
 #include "swrast_setup/swrast_setup.h"
-#include "math/m_translate.h"
 #include "tnl/tnl.h"
 #include "tnl/t_context.h"
 
 #include "r300_context.h"
-#include "r300_state.h"
 #include "r300_emit.h"
-#include "r300_ioctl.h"
-#include "r300_render.h"
-#include "r300_swtcl.h"
 
 GLuint r300VAPInputCntl0(GLcontext * ctx, GLuint InputsRead)
 {
diff --git a/src/mesa/drivers/dri/r300/r300_fragprog_common.c b/src/mesa/drivers/dri/r300/r300_fragprog_common.c
index 267ee81..d94ed08 100644
--- a/src/mesa/drivers/dri/r300/r300_fragprog_common.c
+++ b/src/mesa/drivers/dri/r300/r300_fragprog_common.c
@@ -38,14 +38,12 @@
 
 #include "r300_fragprog_common.h"
 
-#include "shader/program.h"
 #include "shader/prog_parameter.h"
 #include "shader/prog_print.h"
 
 #include "compiler/radeon_compiler.h"
 
 #include "radeon_mesa_to_rc.h"
-#include "r300_state.h"
 
 
 static GLuint build_dtm(GLuint depthmode)
diff --git a/src/mesa/drivers/dri/r300/r300_ioctl.c b/src/mesa/drivers/dri/r300/r300_ioctl.c
index 5cb04e2..bb34efe 100644
--- a/src/mesa/drivers/dri/r300/r300_ioctl.c
+++ b/src/mesa/drivers/dri/r300/r300_ioctl.c
@@ -58,8 +58,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "r300_emit.h"
 #include "r300_context.h"
 
-#include "vblank.h"
-
 #define R200_3D_DRAW_IMMD_2      0xC0003500
 
 #define CLEARBUFFER_COLOR	0x1
diff --git a/src/mesa/drivers/dri/r300/r300_render.c b/src/mesa/drivers/dri/r300/r300_render.c
index 4ae593c..e3e6285 100644
--- a/src/mesa/drivers/dri/r300/r300_render.c
+++ b/src/mesa/drivers/dri/r300/r300_render.c
@@ -53,7 +53,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "r300_render.h"
 
 #include "main/glheader.h"
-#include "main/state.h"
 #include "main/imports.h"
 #include "main/enums.h"
 #include "main/macros.h"
@@ -65,15 +64,10 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "swrast_setup/swrast_setup.h"
 #include "vbo/vbo.h"
 #include "vbo/vbo_split.h"
-#include "tnl/tnl.h"
-#include "tnl/t_vp_build.h"
 #include "r300_context.h"
-#include "r300_ioctl.h"
 #include "r300_state.h"
 #include "r300_reg.h"
-#include "r300_tex.h"
 #include "r300_emit.h"
-#include "r300_fragprog_common.h"
 #include "r300_swtcl.h"
 
 /**
diff --git a/src/mesa/drivers/dri/r300/r300_state.c b/src/mesa/drivers/dri/r300/r300_state.c
index ac20c08..66b57e5 100644
--- a/src/mesa/drivers/dri/r300/r300_state.c
+++ b/src/mesa/drivers/dri/r300/r300_state.c
@@ -55,17 +55,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "tnl/t_vp_build.h"
 
 #include "r300_context.h"
-#include "r300_ioctl.h"
 #include "r300_state.h"
 #include "r300_reg.h"
 #include "r300_emit.h"
-#include "r300_tex.h"
 #include "r300_fragprog_common.h"
 #include "r300_render.h"
 #include "r300_vertprog.h"
 
-#include "drirenderbuffer.h"
-
 static void r300BlendColor(GLcontext * ctx, const GLfloat cf[4])
 {
 	r300ContextPtr rmesa = R300_CONTEXT(ctx);
diff --git a/src/mesa/drivers/dri/r300/r300_tex.c b/src/mesa/drivers/dri/r300/r300_tex.c
index 726b3ff..de6e6e1 100644
--- a/src/mesa/drivers/dri/r300/r300_tex.c
+++ b/src/mesa/drivers/dri/r300/r300_tex.c
@@ -41,19 +41,14 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/mipmap.h"
 #include "main/simple_list.h"
 #include "main/texstore.h"
-#include "main/teximage.h"
 #include "main/texobj.h"
 
 #include "texmem.h"
 
 #include "r300_context.h"
-#include "r300_state.h"
-#include "r300_ioctl.h"
 #include "radeon_mipmap_tree.h"
 #include "r300_tex.h"
 
-#include "xmlpool.h"
-
 
 static unsigned int translate_wrap_mode(GLenum wrapmode)
 {
diff --git a/src/mesa/drivers/dri/r300/r300_texstate.c b/src/mesa/drivers/dri/r300/r300_texstate.c
index bbe8b1e..1dc5f82 100644
--- a/src/mesa/drivers/dri/r300/r300_texstate.c
+++ b/src/mesa/drivers/dri/r300/r300_texstate.c
@@ -45,8 +45,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/simple_list.h"
 
 #include "r300_context.h"
-#include "r300_state.h"
-#include "r300_ioctl.h"
 #include "radeon_mipmap_tree.h"
 #include "r300_tex.h"
 #include "r300_reg.h"
diff --git a/src/mesa/drivers/dri/r300/r300_vertprog.c b/src/mesa/drivers/dri/r300/r300_vertprog.c
index c2f96af..bede6e0 100644
--- a/src/mesa/drivers/dri/r300/r300_vertprog.c
+++ b/src/mesa/drivers/dri/r300/r300_vertprog.c
@@ -34,7 +34,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "shader/program.h"
 #include "shader/programopt.h"
 #include "shader/prog_instruction.h"
-#include "shader/prog_optimize.h"
 #include "shader/prog_parameter.h"
 #include "shader/prog_print.h"
 #include "shader/prog_statevars.h"
diff --git a/src/mesa/drivers/dri/r600/r600_context.h b/src/mesa/drivers/dri/r600/r600_context.h
index 394fd75..94662ab 100644
--- a/src/mesa/drivers/dri/r600/r600_context.h
+++ b/src/mesa/drivers/dri/r600/r600_context.h
@@ -108,6 +108,7 @@ typedef struct StreamDesc
 	GLint   size;   //number of data element
 	GLenum  type;  //data element type
 	GLsizei stride;
+	GLenum  format; // GL_RGBA,GLBGRA 
 
 	struct radeon_bo *bo;
 	GLint  bo_offset;
diff --git a/src/mesa/drivers/dri/r600/r600_texstate.c b/src/mesa/drivers/dri/r600/r600_texstate.c
index 4ec315b..8fdca0b 100644
--- a/src/mesa/drivers/dri/r600/r600_texstate.c
+++ b/src/mesa/drivers/dri/r600/r600_texstate.c
@@ -85,16 +85,22 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 	CLEARfield(t->SQ_TEX_RESOURCE4, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
 	CLEARfield(t->SQ_TEX_RESOURCE4, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 	CLEARfield(t->SQ_TEX_RESOURCE4, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
+	CLEARbit(t->SQ_TEX_RESOURCE4, SQ_TEX_RESOURCE_WORD4_0__FORCE_DEGAMMA_bit);
 
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
 		 FORMAT_COMP_X_shift, FORMAT_COMP_X_mask);
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
 		 FORMAT_COMP_Y_shift, FORMAT_COMP_Y_mask);
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
-		 FORMAT_COMP_X_shift, FORMAT_COMP_Z_mask);
+		 FORMAT_COMP_Z_shift, FORMAT_COMP_Z_mask);
 	SETfield(t->SQ_TEX_RESOURCE4, SQ_FORMAT_COMP_UNSIGNED,
 		 FORMAT_COMP_W_shift, FORMAT_COMP_W_mask);
 
+	CLEARbit(t->SQ_TEX_RESOURCE0, TILE_TYPE_bit);
+	SETfield(t->SQ_TEX_RESOURCE0, ARRAY_LINEAR_GENERAL,
+		 SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_shift,
+		 SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_mask);
+
 	switch (mesa_format) /* This is mesa format. */
 	{
 	case MESA_FORMAT_RGBA8888:
@@ -158,6 +164,32 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
+	case MESA_FORMAT_XRGB8888:
+		SETfield(t->SQ_TEX_RESOURCE1, FMT_8_8_8_8,
+			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
+
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
+		break;
+	case MESA_FORMAT_XRGB8888_REV:
+		SETfield(t->SQ_TEX_RESOURCE1, FMT_8_8_8_8,
+			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
+
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
+		break;
 	case MESA_FORMAT_ARGB8888_REV:
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_8_8_8_8,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
@@ -357,37 +389,37 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_RGBA_FLOAT16:
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_W,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_RGB_FLOAT32: /* X, Y, Z, ONE */
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
@@ -396,11 +428,11 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Z,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_1,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
@@ -461,26 +493,26 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_32_32_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
 		SETfield(t->SQ_TEX_RESOURCE1, FMT_16_16_FLOAT,
 			 SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift, SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_mask);
 
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_mask);
-		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
-			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
 		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_X,
+			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_mask);
+		SETfield(t->SQ_TEX_RESOURCE4, SQ_SEL_Y,
 			 SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift, SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_mask);
 		break;
 	case MESA_FORMAT_INTENSITY_FLOAT32: /* X, X, X, X */
@@ -515,6 +547,10 @@ static GLboolean r600GetTexFormat(struct gl_texture_object *tObj, gl_format mesa
 	case MESA_FORMAT_Z24_S8:
 	case MESA_FORMAT_Z32:
 	case MESA_FORMAT_S8:
+		SETbit(t->SQ_TEX_RESOURCE0, TILE_TYPE_bit);
+		SETfield(t->SQ_TEX_RESOURCE0, ARRAY_1D_TILED_THIN1,
+			 SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_shift,
+			 SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_mask);
 		switch (mesa_format) {
 		case MESA_FORMAT_Z16:
 			SETfield(t->SQ_TEX_RESOURCE1, FMT_16,
@@ -706,8 +742,10 @@ static void setup_hardware_state(context_t *rmesa, struct gl_texture_object *tex
 	SETfield(t->SQ_TEX_RESOURCE1, firstImage->Height - 1,
 		 TEX_HEIGHT_shift, TEX_HEIGHT_mask);
 
+	t->SQ_TEX_RESOURCE2 = get_base_teximage_offset(t) / 256;
+
 	if ((t->maxLod - t->minLod) > 0) {
-		t->SQ_TEX_RESOURCE3 = t->mt->levels[t->minLod].size / 256;
+		t->SQ_TEX_RESOURCE3 = radeon_miptree_image_offset(t->mt, 0, t->minLod + 1) / 256;
 		SETfield(t->SQ_TEX_RESOURCE4, 0, BASE_LEVEL_shift, BASE_LEVEL_mask);
 		SETfield(t->SQ_TEX_RESOURCE5, t->maxLod - t->minLod, LAST_LEVEL_shift, LAST_LEVEL_mask);
 	}
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.c b/src/mesa/drivers/dri/r600/r700_assembler.c
index 67e0ee7..b0b3892 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.c
+++ b/src/mesa/drivers/dri/r600/r700_assembler.c
@@ -798,6 +798,7 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
                                        GLubyte             element,
                                        GLuint              _signed,
                                        GLboolean           normalize,
+                                       GLenum              format,
                                        VTX_FETCH_METHOD  * pFetchMethod)
 {
     GLuint client_size_inbyte;
@@ -846,10 +847,21 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
 	vfetch_instruction_ptr->m_Word0.f.src_sel_x        = SQ_SEL_X;
 	vfetch_instruction_ptr->m_Word0.f.mega_fetch_count = mega_fetch_count;
 
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_X;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_Z;
-	vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+	if(format == GL_BGRA)
+	{
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_Z;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_X;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+	}
+	else
+	{
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_x        = (size < 1) ? SQ_SEL_0 : SQ_SEL_X;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_y        = (size < 2) ? SQ_SEL_0 : SQ_SEL_Y;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_z        = (size < 3) ? SQ_SEL_0 : SQ_SEL_Z;
+		vfetch_instruction_ptr->m_Word1.f.dst_sel_w        = (size < 4) ? SQ_SEL_1 : SQ_SEL_W;
+
+	}
 
 	vfetch_instruction_ptr->m_Word1.f.use_const_fields = 1;
     vfetch_instruction_ptr->m_Word1.f.data_format      = data_format;
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.h b/src/mesa/drivers/dri/r600/r700_assembler.h
index c66db50..ee12582 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.h
+++ b/src/mesa/drivers/dri/r600/r700_assembler.h
@@ -422,6 +422,7 @@ GLboolean assemble_vfetch_instruction2(r700_AssemblerBase* pAsm,
                                        GLubyte             element,
                                        GLuint              _signed,
                                        GLboolean           normalize,
+                                       GLenum              format,
                                        VTX_FETCH_METHOD  * pFetchMethod);
 GLboolean cleanup_vfetch_instructions(r700_AssemblerBase* pAsm);
 GLuint gethelpr(r700_AssemblerBase* pAsm);
diff --git a/src/mesa/drivers/dri/r600/r700_chip.c b/src/mesa/drivers/dri/r600/r700_chip.c
index 02c56b9..7f1894d 100644
--- a/src/mesa/drivers/dri/r600/r700_chip.c
+++ b/src/mesa/drivers/dri/r600/r700_chip.c
@@ -54,14 +54,11 @@ static void r700SendTexState(GLcontext *ctx, struct radeon_state_atom *atom)
 	for (i = 0; i < R700_TEXTURE_NUMBERUNITS; i++) {
 		if (ctx->Texture.Unit[i]._ReallyEnabled) {
 			radeonTexObj *t = r700->textures[i];
-			uint32_t offset;
 			if (t) {
 				if (!t->image_override) {
 					bo = t->mt->bo;
-					offset = get_base_teximage_offset(t);
 				} else {
 					bo = t->bo;
-					offset = 0;
 				}
 				if (bo) {
 
@@ -81,7 +78,7 @@ static void r700SendTexState(GLcontext *ctx, struct radeon_state_atom *atom)
 					R600_OUT_BATCH(r700->textures[i]->SQ_TEX_RESOURCE6);
 					R600_OUT_BATCH_RELOC(r700->textures[i]->SQ_TEX_RESOURCE2,
 							     bo,
-							     offset,
+							     r700->textures[i]->SQ_TEX_RESOURCE2,
 							     RADEON_GEM_DOMAIN_GTT|RADEON_GEM_DOMAIN_VRAM, 0, 0);
 					R600_OUT_BATCH_RELOC(r700->textures[i]->SQ_TEX_RESOURCE3,
 							     bo,
diff --git a/src/mesa/drivers/dri/r600/r700_state.c b/src/mesa/drivers/dri/r600/r700_state.c
index 16b05d5..82bd48b 100644
--- a/src/mesa/drivers/dri/r600/r700_state.c
+++ b/src/mesa/drivers/dri/r600/r700_state.c
@@ -1576,9 +1576,9 @@ static void r700InitSQConfig(GLcontext * ctx)
     SETbit(r700->sq_config.SQ_CONFIG.u32All, DX9_CONSTS_bit);
     SETbit(r700->sq_config.SQ_CONFIG.u32All, ALU_INST_PREFER_VECTOR_bit);
     SETfield(r700->sq_config.SQ_CONFIG.u32All, ps_prio, PS_PRIO_shift, PS_PRIO_mask);
-    SETfield(r700->sq_config.SQ_CONFIG.u32All, ps_prio, VS_PRIO_shift, VS_PRIO_mask);
-    SETfield(r700->sq_config.SQ_CONFIG.u32All, ps_prio, GS_PRIO_shift, GS_PRIO_mask);
-    SETfield(r700->sq_config.SQ_CONFIG.u32All, ps_prio, ES_PRIO_shift, ES_PRIO_mask);
+    SETfield(r700->sq_config.SQ_CONFIG.u32All, vs_prio, VS_PRIO_shift, VS_PRIO_mask);
+    SETfield(r700->sq_config.SQ_CONFIG.u32All, gs_prio, GS_PRIO_shift, GS_PRIO_mask);
+    SETfield(r700->sq_config.SQ_CONFIG.u32All, es_prio, ES_PRIO_shift, ES_PRIO_mask);
 
     r700->sq_config.SQ_GPR_RESOURCE_MGMT_1.u32All = 0;
     SETfield(r700->sq_config.SQ_GPR_RESOURCE_MGMT_1.u32All, num_ps_gprs, NUM_PS_GPRS_shift, NUM_PS_GPRS_mask);
diff --git a/src/mesa/drivers/dri/r600/r700_vertprog.c b/src/mesa/drivers/dri/r600/r700_vertprog.c
index ffc6068..4ca5ce6 100644
--- a/src/mesa/drivers/dri/r600/r700_vertprog.c
+++ b/src/mesa/drivers/dri/r600/r700_vertprog.c
@@ -179,7 +179,8 @@ GLboolean Process_Vertex_Program_Vfetch_Instructions2(
                                       context->stream_desc[i].size,
                                       context->stream_desc[i].element,
                                       context->stream_desc[i]._signed,
-                                      context->stream_desc[i].normalize,						            
+                                      context->stream_desc[i].normalize,
+                                      context->stream_desc[i].format,
                                      &vtxFetchMethod);
     }
 
@@ -308,6 +309,7 @@ struct r700_vertex_program* r700TranslateVertexShader(GLcontext *ctx,
 		vp->aos_desc[i].size   = context->stream_desc[i].size;
 		vp->aos_desc[i].stride = context->stream_desc[i].stride;
 		vp->aos_desc[i].type   = context->stream_desc[i].type;
+		vp->aos_desc[i].format = context->stream_desc[i].format;
 	}
 
 	if (context->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV770)
@@ -368,7 +370,8 @@ void r700SelectVertexShader(GLcontext *ctx)
 	match = GL_TRUE;
 	for(i=0; i<context->nNumActiveAos; i++)
 	{
-		if (vp->aos_desc[i].size != context->stream_desc[i].size)
+		if (vp->aos_desc[i].size != context->stream_desc[i].size ||
+		    vp->aos_desc[i].format != context->stream_desc[i].format)
 		{
 			match = GL_FALSE;
 			break;
@@ -471,6 +474,7 @@ static void r700TranslateAttrib(GLcontext *ctx, GLuint unLoc, int count, const s
 	pStreamDesc->size = input->Size;
 	pStreamDesc->dst_loc = context->nNumActiveAos;
 	pStreamDesc->element = unLoc;
+	pStreamDesc->format = input->Format;
 
 	switch (pStreamDesc->type) 
 	{ //GetSurfaceFormat
diff --git a/src/mesa/drivers/dri/r600/r700_vertprog.h b/src/mesa/drivers/dri/r600/r700_vertprog.h
index 00824c2..645c9ac 100644
--- a/src/mesa/drivers/dri/r600/r700_vertprog.h
+++ b/src/mesa/drivers/dri/r600/r700_vertprog.h
@@ -39,6 +39,7 @@ typedef struct ArrayDesc //TEMP
 	GLint size;   //number of data element
 	GLenum type;  //data element type
 	GLsizei stride;
+	GLenum format; //GL_RGBA or GL_BGRA
 } ArrayDesc;
 
 struct r700_vertex_program 
diff --git a/src/mesa/drivers/dri/radeon/radeon_common.c b/src/mesa/drivers/dri/radeon/radeon_common.c
index 9b64c21..47bc252 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common.c
+++ b/src/mesa/drivers/dri/radeon/radeon_common.c
@@ -1015,10 +1015,11 @@ static INLINE void radeon_emit_atom(radeonContextPtr radeon, struct radeon_state
 			OUT_BATCH_TABLE(atom->cmd, dwords);
 			END_BATCH();
 		}
+		atom->dirty = GL_FALSE;
+
 	} else {
 		radeon_print(RADEON_STATE, RADEON_VERBOSE, "  skip state %s\n", atom->name);
 	}
-	atom->dirty = GL_FALSE;
 
 }
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c b/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
index 45b608a..cc951a1 100644
--- a/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
+++ b/src/mesa/drivers/dri/radeon/radeon_cs_legacy.c
@@ -180,9 +180,8 @@ static int cs_begin(struct radeon_cs_int *cs,
 
     if (cs->cdw + ndw > cs->ndw) {
         uint32_t tmp, *ptr;
-	int num = (ndw > 0x3FF) ? ndw : 0x3FF;
 
-        tmp = (cs->cdw + 1 + num) & (~num);
+        tmp = (cs->cdw + ndw + 0x3ff) & (~0x3ff);
         ptr = (uint32_t*)realloc(cs->packets, 4 * tmp);
         if (ptr == NULL) {
             return -ENOMEM;
diff --git a/src/mesa/drivers/dri/radeon/radeon_lighting.c b/src/mesa/drivers/dri/radeon/radeon_lighting.c
deleted file mode 100644
index ba444f2..0000000
--- a/src/mesa/drivers/dri/radeon/radeon_lighting.c
+++ /dev/null
@@ -1,681 +0,0 @@
-/*
- * Copyright 2000, 2001 VA Linux Systems Inc., Fremont, California.
- *
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * on the rights to use, copy, modify, merge, publish, distribute, sub
- * license, and/or sell copies of the Software, and to permit persons to whom
- * the Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
- * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors:
- *    Gareth Hughes <gareth@valinux.com>
- *    Keith Whitwell <keith@tungstengraphics.com>
- */
-
-#include "main/glheader.h"
-#include "main/imports.h"
-#include "api_arrayelt.h"
-/* #include "mmath.h" */
-#include "main/enums.h"
-#include "colormac.h"
-
-
-#include "radeon_context.h"
-#include "radeon_ioctl.h"
-#include "radeon_state.h"
-#include "radeon_tcl.h"
-#include "radeon_tex.h"
-#include "radeon_vtxfmt.h"
-
-
-
-/* =============================================================
- * Materials
- */
-
-
-/* Update on colormaterial, material emmissive/ambient, 
- * lightmodel.globalambient
- */
-void update_global_ambient( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   float *fcmd = (float *)RADEON_DB_STATE( glt );
-
-   /* Need to do more if both emmissive & ambient are PREMULT:
-    */
-   if ((rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &
-       ((3 << RADEON_EMISSIVE_SOURCE_SHIFT) |
-	(3 << RADEON_AMBIENT_SOURCE_SHIFT))) == 0) 
-   {
-      COPY_3V( &fcmd[GLT_RED], 
-	       ctx->Light.Material[0].Emission);
-      ACC_SCALE_3V( &fcmd[GLT_RED],
-		   ctx->Light.Model.Ambient,
-		   ctx->Light.Material[0].Ambient);
-   } 
-   else
-   {
-      COPY_3V( &fcmd[GLT_RED], ctx->Light.Model.Ambient );
-   }
-   
-   RADEON_DB_STATECHANGE(rmesa, &rmesa->hw.glt);
-}
-
-/* Update on change to 
- *    - light[p].colors
- *    - light[p].enabled
- *    - material,
- *    - colormaterial enabled
- *    - colormaterial bitmask
- */
-void update_light_colors( GLcontext *ctx, GLuint p )
-{
-   struct gl_light *l = &ctx->Light.Light[p];
-
-/*     fprintf(stderr, "%s\n", __FUNCTION__); */
-
-   if (l->Enabled) {
-      radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-      float *fcmd = (float *)RADEON_DB_STATE( lit[p] );
-      GLuint bitmask = ctx->Light.ColorMaterialBitmask;
-      struct gl_material *mat = &ctx->Light.Material[0];
-
-      COPY_4V( &fcmd[LIT_AMBIENT_RED], l->Ambient );	 
-      COPY_4V( &fcmd[LIT_DIFFUSE_RED], l->Diffuse );
-      COPY_4V( &fcmd[LIT_SPECULAR_RED], l->Specular );
-      
-      if (!ctx->Light.ColorMaterialEnabled)
-	 bitmask = 0;
-
-      if ((bitmask & FRONT_AMBIENT_BIT) == 0) 
-	 SELF_SCALE_3V( &fcmd[LIT_AMBIENT_RED], mat->Ambient );
-
-      if ((bitmask & FRONT_DIFFUSE_BIT) == 0) 
-	 SELF_SCALE_3V( &fcmd[LIT_DIFFUSE_RED], mat->Diffuse );
-      
-      if ((bitmask & FRONT_SPECULAR_BIT) == 0) 
-	 SELF_SCALE_3V( &fcmd[LIT_SPECULAR_RED], mat->Specular );
-
-      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.lit[p] );
-   }
-}
-
-/* Also fallback for asym colormaterial mode in twoside lighting...
- */
-void check_twoside_fallback( GLcontext *ctx )
-{
-   GLboolean fallback = GL_FALSE;
-
-   if (ctx->Light.Enabled && ctx->Light.Model.TwoSide) {
-      if (memcmp( &ctx->Light.Material[0],
-		  &ctx->Light.Material[1],
-		  sizeof(struct gl_material)) != 0)
-	 fallback = GL_TRUE;  
-      else if (ctx->Light.ColorMaterialEnabled &&
-	       (ctx->Light.ColorMaterialBitmask & BACK_MATERIAL_BITS) != 
-	       ((ctx->Light.ColorMaterialBitmask & FRONT_MATERIAL_BITS)<<1))
-	 fallback = GL_TRUE;
-   }
-
-   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_LIGHT_TWOSIDE, fallback );
-}
-
-void radeonColorMaterial( GLcontext *ctx, GLenum face, GLenum mode )
-{
-   if (ctx->Light.ColorMaterialEnabled) {
-      radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-      GLuint light_model_ctl = rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL];
-      GLuint mask = ctx->Light.ColorMaterialBitmask;
-
-      /* Default to PREMULT:
-       */
-      light_model_ctl &= ~((3 << RADEON_EMISSIVE_SOURCE_SHIFT) |
-			   (3 << RADEON_AMBIENT_SOURCE_SHIFT) |
-			   (3 << RADEON_DIFFUSE_SOURCE_SHIFT) |
-			   (3 << RADEON_SPECULAR_SOURCE_SHIFT)); 
-   
-      if (mask & FRONT_EMISSION_BIT) {
-	 light_model_ctl |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
-			     RADEON_EMISSIVE_SOURCE_SHIFT);
-      }
-
-      if (mask & FRONT_AMBIENT_BIT) {
-	 light_model_ctl |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
-			     RADEON_AMBIENT_SOURCE_SHIFT);
-      }
-	 
-      if (mask & FRONT_DIFFUSE_BIT) {
-	 light_model_ctl |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
-			     RADEON_DIFFUSE_SOURCE_SHIFT);
-      }
-   
-      if (mask & FRONT_SPECULAR_BIT) {
-	 light_model_ctl |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
-			     RADEON_SPECULAR_SOURCE_SHIFT);
-      }
-   
-      if (light_model_ctl != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]) {
-	 GLuint p;
-
-	 RADEON_STATECHANGE( rmesa, tcl );
-	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = light_model_ctl;      
-
-	 for (p = 0 ; p < MAX_LIGHTS; p++) 
-	    update_light_colors( ctx, p );
-	 update_global_ambient( ctx );
-      }
-   }
-   
-   check_twoside_fallback( ctx );
-}
-
-void radeonUpdateMaterial( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( mtl );
-   GLuint p;
-   GLuint mask = ~0;
-   
-   if (ctx->Light.ColorMaterialEnabled)
-      mask &= ~ctx->Light.ColorMaterialBitmask;
-
-   if (RADEON_DEBUG & RADEON_STATE)
-      fprintf(stderr, "%s\n", __FUNCTION__);
-
-      
-   if (mask & FRONT_EMISSION_BIT) {
-      fcmd[MTL_EMMISSIVE_RED]   = ctx->Light.Material[0].Emission[0];
-      fcmd[MTL_EMMISSIVE_GREEN] = ctx->Light.Material[0].Emission[1];
-      fcmd[MTL_EMMISSIVE_BLUE]  = ctx->Light.Material[0].Emission[2];
-      fcmd[MTL_EMMISSIVE_ALPHA] = ctx->Light.Material[0].Emission[3];
-   }
-   if (mask & FRONT_AMBIENT_BIT) {
-      fcmd[MTL_AMBIENT_RED]     = ctx->Light.Material[0].Ambient[0];
-      fcmd[MTL_AMBIENT_GREEN]   = ctx->Light.Material[0].Ambient[1];
-      fcmd[MTL_AMBIENT_BLUE]    = ctx->Light.Material[0].Ambient[2];
-      fcmd[MTL_AMBIENT_ALPHA]   = ctx->Light.Material[0].Ambient[3];
-   }
-   if (mask & FRONT_DIFFUSE_BIT) {
-      fcmd[MTL_DIFFUSE_RED]     = ctx->Light.Material[0].Diffuse[0];
-      fcmd[MTL_DIFFUSE_GREEN]   = ctx->Light.Material[0].Diffuse[1];
-      fcmd[MTL_DIFFUSE_BLUE]    = ctx->Light.Material[0].Diffuse[2];
-      fcmd[MTL_DIFFUSE_ALPHA]   = ctx->Light.Material[0].Diffuse[3];
-   }
-   if (mask & FRONT_SPECULAR_BIT) {
-      fcmd[MTL_SPECULAR_RED]    = ctx->Light.Material[0].Specular[0];
-      fcmd[MTL_SPECULAR_GREEN]  = ctx->Light.Material[0].Specular[1];
-      fcmd[MTL_SPECULAR_BLUE]   = ctx->Light.Material[0].Specular[2];
-      fcmd[MTL_SPECULAR_ALPHA]  = ctx->Light.Material[0].Specular[3];
-   }
-   if (mask & FRONT_SHININESS_BIT) {
-      fcmd[MTL_SHININESS]       = ctx->Light.Material[0].Shininess;
-   }
-
-   if (RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.mtl )) {
-      for (p = 0 ; p < MAX_LIGHTS; p++) 
-	 update_light_colors( ctx, p );
-
-      check_twoside_fallback( ctx );
-      update_global_ambient( ctx );
-   }
-   else if (RADEON_DEBUG & (RADEON_PRIMS|DEBUG_STATE))
-      fprintf(stderr, "%s: Elided noop material call\n", __FUNCTION__);
-}
-
-/* _NEW_LIGHT
- * _NEW_MODELVIEW
- * _MESA_NEW_NEED_EYE_COORDS
- *
- * Uses derived state from mesa:
- *       _VP_inf_norm
- *       _h_inf_norm
- *       _Position
- *       _NormSpotDirection
- *       _ModelViewInvScale
- *       _NeedEyeCoords
- *       _EyeZDir
- *
- * which are calculated in light.c and are correct for the current
- * lighting space (model or eye), hence dependencies on _NEW_MODELVIEW
- * and _MESA_NEW_NEED_EYE_COORDS.  
- */
-void radeonUpdateLighting( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-
-   /* Have to check these, or have an automatic shortcircuit mechanism
-    * to remove noop statechanges. (Or just do a better job on the
-    * front end).
-    */
-   {
-      GLuint tmp = rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL];
-
-      if (ctx->_NeedEyeCoords)
-	 tmp &= ~RADEON_LIGHT_IN_MODELSPACE;
-      else
-	 tmp |= RADEON_LIGHT_IN_MODELSPACE;
-      
-
-      /* Leave this test disabled: (unexplained q3 lockup) (even with
-         new packets)
-      */
-      if (tmp != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]) 
-      {
-	 RADEON_STATECHANGE( rmesa, tcl );
-	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = tmp;
-      }
-   }
-
-   {
-      GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( eye );
-      fcmd[EYE_X] = ctx->_EyeZDir[0];
-      fcmd[EYE_Y] = ctx->_EyeZDir[1];
-      fcmd[EYE_Z] = - ctx->_EyeZDir[2];
-      fcmd[EYE_RESCALE_FACTOR] = ctx->_ModelViewInvScale;
-      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.eye );
-   }
-
-
-/*     RADEON_STATECHANGE( rmesa, glt ); */
-
-   if (ctx->Light.Enabled) {
-      GLint p;
-      for (p = 0 ; p < MAX_LIGHTS; p++) {
-	 if (ctx->Light.Light[p].Enabled) {
-	    struct gl_light *l = &ctx->Light.Light[p];
-	    GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( lit[p] );
-	    
-	    if (l->EyePosition[3] == 0.0) {
-	       COPY_3FV( &fcmd[LIT_POSITION_X], l->_VP_inf_norm ); 
-	       COPY_3FV( &fcmd[LIT_DIRECTION_X], l->_h_inf_norm ); 
-	       fcmd[LIT_POSITION_W] = 0;
-	       fcmd[LIT_DIRECTION_W] = 0;
-	    } else {
-	       COPY_4V( &fcmd[LIT_POSITION_X], l->_Position );
-	       fcmd[LIT_DIRECTION_X] = -l->_NormSpotDirection[0];
-	       fcmd[LIT_DIRECTION_Y] = -l->_NormSpotDirection[1];
-	       fcmd[LIT_DIRECTION_Z] = -l->_NormSpotDirection[2];
-	       fcmd[LIT_DIRECTION_W] = 0;
-	    }
-
-	    RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.lit[p] );
-	 }
-      }
-   }
-}
-
-
-void radeonLightfv( GLcontext *ctx, GLenum light,
-		    GLenum pname, const GLfloat *params )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   GLint p = light - GL_LIGHT0;
-   struct gl_light *l = &ctx->Light.Light[p];
-   GLfloat *fcmd = (GLfloat *)rmesa->hw.lit[p].cmd;
-   
-
-   switch (pname) {
-   case GL_AMBIENT:		
-   case GL_DIFFUSE:
-   case GL_SPECULAR:
-      update_light_colors( ctx, p );
-      break;
-
-   case GL_SPOT_DIRECTION: 
-      /* picked up in update_light */	
-      break;
-
-   case GL_POSITION: {
-      /* positions picked up in update_light, but can do flag here */	
-      GLuint flag = (p&1)? RADEON_LIGHT_1_IS_LOCAL : RADEON_LIGHT_0_IS_LOCAL;
-      GLuint idx = TCL_PER_LIGHT_CTL_0 + p/2;
-
-      RADEON_STATECHANGE(rmesa, tcl);
-      if (l->EyePosition[3] != 0.0F)
-	 rmesa->hw.tcl.cmd[idx] |= flag;
-      else
-	 rmesa->hw.tcl.cmd[idx] &= ~flag;
-      break;
-   }
-
-   case GL_SPOT_EXPONENT:
-      RADEON_STATECHANGE(rmesa, lit[p]);
-      fcmd[LIT_SPOT_EXPONENT] = params[0];
-      break;
-
-   case GL_SPOT_CUTOFF: {
-      GLuint flag = (p&1) ? RADEON_LIGHT_1_IS_SPOT : RADEON_LIGHT_0_IS_SPOT;
-      GLuint idx = TCL_PER_LIGHT_CTL_0 + p/2;
-
-      RADEON_STATECHANGE(rmesa, lit[p]);
-      fcmd[LIT_SPOT_CUTOFF] = l->_CosCutoff;
-
-      RADEON_STATECHANGE(rmesa, tcl);
-      if (l->SpotCutoff != 180.0F)
-	 rmesa->hw.tcl.cmd[idx] |= flag;
-      else
-	 rmesa->hw.tcl.cmd[idx] &= ~flag;
-      break;
-   }
-
-   case GL_CONSTANT_ATTENUATION:
-      RADEON_STATECHANGE(rmesa, lit[p]);
-      fcmd[LIT_ATTEN_CONST] = params[0];
-      break;
-   case GL_LINEAR_ATTENUATION:
-      RADEON_STATECHANGE(rmesa, lit[p]);
-      fcmd[LIT_ATTEN_LINEAR] = params[0];
-      break;
-   case GL_QUADRATIC_ATTENUATION:
-      RADEON_STATECHANGE(rmesa, lit[p]);
-      fcmd[LIT_ATTEN_QUADRATIC] = params[0];
-      break;
-   default:
-      return;
-   }
-
-}
-
-		  
-
-
-void radeonLightModelfv( GLcontext *ctx, GLenum pname,
-			 const GLfloat *param )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-
-   switch (pname) {
-      case GL_LIGHT_MODEL_AMBIENT: 
-	 update_global_ambient( ctx );
-	 break;
-
-      case GL_LIGHT_MODEL_LOCAL_VIEWER:
-	 RADEON_STATECHANGE( rmesa, tcl );
-	 if (ctx->Light.Model.LocalViewer)
-	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LOCAL_VIEWER;
-	 else
-	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_LOCAL_VIEWER;
-         break;
-
-      case GL_LIGHT_MODEL_TWO_SIDE:
-	 RADEON_STATECHANGE( rmesa, tcl );
-	 if (ctx->Light.Model.TwoSide)
-	    rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_LIGHT_TWOSIDE;
-	 else
-	    rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_LIGHT_TWOSIDE;
-
-	 check_twoside_fallback( ctx );
-
-#if _HAVE_SWTNL
-	 if (rmesa->TclFallback) {
-	    radeonChooseRenderState( ctx );
-	    radeonChooseVertexState( ctx );
-	 }
-#endif
-         break;
-
-      case GL_LIGHT_MODEL_COLOR_CONTROL:
-	 radeonUpdateSpecular(ctx);
-
-	 RADEON_STATECHANGE( rmesa, tcl );
-	 if (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR) 
-	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= 
-	       ~RADEON_DIFFUSE_SPECULAR_COMBINE;
-	 else
-	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= 
-	       RADEON_DIFFUSE_SPECULAR_COMBINE;
-         break;
-
-      default:
-         break;
-   }
-}
-
-
-/* =============================================================
- * Fog
- */
-
-
-static void radeonFogfv( GLcontext *ctx, GLenum pname, const GLfloat *param )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   union { int i; float f; } c, d;
-   GLchan col[4];
-
-   c.i = rmesa->hw.fog.cmd[FOG_C];
-   d.i = rmesa->hw.fog.cmd[FOG_D];
-
-   switch (pname) {
-   case GL_FOG_MODE:
-      if (!ctx->Fog.Enabled)
-	 return;
-      RADEON_STATECHANGE(rmesa, tcl);
-      rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_TCL_FOG_MASK;
-      switch (ctx->Fog.Mode) {
-      case GL_LINEAR:
-	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_LINEAR;
-	 if (ctx->Fog.Start == ctx->Fog.End) {
-	    c.f = 1.0F;
-	    d.f = 1.0F;
-	 }
-	 else {
-	    c.f = ctx->Fog.End/(ctx->Fog.End-ctx->Fog.Start);
-	    d.f = 1.0/(ctx->Fog.End-ctx->Fog.Start);
-	 }
-	 break;
-      case GL_EXP:
-	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_EXP;
-	 c.f = 0.0;
-	 d.f = ctx->Fog.Density;
-	 break;
-      case GL_EXP2:
-	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_EXP2;
-	 c.f = 0.0;
-	 d.f = -(ctx->Fog.Density * ctx->Fog.Density);
-	 break;
-      default:
-	 return;
-      }
-      break;
-   case GL_FOG_DENSITY:
-      switch (ctx->Fog.Mode) {
-      case GL_EXP:
-	 c.f = 0.0;
-	 d.f = ctx->Fog.Density;
-	 break;
-      case GL_EXP2:
-	 c.f = 0.0;
-	 d.f = -(ctx->Fog.Density * ctx->Fog.Density);
-	 break;
-      default:
-	 break;
-      }
-      break;
-   case GL_FOG_START:
-   case GL_FOG_END:
-      if (ctx->Fog.Mode == GL_LINEAR) {
-	 if (ctx->Fog.Start == ctx->Fog.End) {
-	    c.f = 1.0F;
-	    d.f = 1.0F;
-	 } else {
-	    c.f = ctx->Fog.End/(ctx->Fog.End-ctx->Fog.Start);
-	    d.f = 1.0/(ctx->Fog.End-ctx->Fog.Start);
-	 }
-      }
-      break;
-   case GL_FOG_COLOR: 
-      RADEON_STATECHANGE( rmesa, ctx );
-      UNCLAMPED_FLOAT_TO_RGB_CHAN( col, ctx->Fog.Color );
-      rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] =
-	 radeonPackColor( 4, col[0], col[1], col[2], 0 );
-      break;
-   case GL_FOG_COORDINATE_SOURCE_EXT: 
-      /* What to do?
-       */
-      break;
-   default:
-      return;
-   }
-
-   if (c.i != rmesa->hw.fog.cmd[FOG_C] || d.i != rmesa->hw.fog.cmd[FOG_D]) {
-      RADEON_STATECHANGE( rmesa, fog );
-      rmesa->hw.fog.cmd[FOG_C] = c.i;
-      rmesa->hw.fog.cmd[FOG_D] = d.i;
-   }
-}
-
-/* Examine lighting and texture state to determine if separate specular
- * should be enabled.
- */
-void radeonUpdateSpecular( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   GLuint p = rmesa->hw.ctx.cmd[CTX_PP_CNTL];
-
-   if (NEED_SECONDARY_COLOR(ctx)) {
-      p |=  RADEON_SPECULAR_ENABLE;
-   } else {
-      p &= ~RADEON_SPECULAR_ENABLE;
-   }
-
-   if ( rmesa->hw.ctx.cmd[CTX_PP_CNTL] != p ) {
-      RADEON_STATECHANGE( rmesa, ctx );
-      rmesa->hw.ctx.cmd[CTX_PP_CNTL] = p;
-   }
-
-   /* Bizzare: have to leave lighting enabled to get fog.
-    */
-   RADEON_STATECHANGE( rmesa, tcl );
-   if ((ctx->Light.Enabled &&
-	ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)) {
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_SPECULAR;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
-   }
-   else if (ctx->Fog.Enabled) {
-      if (ctx->Light.Enabled) {
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_SPECULAR;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_DIFFUSE;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
-      } else {
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_SPECULAR;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_DIFFUSE;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
-	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
-      }
-   }
-   else if (ctx->Light.Enabled) {
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_SPECULAR;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~RADEON_TCL_VTX_PK_SPEC;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
-   } else if (ctx->Fog.ColorSumEnabled ) {
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_SPECULAR;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_LIGHTING_ENABLE;
-   } else {
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_SPECULAR;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~RADEON_TCL_VTX_PK_SPEC;
-      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_LIGHTING_ENABLE;
-   }
-
-#if _HAVE_SWTNL
-   /* Update vertex/render formats
-    */
-   if (rmesa->TclFallback) { 
-      radeonChooseRenderState( ctx );
-      radeonChooseVertexState( ctx );
-   }
-#endif
-}
-
-
-
-static void radeonLightingSpaceChange( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   GLboolean tmp;
-   RADEON_STATECHANGE( rmesa, tcl );
-
-   if (RADEON_DEBUG & RADEON_STATE)
-      fprintf(stderr, "%s %d\n", __FUNCTION__, ctx->_NeedEyeCoords);
-
-   if (ctx->_NeedEyeCoords)
-      tmp = ctx->Transform.RescaleNormals;
-   else
-      tmp = !ctx->Transform.RescaleNormals;
-
-   if ( tmp ) {
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |=  RADEON_RESCALE_NORMALS;
-   } else {
-      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_RESCALE_NORMALS;
-   }
-}
-
-void radeonInitLightStateFuncs( GLcontext *ctx )
-{
-   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
-   int i;
-
-   ctx->Driver.LightModelfv		= radeonLightModelfv; 
-   ctx->Driver.Lightfv			= radeonLightfv; 
-   ctx->Driver.Fogfv			= radeonFogfv;
-   ctx->Driver.LightingSpaceChange      = radeonLightingSpaceChange;
-
-   for (i = 0 ; i < 8; i++) {
-      struct gl_light *l = &ctx->Light.Light[i];
-      GLenum p = GL_LIGHT0 + i;
-      *(float *)&(rmesa->hw.lit[i].cmd[LIT_RANGE_CUTOFF]) = FLT_MAX;
-
-      ctx->Driver.Lightfv( ctx, p, GL_AMBIENT, l->Ambient );
-      ctx->Driver.Lightfv( ctx, p, GL_DIFFUSE, l->Diffuse );
-      ctx->Driver.Lightfv( ctx, p, GL_SPECULAR, l->Specular );
-      ctx->Driver.Lightfv( ctx, p, GL_POSITION, 0 );
-      ctx->Driver.Lightfv( ctx, p, GL_SPOT_DIRECTION, 0 );
-      ctx->Driver.Lightfv( ctx, p, GL_SPOT_EXPONENT, &l->SpotExponent );
-      ctx->Driver.Lightfv( ctx, p, GL_SPOT_CUTOFF, &l->SpotCutoff );
-      ctx->Driver.Lightfv( ctx, p, GL_CONSTANT_ATTENUATION,
-			   &l->ConstantAttenuation );
-      ctx->Driver.Lightfv( ctx, p, GL_LINEAR_ATTENUATION, 
-			   &l->LinearAttenuation );
-      ctx->Driver.Lightfv( ctx, p, GL_QUADRATIC_ATTENUATION, 
-		     &l->QuadraticAttenuation );
-   }
-
-   ctx->Driver.LightModelfv( ctx, GL_LIGHT_MODEL_AMBIENT, 
-			     ctx->Light.Model.Ambient );
-
-   ctx->Driver.Fogfv( ctx, GL_FOG_MODE, 0 );
-   ctx->Driver.Fogfv( ctx, GL_FOG_DENSITY, &ctx->Fog.Density );
-   ctx->Driver.Fogfv( ctx, GL_FOG_START, &ctx->Fog.Start );
-   ctx->Driver.Fogfv( ctx, GL_FOG_END, &ctx->Fog.End );
-   ctx->Driver.Fogfv( ctx, GL_FOG_COLOR, ctx->Fog.Color );
-   ctx->Driver.Fogfv( ctx, GL_FOG_COORDINATE_SOURCE_EXT, 0 );
-}
diff --git a/src/mesa/drivers/dri/radeon/radeon_tcl.c b/src/mesa/drivers/dri/radeon/radeon_tcl.c
index b334ea0..cd02bfb 100644
--- a/src/mesa/drivers/dri/radeon/radeon_tcl.c
+++ b/src/mesa/drivers/dri/radeon/radeon_tcl.c
@@ -412,6 +412,7 @@ static GLuint radeonEnsureEmitSize( GLcontext * ctx , GLuint inputs )
 	space_required += vbuf;
       else
 	space_required += index + elts;
+      space_required += VB->Primitive[i].count * 3;
       space_required += AOS_BUFSZ(nr_aos);
     }
     space_required += SCISSOR_BUFSZ;
diff --git a/src/mesa/drivers/dri/savage/savagedd.c b/src/mesa/drivers/dri/savage/savagedd.c
index 32ca86d..bbf49ae 100644
--- a/src/mesa/drivers/dri/savage/savagedd.c
+++ b/src/mesa/drivers/dri/savage/savagedd.c
@@ -29,15 +29,11 @@
 #include <stdio.h>
 
 #include "main/mm.h"
-#include "swrast/swrast.h"
 
 #include "savagedd.h"
 #include "savagestate.h"
-#include "savagespan.h"
 #include "savagetex.h"
-#include "savagetris.h"
 #include "savagecontext.h"
-#include "main/extensions.h"
 
 #include "utils.h"
 
diff --git a/src/mesa/drivers/dri/savage/savageioctl.c b/src/mesa/drivers/dri/savage/savageioctl.c
index 77ab8d1..624d6af 100644
--- a/src/mesa/drivers/dri/savage/savageioctl.c
+++ b/src/mesa/drivers/dri/savage/savageioctl.c
@@ -37,12 +37,10 @@
 
 #include "savagecontext.h"
 #include "savageioctl.h"
-#include "savage_bci.h"
 #include "savagestate.h"
 #include "savagespan.h"
 
 #include "drm.h"
-#include <sys/ioctl.h>
 #include <sys/timeb.h>
 
 #define DEPTH_SCALE_16 ((1<<16)-1)
diff --git a/src/mesa/drivers/dri/savage/savagerender.c b/src/mesa/drivers/dri/savage/savagerender.c
index 32c74f9..d096dfe 100644
--- a/src/mesa/drivers/dri/savage/savagerender.c
+++ b/src/mesa/drivers/dri/savage/savagerender.c
@@ -36,7 +36,6 @@
 #include "tnl/t_context.h"
 
 #include "savagecontext.h"
-#include "savagetris.h"
 #include "savagestate.h"
 #include "savageioctl.h"
 
diff --git a/src/mesa/drivers/dri/savage/savagespan.c b/src/mesa/drivers/dri/savage/savagespan.c
index 3bb6fbc..c6818d3 100644
--- a/src/mesa/drivers/dri/savage/savagespan.c
+++ b/src/mesa/drivers/dri/savage/savagespan.c
@@ -26,7 +26,6 @@
 #include "savagedd.h"
 #include "savagespan.h"
 #include "savageioctl.h"
-#include "savage_bci.h"
 #include "savage_3d_reg.h"
 #include "swrast/swrast.h"
 
diff --git a/src/mesa/drivers/dri/savage/savagetex.c b/src/mesa/drivers/dri/savage/savagetex.c
index 6c97bb6..e09e52b 100644
--- a/src/mesa/drivers/dri/savage/savagetex.c
+++ b/src/mesa/drivers/dri/savage/savagetex.c
@@ -33,8 +33,6 @@
 #include "main/simple_list.h"
 #include "main/enums.h"
 
-#include "swrast/swrast.h"
-
 #include "savagecontext.h"
 #include "savagetex.h"
 #include "savagetris.h"
diff --git a/src/mesa/drivers/dri/savage/savagetris.c b/src/mesa/drivers/dri/savage/savagetris.c
index 0714101..8646200 100644
--- a/src/mesa/drivers/dri/savage/savagetris.c
+++ b/src/mesa/drivers/dri/savage/savagetris.c
@@ -52,7 +52,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "savagestate.h"
 #include "savagetex.h"
 #include "savageioctl.h"
-#include "savage_bci.h"
 
 static void savageRasterPrimitive( GLcontext *ctx, GLuint prim );
 static void savageRenderPrimitive( GLcontext *ctx, GLenum prim );
diff --git a/src/mesa/drivers/dri/sis/sis6326_state.c b/src/mesa/drivers/dri/sis/sis6326_state.c
index 65d4c06..52008c7 100644
--- a/src/mesa/drivers/dri/sis/sis6326_state.c
+++ b/src/mesa/drivers/dri/sis/sis6326_state.c
@@ -34,14 +34,12 @@
 #include "sis_reg.h"
 
 #include "main/context.h"
-#include "main/enums.h"
 #include "main/colormac.h"
 #include "swrast/swrast.h"
 #include "vbo/vbo.h"
 #include "tnl/tnl.h"
 #include "swrast_setup/swrast_setup.h"
 
-#include "tnl/t_pipeline.h"
 
 /* =============================================================
  * Alpha blending
diff --git a/src/mesa/drivers/dri/sis/sis_context.c b/src/mesa/drivers/dri/sis/sis_context.c
index f501e7a..b5586b7 100644
--- a/src/mesa/drivers/dri/sis/sis_context.c
+++ b/src/mesa/drivers/dri/sis/sis_context.c
@@ -43,8 +43,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sis_alloc.h"
 
 #include "main/imports.h"
-#include "main/matrix.h"
-#include "main/extensions.h"
 #include "utils.h"
 #include "main/framebuffer.h"
 
@@ -55,7 +53,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "vbo/vbo.h"
 
 #include "tnl/tnl.h"
-#include "tnl/t_pipeline.h"
 
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_secondary_color
@@ -83,6 +80,7 @@ static struct dri_extension card_extensions[] =
     { NULL,                                NULL }
 };
 
+#if 0
 static struct dri_extension card_extensions_6326[] =
 {
     /*{ "GL_ARB_texture_border_clamp",       NULL },*/
@@ -90,6 +88,7 @@ static struct dri_extension card_extensions_6326[] =
     /*{ "GL_MESA_ycbcr_texture",             NULL },*/
     { NULL,                                NULL }
 };
+#endif
 
 static const struct dri_debug_control debug_control[] =
 {
diff --git a/src/mesa/drivers/dri/sis/sis_dd.c b/src/mesa/drivers/dri/sis/sis_dd.c
index 217d775..fe4ade8 100644
--- a/src/mesa/drivers/dri/sis/sis_dd.c
+++ b/src/mesa/drivers/dri/sis/sis_dd.c
@@ -40,9 +40,7 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sis_state.h"
 #include "sis_tris.h"
 
-#include "swrast/swrast.h"
 #include "main/formats.h"
-#include "main/framebuffer.h"
 #include "main/renderbuffer.h"
 
 #include "utils.h"
diff --git a/src/mesa/drivers/dri/sis/sis_fog.c b/src/mesa/drivers/dri/sis/sis_fog.c
index 517d572..6c774e0 100644
--- a/src/mesa/drivers/dri/sis/sis_fog.c
+++ b/src/mesa/drivers/dri/sis/sis_fog.c
@@ -33,7 +33,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include "sis_context.h"
 #include "sis_state.h"
-#include "swrast/swrast.h"
 
 #include "main/macros.h"
 
diff --git a/src/mesa/drivers/dri/sis/sis_screen.c b/src/mesa/drivers/dri/sis/sis_screen.c
index fec9158..f0e4e81 100644
--- a/src/mesa/drivers/dri/sis/sis_screen.c
+++ b/src/mesa/drivers/dri/sis/sis_screen.c
@@ -39,7 +39,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sis_context.h"
 #include "sis_dri.h"
 #include "sis_lock.h"
-#include "sis_span.h"
 
 #include "xmlpool.h"
 
diff --git a/src/mesa/drivers/dri/sis/sis_state.c b/src/mesa/drivers/dri/sis/sis_state.c
index 98e8d02..a22195c 100644
--- a/src/mesa/drivers/dri/sis/sis_state.c
+++ b/src/mesa/drivers/dri/sis/sis_state.c
@@ -35,17 +35,13 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sis_state.h"
 #include "sis_tris.h"
 #include "sis_lock.h"
-#include "sis_tex.h"
 
 #include "main/context.h"
-#include "main/enums.h"
-#include "main/colormac.h"
 #include "swrast/swrast.h"
 #include "vbo/vbo.h"
 #include "tnl/tnl.h"
 #include "swrast_setup/swrast_setup.h"
 
-#include "tnl/t_pipeline.h"
 
 /* =============================================================
  * Alpha blending
diff --git a/src/mesa/drivers/dri/sis/sis_tex.c b/src/mesa/drivers/dri/sis/sis_tex.c
index 951c470..31709c3 100644
--- a/src/mesa/drivers/dri/sis/sis_tex.c
+++ b/src/mesa/drivers/dri/sis/sis_tex.c
@@ -31,7 +31,6 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "swrast/swrast.h"
 #include "main/imports.h"
 #include "main/texstore.h"
-#include "main/teximage.h"
 #include "main/texobj.h"
 
 #include "sis_context.h"
diff --git a/src/mesa/drivers/dri/sis/sis_texstate.c b/src/mesa/drivers/dri/sis/sis_texstate.c
index a507173..e96a2e8 100644
--- a/src/mesa/drivers/dri/sis/sis_texstate.c
+++ b/src/mesa/drivers/dri/sis/sis_texstate.c
@@ -38,7 +38,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "main/macros.h"
 
 #include "sis_context.h"
-#include "sis_state.h"
 #include "sis_tex.h"
 #include "sis_tris.h"
 #include "sis_alloc.h"
diff --git a/src/mesa/drivers/dri/sis/sis_tris.c b/src/mesa/drivers/dri/sis/sis_tris.c
index 4fa2e41..aaa23db 100644
--- a/src/mesa/drivers/dri/sis/sis_tris.c
+++ b/src/mesa/drivers/dri/sis/sis_tris.c
@@ -47,7 +47,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "sis_state.h"
 #include "sis_lock.h"
 #include "sis_span.h"
-#include "sis_alloc.h"
 #include "sis_tex.h"
 
 /* 6326 and 300-series shared */
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_dd.c b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
index 8472df6..2cbbeb8 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_dd.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
@@ -35,17 +35,10 @@
 #include "tdfx_context.h"
 #include "tdfx_dd.h"
 #include "tdfx_lock.h"
-#include "tdfx_vb.h"
 #include "tdfx_pixels.h"
 
 #include "utils.h"
 #include "main/context.h"
-#include "main/enums.h"
-#include "main/framebuffer.h"
-#include "swrast/swrast.h"
-#if defined(USE_X86_ASM)
-#include "x86/common_x86_asm.h"
-#endif
 
 
 #define DRIVER_DATE	"20061113"
@@ -91,7 +84,7 @@ static const GLubyte *tdfxDDGetString( GLcontext *ctx, GLenum name )
       else {
 	 /* unexpected result: replace spaces with hyphens */
 	 int i;
-	 for (i = 0; hardware[i] && (i < sizeof(hardware)); i++) {
+	 for (i = 0; i < sizeof(hardware) && hardware[i]; i++) {
 	    if (hardware[i] == ' ' || hardware[i] == '\t') {
 	       hardware[i] = '-';
 	    }
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_lock.c b/src/mesa/drivers/dri/tdfx/tdfx_lock.c
index 17cdc51..c00f537 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_lock.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_lock.c
@@ -38,7 +38,6 @@
 #include "tdfx_state.h"
 #include "tdfx_render.h"
 #include "tdfx_texman.h"
-#include "tdfx_tris.h"
 
 #include "drirenderbuffer.h"
 
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_pixels.c b/src/mesa/drivers/dri/tdfx/tdfx_pixels.c
index 18729d5..c213e67 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_pixels.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_pixels.c
@@ -38,7 +38,6 @@
 #include "tdfx_context.h"
 #include "tdfx_dd.h"
 #include "tdfx_lock.h"
-#include "tdfx_vb.h"
 #include "tdfx_pixels.h"
 #include "tdfx_render.h"
 
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_screen.c b/src/mesa/drivers/dri/tdfx/tdfx_screen.c
index 2eb0024..9e5f2b8 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_screen.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_screen.c
@@ -36,9 +36,7 @@
 #include "tdfx_dri.h"
 #include "tdfx_context.h"
 #include "tdfx_lock.h"
-#include "tdfx_vb.h"
 #include "tdfx_span.h"
-#include "tdfx_tris.h"
 
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_state.c b/src/mesa/drivers/dri/tdfx/tdfx_state.c
index cf27127..16b0bfc 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_state.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_state.c
@@ -40,8 +40,6 @@
 
 #include "main/mtypes.h"
 #include "main/colormac.h"
-#include "main/texstore.h"
-#include "main/teximage.h"
 
 #include "swrast/swrast.h"
 #include "vbo/vbo.h"
@@ -51,11 +49,9 @@
 
 #include "tdfx_context.h"
 #include "tdfx_state.h"
-#include "tdfx_vb.h"
 #include "tdfx_tex.h"
 #include "tdfx_texman.h"
 #include "tdfx_texstate.h"
-#include "tdfx_tris.h"
 #include "tdfx_render.h"
 
 
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_tex.c b/src/mesa/drivers/dri/tdfx/tdfx_tex.c
index 0aa09e7..e31ae97 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_tex.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_tex.c
@@ -1572,7 +1572,7 @@ tdfxCompressedTexImage2D (GLcontext *ctx, GLenum target,
     tdfxTexInfo *ti;
     tdfxMipMapLevel *mml;
     gl_format mesaFormat;
-    GLuint compressedSize;
+    GLuint compressedSize = 0;
 
     if (TDFX_DEBUG & DEBUG_VERBOSE_DRI) {
         fprintf(stderr, "tdfxCompressedTexImage2D: id=%d int 0x%x  %dx%d\n",
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_texman.c b/src/mesa/drivers/dri/tdfx/tdfx_texman.c
index 35636ee..726cc58 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_texman.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_texman.c
@@ -35,7 +35,6 @@
  */
 
 #include "tdfx_context.h"
-#include "tdfx_tex.h"
 #include "tdfx_texman.h"
 #include "main/texobj.h"
 #include "main/hash.h"
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_texstate.c b/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
index bbd2c8c..6658b4d 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_texstate.c
@@ -38,7 +38,6 @@
  */
 
 #include "tdfx_state.h"
-#include "tdfx_tex.h"
 #include "tdfx_texman.h"
 #include "tdfx_texstate.h"
 
@@ -1314,7 +1313,7 @@ SetupDoubleTexEnvVoodoo3(GLcontext *ctx, int tmu0,
       fxMesa->TexCombine[0].InvertRGB = FXFALSE;
       fxMesa->TexCombine[0].InvertAlpha = FXFALSE;
 
-      if ((baseFormat0 == GL_RGB) && (baseFormat0 == GL_LUMINANCE)) {
+      if ((baseFormat0 == GL_RGB) || (baseFormat0 == GL_LUMINANCE)) {
          fxMesa->AlphaCombine.Function = GR_COMBINE_FUNCTION_LOCAL;
          fxMesa->AlphaCombine.Factor = GR_COMBINE_FACTOR_NONE;
          fxMesa->AlphaCombine.Local = locala;
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_vb.c b/src/mesa/drivers/dri/tdfx/tdfx_vb.c
index 4928802..d6fcf98 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_vb.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_vb.c
@@ -29,13 +29,8 @@
 #include "main/macros.h"
 #include "main/colormac.h"
 
-#include "math/m_translate.h"
-#include "swrast_setup/swrast_setup.h"
-
 #include "tdfx_context.h"
 #include "tdfx_vb.h"
-#include "tdfx_tris.h"
-#include "tdfx_state.h"
 #include "tdfx_render.h"
 
 static void copy_pv( GLcontext *ctx, GLuint edst, GLuint esrc )
diff --git a/src/mesa/drivers/dri/unichrome/via_context.c b/src/mesa/drivers/dri/unichrome/via_context.c
index 0524bec..ff666a3 100644
--- a/src/mesa/drivers/dri/unichrome/via_context.c
+++ b/src/mesa/drivers/dri/unichrome/via_context.c
@@ -33,10 +33,7 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/formats.h"
-#include "main/matrix.h"
-#include "main/state.h"
 #include "main/simple_list.h"
-#include "main/extensions.h"
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
 
diff --git a/src/mesa/drivers/dri/unichrome/via_ioctl.c b/src/mesa/drivers/dri/unichrome/via_ioctl.c
index 91c94fa..69eac44 100644
--- a/src/mesa/drivers/dri/unichrome/via_ioctl.c
+++ b/src/mesa/drivers/dri/unichrome/via_ioctl.c
@@ -34,7 +34,6 @@
 #include "via_context.h"
 #include "via_tris.h"
 #include "via_ioctl.h"
-#include "via_state.h"
 #include "via_fb.h"
 #include "via_3d_reg.h"
 
diff --git a/src/mesa/drivers/dri/unichrome/via_render.c b/src/mesa/drivers/dri/unichrome/via_render.c
index f676cc1..896c43d 100644
--- a/src/mesa/drivers/dri/unichrome/via_render.c
+++ b/src/mesa/drivers/dri/unichrome/via_render.c
@@ -37,7 +37,6 @@
 
 #include "via_context.h"
 #include "via_tris.h"
-#include "via_state.h"
 #include "via_ioctl.h"
 
 /*
diff --git a/src/mesa/drivers/dri/unichrome/via_screen.c b/src/mesa/drivers/dri/unichrome/via_screen.c
index e0bf58c..115d3fb 100644
--- a/src/mesa/drivers/dri/unichrome/via_screen.c
+++ b/src/mesa/drivers/dri/unichrome/via_screen.c
@@ -30,17 +30,13 @@
 #include "main/context.h"
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
-#include "main/matrix.h"
 #include "main/simple_list.h"
 #include "vblank.h"
 
 #include "via_state.h"
 #include "via_tex.h"
 #include "via_span.h"
-#include "via_tris.h"
-#include "via_ioctl.h"
 #include "via_screen.h"
-#include "via_fb.h"
 #include "via_dri.h"
 
 #include "GL/internal/dri_interface.h"
diff --git a/src/mesa/drivers/dri/unichrome/via_state.c b/src/mesa/drivers/dri/unichrome/via_state.c
index 840e4e4..e65f5fd 100644
--- a/src/mesa/drivers/dri/unichrome/via_state.c
+++ b/src/mesa/drivers/dri/unichrome/via_state.c
@@ -35,7 +35,6 @@
 #include "via_context.h"
 #include "via_state.h"
 #include "via_tex.h"
-#include "via_tris.h"
 #include "via_ioctl.h"
 #include "via_3d_reg.h"
 
@@ -44,8 +43,6 @@
 #include "tnl/tnl.h"
 #include "swrast_setup/swrast_setup.h"
 
-#include "tnl/t_pipeline.h"
-
 
 static GLuint ROP[16] = {
     HC_HROP_BLACK,    /* GL_CLEAR           0                      	*/
diff --git a/src/mesa/drivers/dri/unichrome/via_tex.c b/src/mesa/drivers/dri/unichrome/via_tex.c
index 24924d2..917f975 100644
--- a/src/mesa/drivers/dri/unichrome/via_tex.c
+++ b/src/mesa/drivers/dri/unichrome/via_tex.c
@@ -37,14 +37,12 @@
 #include "main/mipmap.h"
 #include "main/mm.h"
 #include "main/simple_list.h"
-#include "main/texcompress.h"
 #include "main/texobj.h"
 #include "main/texstore.h"
 
 #include "via_context.h"
 #include "via_fb.h"
 #include "via_tex.h"
-#include "via_state.h"
 #include "via_ioctl.h"
 #include "via_3d_reg.h"
 
diff --git a/src/mesa/drivers/dri/unichrome/via_texcombine.c b/src/mesa/drivers/dri/unichrome/via_texcombine.c
index b646897..f87ba07 100644
--- a/src/mesa/drivers/dri/unichrome/via_texcombine.c
+++ b/src/mesa/drivers/dri/unichrome/via_texcombine.c
@@ -38,7 +38,6 @@
 #include "main/enums.h"
 
 #include "via_context.h"
-#include "via_state.h"
 #include "via_tex.h"
 #include "via_3d_reg.h"
 
diff --git a/src/mesa/main/attrib.c b/src/mesa/main/attrib.c
index 246c552..7adb2e2 100644
--- a/src/mesa/main/attrib.c
+++ b/src/mesa/main/attrib.c
@@ -33,7 +33,6 @@
 #include "bufferobj.h"
 #include "clear.h"
 #include "colormac.h"
-#include "colortab.h"
 #include "context.h"
 #include "depth.h"
 #include "enable.h"
@@ -1043,22 +1042,39 @@ _mesa_PopAttrib(void)
                   _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
 	       
                for (i = 0; i < ctx->Const.MaxLights; i++) {
-		  const struct gl_light *l = &light->Light[i];
+                  const struct gl_light *l = &light->Light[i];
                   _mesa_set_enable(ctx, GL_LIGHT0 + i, l->Enabled);
-		  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
-		  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
-		  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
-		  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
-		  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
-		  _mesa_light(ctx, i, GL_SPOT_EXPONENT, &l->SpotExponent);
-		  _mesa_light(ctx, i, GL_SPOT_CUTOFF, &l->SpotCutoff);
-		  _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION,
-                              &l->ConstantAttenuation);
-		  _mesa_light(ctx, i, GL_LINEAR_ATTENUATION,
-                              &l->LinearAttenuation);
-		  _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION,
-                              &l->QuadraticAttenuation);
-               }
+                  _mesa_light(ctx, i, GL_AMBIENT, l->Ambient);
+                  _mesa_light(ctx, i, GL_DIFFUSE, l->Diffuse);
+                  _mesa_light(ctx, i, GL_SPECULAR, l->Specular );
+                  _mesa_light(ctx, i, GL_POSITION, l->EyePosition);
+                  _mesa_light(ctx, i, GL_SPOT_DIRECTION, l->SpotDirection);
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->SpotExponent;
+                     _mesa_light(ctx, i, GL_SPOT_EXPONENT, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->SpotCutoff;
+                     _mesa_light(ctx, i, GL_SPOT_CUTOFF, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->ConstantAttenuation;
+                     _mesa_light(ctx, i, GL_CONSTANT_ATTENUATION, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->LinearAttenuation;
+                     _mesa_light(ctx, i, GL_LINEAR_ATTENUATION, p);
+                  }
+                  {
+                     GLfloat p[4] = { 0 };
+                     p[0] = l->QuadraticAttenuation;
+                     _mesa_light(ctx, i, GL_QUADRATIC_ATTENUATION, p);
+                  }
+                }
                /* light model */
                _mesa_LightModelfv(GL_LIGHT_MODEL_AMBIENT,
                                   light->Model.Ambient);
diff --git a/src/mesa/main/blend.c b/src/mesa/main/blend.c
index 830e3b2..0b6ff1a 100644
--- a/src/mesa/main/blend.c
+++ b/src/mesa/main/blend.c
@@ -35,7 +35,6 @@
 #include "enums.h"
 #include "macros.h"
 #include "mtypes.h"
-#include "glapi/glapitable.h"
 
 
 /**
diff --git a/src/mesa/main/buffers.c b/src/mesa/main/buffers.c
index 97f0659..fb30b59 100644
--- a/src/mesa/main/buffers.c
+++ b/src/mesa/main/buffers.c
@@ -35,8 +35,6 @@
 #include "colormac.h"
 #include "context.h"
 #include "enums.h"
-#include "fbobject.h"
-#include "state.h"
 
 
 #define BAD_MASK ~0u
diff --git a/src/mesa/main/convolve.c b/src/mesa/main/convolve.c
index 8db3e79..5ed93e0 100644
--- a/src/mesa/main/convolve.c
+++ b/src/mesa/main/convolve.c
@@ -38,7 +38,6 @@
 #include "context.h"
 #include "image.h"
 #include "mtypes.h"
-#include "pixel.h"
 #include "state.h"
 #include "glapi/dispatch.h"
 
diff --git a/src/mesa/main/debug.c b/src/mesa/main/debug.c
index a42113e..9bad834 100644
--- a/src/mesa/main/debug.c
+++ b/src/mesa/main/debug.c
@@ -26,7 +26,6 @@
 #include "mtypes.h"
 #include "attrib.h"
 #include "colormac.h"
-#include "context.h"
 #include "enums.h"
 #include "formats.h"
 #include "hash.h"
@@ -35,7 +34,6 @@
 #include "get.h"
 #include "pixelstore.h"
 #include "readpix.h"
-#include "texgetimage.h"
 #include "texobj.h"
 
 
@@ -54,7 +52,7 @@ const char *_mesa_prim_name[GL_POLYGON+4] = {
    "GL_QUAD_STRIP",
    "GL_POLYGON",
    "outside begin/end",
-   "inside unkown primitive",
+   "inside unknown primitive",
    "unknown state"
 };
 
diff --git a/src/mesa/main/depthstencil.c b/src/mesa/main/depthstencil.c
index 193c7f8..49946a6 100644
--- a/src/mesa/main/depthstencil.c
+++ b/src/mesa/main/depthstencil.c
@@ -25,7 +25,6 @@
 #include "glheader.h"
 #include "imports.h"
 #include "context.h"
-#include "fbobject.h"
 #include "formats.h"
 #include "mtypes.h"
 #include "depthstencil.h"
diff --git a/src/mesa/main/dispatch.c b/src/mesa/main/dispatch.c
index 97d213e..eb0d1ff 100644
--- a/src/mesa/main/dispatch.c
+++ b/src/mesa/main/dispatch.c
@@ -37,8 +37,6 @@
  * \author Brian Paul <brian@precisioninsight.com>
  */
 
-#ifndef GLX_USE_APPLEGL
-
 #include "main/glheader.h"
 #include "main/compiler.h"
 #include "glapi/glapi.h"
@@ -92,5 +90,3 @@
 #include "glapi/glapitemp.h"
 
 #endif /* USE_X86_ASM */
-
-#endif /* !GLX_USE_APPLEGL */
diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index b692c33..a90bb6c 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -35,46 +35,25 @@
 #include "api_loopback.h"
 #include "config.h"
 #include "mfeatures.h"
-#include "attrib.h"
-#include "blend.h"
-#include "buffers.h"
 #if FEATURE_ARB_vertex_buffer_object
 #include "bufferobj.h"
 #endif
 #include "arrayobj.h"
-#include "clip.h"
-#include "colortab.h"
 #include "context.h"
-#include "convolve.h"
-#include "depth.h"
 #include "dlist.h"
-#include "enable.h"
 #include "enums.h"
 #include "eval.h"
-#include "extensions.h"
-#include "feedback.h"
 #include "framebuffer.h"
-#include "get.h"
 #include "glapi/glapi.h"
 #include "hash.h"
-#include "histogram.h"
 #include "image.h"
 #include "light.h"
-#include "lines.h"
 #include "dlist.h"
 #include "macros.h"
-#include "matrix.h"
-#include "pixel.h"
-#include "points.h"
-#include "polygon.h"
 #include "queryobj.h"
-#include "state.h"
-#include "texobj.h"
 #include "teximage.h"
-#include "texstate.h"
 #include "mtypes.h"
 #include "varray.h"
-#include "vtxfmt.h"
 #if FEATURE_ARB_vertex_program || FEATURE_ARB_fragment_program
 #include "shader/arbprogram.h"
 #include "shader/program.h"
diff --git a/src/mesa/main/drawpix.c b/src/mesa/main/drawpix.c
index 5d4b53a..0afd47b 100644
--- a/src/mesa/main/drawpix.c
+++ b/src/mesa/main/drawpix.c
@@ -30,7 +30,6 @@
 #include "enums.h"
 #include "feedback.h"
 #include "framebuffer.h"
-#include "image.h"
 #include "readpix.h"
 #include "state.h"
 #include "glapi/dispatch.h"
diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index 12ce14c..1573bc2 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -32,7 +32,6 @@
 #include "context.h"
 #include "enable.h"
 #include "light.h"
-#include "macros.h"
 #include "simple_list.h"
 #include "mtypes.h"
 #include "enums.h"
diff --git a/src/mesa/main/enums.c b/src/mesa/main/enums.c
index f9f4bc7..8a39401 100644
--- a/src/mesa/main/enums.c
+++ b/src/mesa/main/enums.c
@@ -1787,7 +1787,6 @@ LONGSTRING static const char enum_string_table[] =
    "GL_TEXTURE_WRAP_S\0"
    "GL_TEXTURE_WRAP_T\0"
    "GL_TIMEOUT_EXPIRED\0"
-   "GL_TIMEOUT_IGNORED\0"
    "GL_TIME_ELAPSED_EXT\0"
    "GL_TRACK_MATRIX_NV\0"
    "GL_TRACK_MATRIX_TRANSFORM_NV\0"
@@ -1919,7 +1918,7 @@ LONGSTRING static const char enum_string_table[] =
    "GL_ZOOM_Y\0"
    ;
 
-static const enum_elt all_enums[1881] =
+static const enum_elt all_enums[1880] =
 {
    {     0, 0x00000600 }, /* GL_2D */
    {     6, 0x00001407 }, /* GL_2_BYTES */
@@ -3672,147 +3671,146 @@ static const enum_elt all_enums[1881] =
    { 37686, 0x00002802 }, /* GL_TEXTURE_WRAP_S */
    { 37704, 0x00002803 }, /* GL_TEXTURE_WRAP_T */
    { 37722, 0x0000911B }, /* GL_TIMEOUT_EXPIRED */
-   { 37741, 0xFFFFFFFFFFFFFFFF }, /* GL_TIMEOUT_IGNORED */
-   { 37760, 0x000088BF }, /* GL_TIME_ELAPSED_EXT */
-   { 37780, 0x00008648 }, /* GL_TRACK_MATRIX_NV */
-   { 37799, 0x00008649 }, /* GL_TRACK_MATRIX_TRANSFORM_NV */
-   { 37828, 0x00001000 }, /* GL_TRANSFORM_BIT */
-   { 37845, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX */
-   { 37871, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX_ARB */
-   { 37901, 0x000088B7 }, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
-   { 37933, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
-   { 37963, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX_ARB */
-   { 37997, 0x0000862C }, /* GL_TRANSPOSE_NV */
-   { 38013, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX */
-   { 38044, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX_ARB */
-   { 38079, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX */
-   { 38107, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX_ARB */
-   { 38139, 0x00000004 }, /* GL_TRIANGLES */
-   { 38152, 0x00000006 }, /* GL_TRIANGLE_FAN */
-   { 38168, 0x00008615 }, /* GL_TRIANGLE_MESH_SUN */
-   { 38189, 0x00000005 }, /* GL_TRIANGLE_STRIP */
-   { 38207, 0x00000001 }, /* GL_TRUE */
-   { 38215, 0x00000CF5 }, /* GL_UNPACK_ALIGNMENT */
-   { 38235, 0x0000806E }, /* GL_UNPACK_IMAGE_HEIGHT */
-   { 38258, 0x00000CF1 }, /* GL_UNPACK_LSB_FIRST */
-   { 38278, 0x00000CF2 }, /* GL_UNPACK_ROW_LENGTH */
-   { 38299, 0x0000806D }, /* GL_UNPACK_SKIP_IMAGES */
-   { 38321, 0x00000CF4 }, /* GL_UNPACK_SKIP_PIXELS */
-   { 38343, 0x00000CF3 }, /* GL_UNPACK_SKIP_ROWS */
-   { 38363, 0x00000CF0 }, /* GL_UNPACK_SWAP_BYTES */
-   { 38384, 0x00009118 }, /* GL_UNSIGNALED */
-   { 38398, 0x00001401 }, /* GL_UNSIGNED_BYTE */
-   { 38415, 0x00008362 }, /* GL_UNSIGNED_BYTE_2_3_3_REV */
-   { 38442, 0x00008032 }, /* GL_UNSIGNED_BYTE_3_3_2 */
-   { 38465, 0x00001405 }, /* GL_UNSIGNED_INT */
-   { 38481, 0x00008036 }, /* GL_UNSIGNED_INT_10_10_10_2 */
-   { 38508, 0x000084FA }, /* GL_UNSIGNED_INT_24_8 */
-   { 38529, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_EXT */
-   { 38554, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_NV */
-   { 38578, 0x00008368 }, /* GL_UNSIGNED_INT_2_10_10_10_REV */
-   { 38609, 0x00008035 }, /* GL_UNSIGNED_INT_8_8_8_8 */
-   { 38633, 0x00008367 }, /* GL_UNSIGNED_INT_8_8_8_8_REV */
-   { 38661, 0x00008C17 }, /* GL_UNSIGNED_NORMALIZED */
-   { 38684, 0x00001403 }, /* GL_UNSIGNED_SHORT */
-   { 38702, 0x00008366 }, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
-   { 38732, 0x00008033 }, /* GL_UNSIGNED_SHORT_4_4_4_4 */
-   { 38758, 0x00008365 }, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
-   { 38788, 0x00008034 }, /* GL_UNSIGNED_SHORT_5_5_5_1 */
-   { 38814, 0x00008363 }, /* GL_UNSIGNED_SHORT_5_6_5 */
-   { 38838, 0x00008364 }, /* GL_UNSIGNED_SHORT_5_6_5_REV */
-   { 38866, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_APPLE */
-   { 38894, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_MESA */
-   { 38921, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
-   { 38953, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_MESA */
-   { 38984, 0x00008CA2 }, /* GL_UPPER_LEFT */
-   { 38998, 0x00002A20 }, /* GL_V2F */
-   { 39005, 0x00002A21 }, /* GL_V3F */
-   { 39012, 0x00008B83 }, /* GL_VALIDATE_STATUS */
-   { 39031, 0x00001F00 }, /* GL_VENDOR */
-   { 39041, 0x00001F02 }, /* GL_VERSION */
-   { 39052, 0x00008074 }, /* GL_VERTEX_ARRAY */
-   { 39068, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING */
-   { 39092, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING_APPLE */
-   { 39122, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
-   { 39153, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING_ARB */
-   { 39188, 0x0000808E }, /* GL_VERTEX_ARRAY_POINTER */
-   { 39212, 0x0000807A }, /* GL_VERTEX_ARRAY_SIZE */
-   { 39233, 0x0000807C }, /* GL_VERTEX_ARRAY_STRIDE */
-   { 39256, 0x0000807B }, /* GL_VERTEX_ARRAY_TYPE */
-   { 39277, 0x00008650 }, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
-   { 39304, 0x0000865A }, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
-   { 39332, 0x0000865B }, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
-   { 39360, 0x0000865C }, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
-   { 39388, 0x0000865D }, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
-   { 39416, 0x0000865E }, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
-   { 39444, 0x0000865F }, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
-   { 39472, 0x00008651 }, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
-   { 39499, 0x00008652 }, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
-   { 39526, 0x00008653 }, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
-   { 39553, 0x00008654 }, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
-   { 39580, 0x00008655 }, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
-   { 39607, 0x00008656 }, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
-   { 39634, 0x00008657 }, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
-   { 39661, 0x00008658 }, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
-   { 39688, 0x00008659 }, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
-   { 39715, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
-   { 39753, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB */
-   { 39795, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
-   { 39826, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB */
-   { 39861, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
-   { 39895, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB */
-   { 39933, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
-   { 39964, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB */
-   { 39999, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
-   { 40027, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB */
-   { 40059, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
-   { 40089, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB */
-   { 40123, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
-   { 40151, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB */
-   { 40183, 0x000086A7 }, /* GL_VERTEX_BLEND_ARB */
-   { 40203, 0x00008620 }, /* GL_VERTEX_PROGRAM_ARB */
-   { 40225, 0x0000864A }, /* GL_VERTEX_PROGRAM_BINDING_NV */
-   { 40254, 0x00008620 }, /* GL_VERTEX_PROGRAM_NV */
-   { 40275, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE */
-   { 40304, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_ARB */
-   { 40337, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_NV */
-   { 40369, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE */
-   { 40396, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_ARB */
-   { 40427, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_NV */
-   { 40457, 0x00008B31 }, /* GL_VERTEX_SHADER */
-   { 40474, 0x00008B31 }, /* GL_VERTEX_SHADER_ARB */
-   { 40495, 0x00008621 }, /* GL_VERTEX_STATE_PROGRAM_NV */
-   { 40522, 0x00000BA2 }, /* GL_VIEWPORT */
-   { 40534, 0x00000800 }, /* GL_VIEWPORT_BIT */
-   { 40550, 0x0000911D }, /* GL_WAIT_FAILED */
-   { 40565, 0x000086AD }, /* GL_WEIGHT_ARRAY_ARB */
-   { 40585, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
-   { 40616, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB */
-   { 40651, 0x000086AC }, /* GL_WEIGHT_ARRAY_POINTER_ARB */
-   { 40679, 0x000086AB }, /* GL_WEIGHT_ARRAY_SIZE_ARB */
-   { 40704, 0x000086AA }, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
-   { 40731, 0x000086A9 }, /* GL_WEIGHT_ARRAY_TYPE_ARB */
-   { 40756, 0x000086A6 }, /* GL_WEIGHT_SUM_UNITY_ARB */
-   { 40780, 0x000081D4 }, /* GL_WRAP_BORDER_SUN */
-   { 40799, 0x000088B9 }, /* GL_WRITE_ONLY */
-   { 40813, 0x000088B9 }, /* GL_WRITE_ONLY_ARB */
-   { 40831, 0x00001506 }, /* GL_XOR */
-   { 40838, 0x000085B9 }, /* GL_YCBCR_422_APPLE */
-   { 40857, 0x00008757 }, /* GL_YCBCR_MESA */
-   { 40871, 0x00000000 }, /* GL_ZERO */
-   { 40879, 0x00000D16 }, /* GL_ZOOM_X */
-   { 40889, 0x00000D17 }, /* GL_ZOOM_Y */
+   { 37741, 0x000088BF }, /* GL_TIME_ELAPSED_EXT */
+   { 37761, 0x00008648 }, /* GL_TRACK_MATRIX_NV */
+   { 37780, 0x00008649 }, /* GL_TRACK_MATRIX_TRANSFORM_NV */
+   { 37809, 0x00001000 }, /* GL_TRANSFORM_BIT */
+   { 37826, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX */
+   { 37852, 0x000084E6 }, /* GL_TRANSPOSE_COLOR_MATRIX_ARB */
+   { 37882, 0x000088B7 }, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
+   { 37914, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
+   { 37944, 0x000084E3 }, /* GL_TRANSPOSE_MODELVIEW_MATRIX_ARB */
+   { 37978, 0x0000862C }, /* GL_TRANSPOSE_NV */
+   { 37994, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX */
+   { 38025, 0x000084E4 }, /* GL_TRANSPOSE_PROJECTION_MATRIX_ARB */
+   { 38060, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX */
+   { 38088, 0x000084E5 }, /* GL_TRANSPOSE_TEXTURE_MATRIX_ARB */
+   { 38120, 0x00000004 }, /* GL_TRIANGLES */
+   { 38133, 0x00000006 }, /* GL_TRIANGLE_FAN */
+   { 38149, 0x00008615 }, /* GL_TRIANGLE_MESH_SUN */
+   { 38170, 0x00000005 }, /* GL_TRIANGLE_STRIP */
+   { 38188, 0x00000001 }, /* GL_TRUE */
+   { 38196, 0x00000CF5 }, /* GL_UNPACK_ALIGNMENT */
+   { 38216, 0x0000806E }, /* GL_UNPACK_IMAGE_HEIGHT */
+   { 38239, 0x00000CF1 }, /* GL_UNPACK_LSB_FIRST */
+   { 38259, 0x00000CF2 }, /* GL_UNPACK_ROW_LENGTH */
+   { 38280, 0x0000806D }, /* GL_UNPACK_SKIP_IMAGES */
+   { 38302, 0x00000CF4 }, /* GL_UNPACK_SKIP_PIXELS */
+   { 38324, 0x00000CF3 }, /* GL_UNPACK_SKIP_ROWS */
+   { 38344, 0x00000CF0 }, /* GL_UNPACK_SWAP_BYTES */
+   { 38365, 0x00009118 }, /* GL_UNSIGNALED */
+   { 38379, 0x00001401 }, /* GL_UNSIGNED_BYTE */
+   { 38396, 0x00008362 }, /* GL_UNSIGNED_BYTE_2_3_3_REV */
+   { 38423, 0x00008032 }, /* GL_UNSIGNED_BYTE_3_3_2 */
+   { 38446, 0x00001405 }, /* GL_UNSIGNED_INT */
+   { 38462, 0x00008036 }, /* GL_UNSIGNED_INT_10_10_10_2 */
+   { 38489, 0x000084FA }, /* GL_UNSIGNED_INT_24_8 */
+   { 38510, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_EXT */
+   { 38535, 0x000084FA }, /* GL_UNSIGNED_INT_24_8_NV */
+   { 38559, 0x00008368 }, /* GL_UNSIGNED_INT_2_10_10_10_REV */
+   { 38590, 0x00008035 }, /* GL_UNSIGNED_INT_8_8_8_8 */
+   { 38614, 0x00008367 }, /* GL_UNSIGNED_INT_8_8_8_8_REV */
+   { 38642, 0x00008C17 }, /* GL_UNSIGNED_NORMALIZED */
+   { 38665, 0x00001403 }, /* GL_UNSIGNED_SHORT */
+   { 38683, 0x00008366 }, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
+   { 38713, 0x00008033 }, /* GL_UNSIGNED_SHORT_4_4_4_4 */
+   { 38739, 0x00008365 }, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
+   { 38769, 0x00008034 }, /* GL_UNSIGNED_SHORT_5_5_5_1 */
+   { 38795, 0x00008363 }, /* GL_UNSIGNED_SHORT_5_6_5 */
+   { 38819, 0x00008364 }, /* GL_UNSIGNED_SHORT_5_6_5_REV */
+   { 38847, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_APPLE */
+   { 38875, 0x000085BA }, /* GL_UNSIGNED_SHORT_8_8_MESA */
+   { 38902, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
+   { 38934, 0x000085BB }, /* GL_UNSIGNED_SHORT_8_8_REV_MESA */
+   { 38965, 0x00008CA2 }, /* GL_UPPER_LEFT */
+   { 38979, 0x00002A20 }, /* GL_V2F */
+   { 38986, 0x00002A21 }, /* GL_V3F */
+   { 38993, 0x00008B83 }, /* GL_VALIDATE_STATUS */
+   { 39012, 0x00001F00 }, /* GL_VENDOR */
+   { 39022, 0x00001F02 }, /* GL_VERSION */
+   { 39033, 0x00008074 }, /* GL_VERTEX_ARRAY */
+   { 39049, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING */
+   { 39073, 0x000085B5 }, /* GL_VERTEX_ARRAY_BINDING_APPLE */
+   { 39103, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
+   { 39134, 0x00008896 }, /* GL_VERTEX_ARRAY_BUFFER_BINDING_ARB */
+   { 39169, 0x0000808E }, /* GL_VERTEX_ARRAY_POINTER */
+   { 39193, 0x0000807A }, /* GL_VERTEX_ARRAY_SIZE */
+   { 39214, 0x0000807C }, /* GL_VERTEX_ARRAY_STRIDE */
+   { 39237, 0x0000807B }, /* GL_VERTEX_ARRAY_TYPE */
+   { 39258, 0x00008650 }, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
+   { 39285, 0x0000865A }, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
+   { 39313, 0x0000865B }, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
+   { 39341, 0x0000865C }, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
+   { 39369, 0x0000865D }, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
+   { 39397, 0x0000865E }, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
+   { 39425, 0x0000865F }, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
+   { 39453, 0x00008651 }, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
+   { 39480, 0x00008652 }, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
+   { 39507, 0x00008653 }, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
+   { 39534, 0x00008654 }, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
+   { 39561, 0x00008655 }, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
+   { 39588, 0x00008656 }, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
+   { 39615, 0x00008657 }, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
+   { 39642, 0x00008658 }, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
+   { 39669, 0x00008659 }, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
+   { 39696, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
+   { 39734, 0x0000889F }, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB */
+   { 39776, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
+   { 39807, 0x00008622 }, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB */
+   { 39842, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
+   { 39876, 0x0000886A }, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB */
+   { 39914, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
+   { 39945, 0x00008645 }, /* GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB */
+   { 39980, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
+   { 40008, 0x00008623 }, /* GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB */
+   { 40040, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
+   { 40070, 0x00008624 }, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB */
+   { 40104, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
+   { 40132, 0x00008625 }, /* GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB */
+   { 40164, 0x000086A7 }, /* GL_VERTEX_BLEND_ARB */
+   { 40184, 0x00008620 }, /* GL_VERTEX_PROGRAM_ARB */
+   { 40206, 0x0000864A }, /* GL_VERTEX_PROGRAM_BINDING_NV */
+   { 40235, 0x00008620 }, /* GL_VERTEX_PROGRAM_NV */
+   { 40256, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE */
+   { 40285, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_ARB */
+   { 40318, 0x00008642 }, /* GL_VERTEX_PROGRAM_POINT_SIZE_NV */
+   { 40350, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE */
+   { 40377, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_ARB */
+   { 40408, 0x00008643 }, /* GL_VERTEX_PROGRAM_TWO_SIDE_NV */
+   { 40438, 0x00008B31 }, /* GL_VERTEX_SHADER */
+   { 40455, 0x00008B31 }, /* GL_VERTEX_SHADER_ARB */
+   { 40476, 0x00008621 }, /* GL_VERTEX_STATE_PROGRAM_NV */
+   { 40503, 0x00000BA2 }, /* GL_VIEWPORT */
+   { 40515, 0x00000800 }, /* GL_VIEWPORT_BIT */
+   { 40531, 0x0000911D }, /* GL_WAIT_FAILED */
+   { 40546, 0x000086AD }, /* GL_WEIGHT_ARRAY_ARB */
+   { 40566, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
+   { 40597, 0x0000889E }, /* GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB */
+   { 40632, 0x000086AC }, /* GL_WEIGHT_ARRAY_POINTER_ARB */
+   { 40660, 0x000086AB }, /* GL_WEIGHT_ARRAY_SIZE_ARB */
+   { 40685, 0x000086AA }, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
+   { 40712, 0x000086A9 }, /* GL_WEIGHT_ARRAY_TYPE_ARB */
+   { 40737, 0x000086A6 }, /* GL_WEIGHT_SUM_UNITY_ARB */
+   { 40761, 0x000081D4 }, /* GL_WRAP_BORDER_SUN */
+   { 40780, 0x000088B9 }, /* GL_WRITE_ONLY */
+   { 40794, 0x000088B9 }, /* GL_WRITE_ONLY_ARB */
+   { 40812, 0x00001506 }, /* GL_XOR */
+   { 40819, 0x000085B9 }, /* GL_YCBCR_422_APPLE */
+   { 40838, 0x00008757 }, /* GL_YCBCR_MESA */
+   { 40852, 0x00000000 }, /* GL_ZERO */
+   { 40860, 0x00000D16 }, /* GL_ZOOM_X */
+   { 40870, 0x00000D17 }, /* GL_ZOOM_Y */
 };
 
-static const unsigned reduced_enums[1347] =
+static const unsigned reduced_enums[1346] =
 {
        479, /* GL_FALSE */
        701, /* GL_LINES */
        703, /* GL_LINE_LOOP */
        710, /* GL_LINE_STRIP */
-      1766, /* GL_TRIANGLES */
-      1769, /* GL_TRIANGLE_STRIP */
-      1767, /* GL_TRIANGLE_FAN */
+      1765, /* GL_TRIANGLES */
+      1768, /* GL_TRIANGLE_STRIP */
+      1766, /* GL_TRIANGLE_FAN */
       1285, /* GL_QUADS */
       1289, /* GL_QUAD_STRIP */
       1171, /* GL_POLYGON */
@@ -3946,7 +3944,7 @@ static const unsigned reduced_enums[1347] =
       1533, /* GL_STENCIL_WRITEMASK */
        853, /* GL_MATRIX_MODE */
       1025, /* GL_NORMALIZE */
-      1861, /* GL_VIEWPORT */
+      1860, /* GL_VIEWPORT */
        999, /* GL_MODELVIEW_STACK_DEPTH */
       1263, /* GL_PROJECTION_STACK_DEPTH */
       1740, /* GL_TEXTURE_STACK_DEPTH */
@@ -4008,12 +4006,12 @@ static const unsigned reduced_enums[1347] =
       1117, /* GL_PIXEL_MAP_G_TO_G_SIZE */
       1115, /* GL_PIXEL_MAP_B_TO_B_SIZE */
       1113, /* GL_PIXEL_MAP_A_TO_A_SIZE */
-      1778, /* GL_UNPACK_SWAP_BYTES */
-      1773, /* GL_UNPACK_LSB_FIRST */
-      1774, /* GL_UNPACK_ROW_LENGTH */
-      1777, /* GL_UNPACK_SKIP_ROWS */
-      1776, /* GL_UNPACK_SKIP_PIXELS */
-      1771, /* GL_UNPACK_ALIGNMENT */
+      1777, /* GL_UNPACK_SWAP_BYTES */
+      1772, /* GL_UNPACK_LSB_FIRST */
+      1773, /* GL_UNPACK_ROW_LENGTH */
+      1776, /* GL_UNPACK_SKIP_ROWS */
+      1775, /* GL_UNPACK_SKIP_PIXELS */
+      1770, /* GL_UNPACK_ALIGNMENT */
       1099, /* GL_PACK_SWAP_BYTES */
       1094, /* GL_PACK_LSB_FIRST */
       1095, /* GL_PACK_ROW_LENGTH */
@@ -4026,8 +4024,8 @@ static const unsigned reduced_enums[1347] =
        641, /* GL_INDEX_OFFSET */
       1313, /* GL_RED_SCALE */
       1311, /* GL_RED_BIAS */
-      1879, /* GL_ZOOM_X */
-      1880, /* GL_ZOOM_Y */
+      1878, /* GL_ZOOM_X */
+      1879, /* GL_ZOOM_Y */
        603, /* GL_GREEN_SCALE */
        601, /* GL_GREEN_BIAS */
         93, /* GL_BLUE_SCALE */
@@ -4112,11 +4110,11 @@ static const unsigned reduced_enums[1347] =
        244, /* GL_COMPILE */
        245, /* GL_COMPILE_AND_EXECUTE */
        120, /* GL_BYTE */
-      1780, /* GL_UNSIGNED_BYTE */
+      1779, /* GL_UNSIGNED_BYTE */
       1437, /* GL_SHORT */
-      1792, /* GL_UNSIGNED_SHORT */
+      1791, /* GL_UNSIGNED_SHORT */
        645, /* GL_INT */
-      1783, /* GL_UNSIGNED_INT */
+      1782, /* GL_UNSIGNED_INT */
        489, /* GL_FLOAT */
          1, /* GL_2_BYTES */
          5, /* GL_3_BYTES */
@@ -4128,7 +4126,7 @@ static const unsigned reduced_enums[1347] =
        299, /* GL_COPY */
         51, /* GL_AND_INVERTED */
       1023, /* GL_NOOP */
-      1875, /* GL_XOR */
+      1874, /* GL_XOR */
       1086, /* GL_OR */
       1024, /* GL_NOR */
        470, /* GL_EQUIV */
@@ -4172,9 +4170,9 @@ static const unsigned reduced_enums[1347] =
       1339, /* GL_REPLACE */
        627, /* GL_INCR */
        342, /* GL_DECR */
-      1807, /* GL_VENDOR */
+      1806, /* GL_VENDOR */
       1336, /* GL_RENDERER */
-      1808, /* GL_VERSION */
+      1807, /* GL_VERSION */
        474, /* GL_EXTENSIONS */
       1387, /* GL_S */
       1553, /* GL_T */
@@ -4207,8 +4205,8 @@ static const unsigned reduced_enums[1347] =
       1178, /* GL_POLYGON_OFFSET_POINT */
       1177, /* GL_POLYGON_OFFSET_LINE */
       1297, /* GL_R3_G3_B2 */
-      1804, /* GL_V2F */
-      1805, /* GL_V3F */
+      1803, /* GL_V2F */
+      1804, /* GL_V3F */
        123, /* GL_C4UB_V2F */
        124, /* GL_C4UB_V3F */
        121, /* GL_C3F_V3F */
@@ -4281,11 +4279,11 @@ static const unsigned reduced_enums[1347] =
        951, /* GL_MINMAX_FORMAT */
        953, /* GL_MINMAX_SINK */
       1561, /* GL_TABLE_TOO_LARGE_EXT */
-      1782, /* GL_UNSIGNED_BYTE_3_3_2 */
-      1794, /* GL_UNSIGNED_SHORT_4_4_4_4 */
-      1796, /* GL_UNSIGNED_SHORT_5_5_5_1 */
-      1789, /* GL_UNSIGNED_INT_8_8_8_8 */
-      1784, /* GL_UNSIGNED_INT_10_10_10_2 */
+      1781, /* GL_UNSIGNED_BYTE_3_3_2 */
+      1793, /* GL_UNSIGNED_SHORT_4_4_4_4 */
+      1795, /* GL_UNSIGNED_SHORT_5_5_5_1 */
+      1788, /* GL_UNSIGNED_INT_8_8_8_8 */
+      1783, /* GL_UNSIGNED_INT_10_10_10_2 */
       1176, /* GL_POLYGON_OFFSET_FILL */
       1175, /* GL_POLYGON_OFFSET_FACTOR */
       1174, /* GL_POLYGON_OFFSET_BIAS */
@@ -4340,22 +4338,22 @@ static const unsigned reduced_enums[1347] =
       1639, /* GL_TEXTURE_BINDING_3D */
       1096, /* GL_PACK_SKIP_IMAGES */
       1092, /* GL_PACK_IMAGE_HEIGHT */
-      1775, /* GL_UNPACK_SKIP_IMAGES */
-      1772, /* GL_UNPACK_IMAGE_HEIGHT */
+      1774, /* GL_UNPACK_SKIP_IMAGES */
+      1771, /* GL_UNPACK_IMAGE_HEIGHT */
       1631, /* GL_TEXTURE_3D */
       1277, /* GL_PROXY_TEXTURE_3D */
       1694, /* GL_TEXTURE_DEPTH */
       1747, /* GL_TEXTURE_WRAP_R */
        856, /* GL_MAX_3D_TEXTURE_SIZE */
-      1809, /* GL_VERTEX_ARRAY */
+      1808, /* GL_VERTEX_ARRAY */
       1026, /* GL_NORMAL_ARRAY */
        148, /* GL_COLOR_ARRAY */
        631, /* GL_INDEX_ARRAY */
       1672, /* GL_TEXTURE_COORD_ARRAY */
        459, /* GL_EDGE_FLAG_ARRAY */
-      1815, /* GL_VERTEX_ARRAY_SIZE */
-      1817, /* GL_VERTEX_ARRAY_TYPE */
-      1816, /* GL_VERTEX_ARRAY_STRIDE */
+      1814, /* GL_VERTEX_ARRAY_SIZE */
+      1816, /* GL_VERTEX_ARRAY_TYPE */
+      1815, /* GL_VERTEX_ARRAY_STRIDE */
       1031, /* GL_NORMAL_ARRAY_TYPE */
       1030, /* GL_NORMAL_ARRAY_STRIDE */
        152, /* GL_COLOR_ARRAY_SIZE */
@@ -4367,7 +4365,7 @@ static const unsigned reduced_enums[1347] =
       1678, /* GL_TEXTURE_COORD_ARRAY_TYPE */
       1677, /* GL_TEXTURE_COORD_ARRAY_STRIDE */
        463, /* GL_EDGE_FLAG_ARRAY_STRIDE */
-      1814, /* GL_VERTEX_ARRAY_POINTER */
+      1813, /* GL_VERTEX_ARRAY_POINTER */
       1029, /* GL_NORMAL_ARRAY_POINTER */
        151, /* GL_COLOR_ARRAY_POINTER */
        634, /* GL_INDEX_ARRAY_POINTER */
@@ -4467,7 +4465,7 @@ static const unsigned reduced_enums[1347] =
        306, /* GL_CULL_VERTEX_EXT */
        308, /* GL_CULL_VERTEX_OBJECT_POSITION_EXT */
        307, /* GL_CULL_VERTEX_EYE_POSITION_EXT */
-      1872, /* GL_WRAP_BORDER_SUN */
+      1871, /* GL_WRAP_BORDER_SUN */
       1656, /* GL_TEXTURE_COLOR_WRITEMASK_SGIS */
        690, /* GL_LIGHT_MODEL_COLOR_CONTROL */
       1440, /* GL_SINGLE_COLOR */
@@ -4485,13 +4483,13 @@ static const unsigned reduced_enums[1347] =
        580, /* GL_FRAMEBUFFER_UNDEFINED */
        373, /* GL_DEPTH_STENCIL_ATTACHMENT */
        630, /* GL_INDEX */
-      1781, /* GL_UNSIGNED_BYTE_2_3_3_REV */
-      1797, /* GL_UNSIGNED_SHORT_5_6_5 */
-      1798, /* GL_UNSIGNED_SHORT_5_6_5_REV */
-      1795, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
-      1793, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
-      1790, /* GL_UNSIGNED_INT_8_8_8_8_REV */
-      1788, /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      1780, /* GL_UNSIGNED_BYTE_2_3_3_REV */
+      1796, /* GL_UNSIGNED_SHORT_5_6_5 */
+      1797, /* GL_UNSIGNED_SHORT_5_6_5_REV */
+      1794, /* GL_UNSIGNED_SHORT_4_4_4_4_REV */
+      1792, /* GL_UNSIGNED_SHORT_1_5_5_5_REV */
+      1789, /* GL_UNSIGNED_INT_8_8_8_8_REV */
+      1787, /* GL_UNSIGNED_INT_2_10_10_10_REV */
       1726, /* GL_TEXTURE_MAX_CLAMP_S_SGIX */
       1727, /* GL_TEXTURE_MAX_CLAMP_T_SGIX */
       1725, /* GL_TEXTURE_MAX_CLAMP_R_SGIX */
@@ -4562,10 +4560,10 @@ static const unsigned reduced_enums[1347] =
         18, /* GL_ACTIVE_TEXTURE */
        133, /* GL_CLIENT_ACTIVE_TEXTURE */
        934, /* GL_MAX_TEXTURE_UNITS */
-      1759, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
-      1762, /* GL_TRANSPOSE_PROJECTION_MATRIX */
-      1764, /* GL_TRANSPOSE_TEXTURE_MATRIX */
-      1756, /* GL_TRANSPOSE_COLOR_MATRIX */
+      1758, /* GL_TRANSPOSE_MODELVIEW_MATRIX */
+      1761, /* GL_TRANSPOSE_PROJECTION_MATRIX */
+      1763, /* GL_TRANSPOSE_TEXTURE_MATRIX */
+      1755, /* GL_TRANSPOSE_COLOR_MATRIX */
       1545, /* GL_SUBTRACT */
        919, /* GL_MAX_RENDERBUFFER_SIZE */
        247, /* GL_COMPRESSED_ALPHA */
@@ -4580,7 +4578,7 @@ static const unsigned reduced_enums[1347] =
       1281, /* GL_PROXY_TEXTURE_RECTANGLE_ARB */
        917, /* GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB */
        372, /* GL_DEPTH_STENCIL */
-      1785, /* GL_UNSIGNED_INT_24_8 */
+      1784, /* GL_UNSIGNED_INT_24_8 */
        930, /* GL_MAX_TEXTURE_LOD_BIAS */
       1724, /* GL_TEXTURE_MAX_ANISOTROPY_EXT */
        931, /* GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT */
@@ -4633,32 +4631,32 @@ static const unsigned reduced_enums[1347] =
       1072, /* GL_OPERAND1_ALPHA */
       1078, /* GL_OPERAND2_ALPHA */
       1084, /* GL_OPERAND3_ALPHA_NV */
-      1810, /* GL_VERTEX_ARRAY_BINDING */
+      1809, /* GL_VERTEX_ARRAY_BINDING */
       1733, /* GL_TEXTURE_RANGE_LENGTH_APPLE */
       1734, /* GL_TEXTURE_RANGE_POINTER_APPLE */
-      1876, /* GL_YCBCR_422_APPLE */
-      1799, /* GL_UNSIGNED_SHORT_8_8_APPLE */
-      1801, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
+      1875, /* GL_YCBCR_422_APPLE */
+      1798, /* GL_UNSIGNED_SHORT_8_8_APPLE */
+      1800, /* GL_UNSIGNED_SHORT_8_8_REV_APPLE */
       1743, /* GL_TEXTURE_STORAGE_HINT_APPLE */
       1536, /* GL_STORAGE_PRIVATE_APPLE */
       1535, /* GL_STORAGE_CACHED_APPLE */
       1537, /* GL_STORAGE_SHARED_APPLE */
       1442, /* GL_SLICE_ACCUM_SUN */
       1288, /* GL_QUAD_MESH_SUN */
-      1768, /* GL_TRIANGLE_MESH_SUN */
-      1849, /* GL_VERTEX_PROGRAM_ARB */
-      1860, /* GL_VERTEX_STATE_PROGRAM_NV */
-      1836, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
-      1842, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
-      1844, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
-      1846, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
+      1767, /* GL_TRIANGLE_MESH_SUN */
+      1848, /* GL_VERTEX_PROGRAM_ARB */
+      1859, /* GL_VERTEX_STATE_PROGRAM_NV */
+      1835, /* GL_VERTEX_ATTRIB_ARRAY_ENABLED */
+      1841, /* GL_VERTEX_ATTRIB_ARRAY_SIZE */
+      1843, /* GL_VERTEX_ATTRIB_ARRAY_STRIDE */
+      1845, /* GL_VERTEX_ATTRIB_ARRAY_TYPE */
        334, /* GL_CURRENT_VERTEX_ATTRIB */
       1240, /* GL_PROGRAM_LENGTH_ARB */
       1254, /* GL_PROGRAM_STRING_ARB */
        998, /* GL_MODELVIEW_PROJECTION_NV */
        623, /* GL_IDENTITY_NV */
        670, /* GL_INVERSE_NV */
-      1761, /* GL_TRANSPOSE_NV */
+      1760, /* GL_TRANSPOSE_NV */
        671, /* GL_INVERSE_TRANSPOSE_NV */
        903, /* GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB */
        902, /* GL_MAX_PROGRAM_MATRICES_ARB */
@@ -4672,33 +4670,33 @@ static const unsigned reduced_enums[1347] =
        845, /* GL_MATRIX7_NV */
        318, /* GL_CURRENT_MATRIX_STACK_DEPTH_ARB */
        315, /* GL_CURRENT_MATRIX_ARB */
-      1852, /* GL_VERTEX_PROGRAM_POINT_SIZE */
-      1855, /* GL_VERTEX_PROGRAM_TWO_SIDE */
+      1851, /* GL_VERTEX_PROGRAM_POINT_SIZE */
+      1854, /* GL_VERTEX_PROGRAM_TWO_SIDE */
       1252, /* GL_PROGRAM_PARAMETER_NV */
-      1840, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
+      1839, /* GL_VERTEX_ATTRIB_ARRAY_POINTER */
       1256, /* GL_PROGRAM_TARGET_NV */
       1253, /* GL_PROGRAM_RESIDENT_NV */
-      1753, /* GL_TRACK_MATRIX_NV */
-      1754, /* GL_TRACK_MATRIX_TRANSFORM_NV */
-      1850, /* GL_VERTEX_PROGRAM_BINDING_NV */
+      1752, /* GL_TRACK_MATRIX_NV */
+      1753, /* GL_TRACK_MATRIX_TRANSFORM_NV */
+      1849, /* GL_VERTEX_PROGRAM_BINDING_NV */
       1234, /* GL_PROGRAM_ERROR_POSITION_ARB */
        356, /* GL_DEPTH_CLAMP */
-      1818, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
-      1825, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
-      1826, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
-      1827, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
-      1828, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
-      1829, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
-      1830, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
-      1831, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
-      1832, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
-      1833, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
-      1819, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
-      1820, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
-      1821, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
-      1822, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
-      1823, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
-      1824, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
+      1817, /* GL_VERTEX_ATTRIB_ARRAY0_NV */
+      1824, /* GL_VERTEX_ATTRIB_ARRAY1_NV */
+      1825, /* GL_VERTEX_ATTRIB_ARRAY2_NV */
+      1826, /* GL_VERTEX_ATTRIB_ARRAY3_NV */
+      1827, /* GL_VERTEX_ATTRIB_ARRAY4_NV */
+      1828, /* GL_VERTEX_ATTRIB_ARRAY5_NV */
+      1829, /* GL_VERTEX_ATTRIB_ARRAY6_NV */
+      1830, /* GL_VERTEX_ATTRIB_ARRAY7_NV */
+      1831, /* GL_VERTEX_ATTRIB_ARRAY8_NV */
+      1832, /* GL_VERTEX_ATTRIB_ARRAY9_NV */
+      1818, /* GL_VERTEX_ATTRIB_ARRAY10_NV */
+      1819, /* GL_VERTEX_ATTRIB_ARRAY11_NV */
+      1820, /* GL_VERTEX_ATTRIB_ARRAY12_NV */
+      1821, /* GL_VERTEX_ATTRIB_ARRAY13_NV */
+      1822, /* GL_VERTEX_ATTRIB_ARRAY14_NV */
+      1823, /* GL_VERTEX_ATTRIB_ARRAY15_NV */
        757, /* GL_MAP1_VERTEX_ATTRIB0_4_NV */
        764, /* GL_MAP1_VERTEX_ATTRIB1_4_NV */
        765, /* GL_MAP1_VERTEX_ATTRIB2_4_NV */
@@ -4737,14 +4735,14 @@ static const unsigned reduced_enums[1347] =
        269, /* GL_COMPRESSED_TEXTURE_FORMATS */
        946, /* GL_MAX_VERTEX_UNITS_ARB */
         22, /* GL_ACTIVE_VERTEX_UNITS_ARB */
-      1871, /* GL_WEIGHT_SUM_UNITY_ARB */
-      1848, /* GL_VERTEX_BLEND_ARB */
+      1870, /* GL_WEIGHT_SUM_UNITY_ARB */
+      1847, /* GL_VERTEX_BLEND_ARB */
        336, /* GL_CURRENT_WEIGHT_ARB */
-      1870, /* GL_WEIGHT_ARRAY_TYPE_ARB */
-      1869, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
-      1868, /* GL_WEIGHT_ARRAY_SIZE_ARB */
-      1867, /* GL_WEIGHT_ARRAY_POINTER_ARB */
-      1864, /* GL_WEIGHT_ARRAY_ARB */
+      1869, /* GL_WEIGHT_ARRAY_TYPE_ARB */
+      1868, /* GL_WEIGHT_ARRAY_STRIDE_ARB */
+      1867, /* GL_WEIGHT_ARRAY_SIZE_ARB */
+      1866, /* GL_WEIGHT_ARRAY_POINTER_ARB */
+      1863, /* GL_WEIGHT_ARRAY_ARB */
        386, /* GL_DOT3_RGB */
        387, /* GL_DOT3_RGBA */
        263, /* GL_COMPRESSED_RGB_FXT1_3DFX */
@@ -4789,7 +4787,7 @@ static const unsigned reduced_enums[1347] =
       1001, /* GL_MODULATE_ADD_ATI */
       1002, /* GL_MODULATE_SIGNED_ADD_ATI */
       1003, /* GL_MODULATE_SUBTRACT_ATI */
-      1877, /* GL_YCBCR_MESA */
+      1876, /* GL_YCBCR_MESA */
       1093, /* GL_PACK_INVERT_MESA */
        339, /* GL_DEBUG_OBJECT_MESA */
        340, /* GL_DEBUG_PRINT_MESA */
@@ -4862,7 +4860,7 @@ static const unsigned reduced_enums[1347] =
       1292, /* GL_QUERY_RESULT */
       1294, /* GL_QUERY_RESULT_AVAILABLE */
        940, /* GL_MAX_VERTEX_ATTRIBS */
-      1838, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
+      1837, /* GL_VERTEX_ATTRIB_ARRAY_NORMALIZED */
        377, /* GL_DEPTH_STENCIL_TO_RGBA_NV */
        376, /* GL_DEPTH_STENCIL_TO_BGRA_NV */
        926, /* GL_MAX_TEXTURE_COORDS */
@@ -4877,7 +4875,7 @@ static const unsigned reduced_enums[1347] =
        464, /* GL_ELEMENT_ARRAY_BUFFER */
         54, /* GL_ARRAY_BUFFER_BINDING */
        465, /* GL_ELEMENT_ARRAY_BUFFER_BINDING */
-      1812, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
+      1811, /* GL_VERTEX_ARRAY_BUFFER_BINDING */
       1027, /* GL_NORMAL_ARRAY_BUFFER_BINDING */
        149, /* GL_COLOR_ARRAY_BUFFER_BINDING */
        632, /* GL_INDEX_ARRAY_BUFFER_BINDING */
@@ -4885,8 +4883,8 @@ static const unsigned reduced_enums[1347] =
        460, /* GL_EDGE_FLAG_ARRAY_BUFFER_BINDING */
       1416, /* GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING */
        514, /* GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING */
-      1865, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
-      1834, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
+      1864, /* GL_WEIGHT_ARRAY_BUFFER_BINDING */
+      1833, /* GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING */
       1239, /* GL_PROGRAM_INSTRUCTIONS_ARB */
        898, /* GL_MAX_PROGRAM_INSTRUCTIONS_ARB */
       1245, /* GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB */
@@ -4910,14 +4908,14 @@ static const unsigned reduced_enums[1347] =
        899, /* GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB */
        895, /* GL_MAX_PROGRAM_ENV_PARAMETERS_ARB */
       1260, /* GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB */
-      1758, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
+      1757, /* GL_TRANSPOSE_CURRENT_MATRIX_ARB */
       1304, /* GL_READ_ONLY */
-      1873, /* GL_WRITE_ONLY */
+      1872, /* GL_WRITE_ONLY */
       1306, /* GL_READ_WRITE */
        102, /* GL_BUFFER_ACCESS */
        105, /* GL_BUFFER_MAPPED */
        107, /* GL_BUFFER_MAP_POINTER */
-      1752, /* GL_TIME_ELAPSED_EXT */
+      1751, /* GL_TIME_ELAPSED_EXT */
        808, /* GL_MATRIX0_ARB */
        820, /* GL_MATRIX1_ARB */
        832, /* GL_MATRIX2_ARB */
@@ -4978,7 +4976,7 @@ static const unsigned reduced_enums[1347] =
        109, /* GL_BUFFER_SERIALIZED_MODIFY_APPLE */
        104, /* GL_BUFFER_FLUSHING_UNMAP_APPLE */
        537, /* GL_FRAGMENT_SHADER */
-      1858, /* GL_VERTEX_SHADER */
+      1857, /* GL_VERTEX_SHADER */
       1250, /* GL_PROGRAM_OBJECT_ARB */
       1429, /* GL_SHADER_OBJECT_ARB */
        882, /* GL_MAX_FRAGMENT_UNIFORM_COMPONENTS */
@@ -5016,7 +5014,7 @@ static const unsigned reduced_enums[1347] =
        345, /* GL_DELETE_STATUS */
        246, /* GL_COMPILE_STATUS */
        715, /* GL_LINK_STATUS */
-      1806, /* GL_VALIDATE_STATUS */
+      1805, /* GL_VALIDATE_STATUS */
        644, /* GL_INFO_LOG_LENGTH */
         56, /* GL_ATTACHED_SHADERS */
         20, /* GL_ACTIVE_UNIFORMS */
@@ -5039,7 +5037,7 @@ static const unsigned reduced_enums[1347] =
       1106, /* GL_PALETTE8_RGB5_A1_OES */
        626, /* GL_IMPLEMENTATION_COLOR_READ_TYPE_OES */
        625, /* GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES */
-      1791, /* GL_UNSIGNED_NORMALIZED */
+      1790, /* GL_UNSIGNED_NORMALIZED */
       1628, /* GL_TEXTURE_1D_ARRAY_EXT */
       1272, /* GL_PROXY_TEXTURE_1D_ARRAY_EXT */
       1630, /* GL_TEXTURE_2D_ARRAY_EXT */
@@ -5060,7 +5058,7 @@ static const unsigned reduced_enums[1347] =
        266, /* GL_COMPRESSED_SLUMINANCE_ALPHA */
       1167, /* GL_POINT_SPRITE_COORD_ORIGIN */
        723, /* GL_LOWER_LEFT */
-      1803, /* GL_UPPER_LEFT */
+      1802, /* GL_UPPER_LEFT */
       1509, /* GL_STENCIL_BACK_REF */
       1510, /* GL_STENCIL_BACK_VALUE_MASK */
       1511, /* GL_STENCIL_BACK_WRITEMASK */
@@ -5138,12 +5136,12 @@ static const unsigned reduced_enums[1347] =
       1549, /* GL_SYNC_FLAGS */
       1548, /* GL_SYNC_FENCE */
       1551, /* GL_SYNC_GPU_COMMANDS_COMPLETE */
-      1779, /* GL_UNSIGNALED */
+      1778, /* GL_UNSIGNALED */
       1438, /* GL_SIGNALED */
         46, /* GL_ALREADY_SIGNALED */
       1750, /* GL_TIMEOUT_EXPIRED */
        270, /* GL_CONDITION_SATISFIED */
-      1863, /* GL_WAIT_FAILED */
+      1862, /* GL_WAIT_FAILED */
        471, /* GL_EVAL_BIT */
       1298, /* GL_RASTER_POSITION_UNCLIPPED_IBM */
        717, /* GL_LIST_BIT */
@@ -5152,7 +5150,6 @@ static const unsigned reduced_enums[1347] =
         29, /* GL_ALL_ATTRIB_BITS */
       1008, /* GL_MULTISAMPLE_BIT */
         30, /* GL_ALL_CLIENT_ATTRIB_BITS */
-      1751, /* GL_TIMEOUT_IGNORED */
 };
 
 typedef int (*cfunc)(const void *, const void *);
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 7b3599f..0e83a4e 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -40,13 +40,10 @@
 #include "framebuffer.h"
 #include "hash.h"
 #include "macros.h"
-#include "mipmap.h"
 #include "renderbuffer.h"
 #include "state.h"
 #include "teximage.h"
 #include "texobj.h"
-#include "texstore.h"
-#include "texstate.h"
 
 
 /** Set this to 1 to help debug FBO incompleteness problems */
@@ -1353,15 +1350,26 @@ _mesa_DeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
             ASSERT(fb == &DummyFramebuffer || fb->Name == framebuffers[i]);
 
             /* check if deleting currently bound framebuffer object */
-            if (fb == ctx->DrawBuffer) {
-               /* bind default */
-               ASSERT(fb->RefCount >= 2);
-               _mesa_BindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);
+            if (ctx->Extensions.EXT_framebuffer_blit) {
+               /* separate draw/read binding points */
+               if (fb == ctx->DrawBuffer) {
+                  /* bind default */
+                  ASSERT(fb->RefCount >= 2);
+                  _mesa_BindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);
+               }
+               if (fb == ctx->ReadBuffer) {
+                  /* bind default */
+                  ASSERT(fb->RefCount >= 2);
+                  _mesa_BindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, 0);
+               }
             }
-            if (fb == ctx->ReadBuffer) {
-               /* bind default */
-               ASSERT(fb->RefCount >= 2);
-               _mesa_BindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, 0);
+            else {
+               /* only one binding point for read/draw buffers */
+               if (fb == ctx->DrawBuffer || fb == ctx->ReadBuffer) {
+                  /* bind default */
+                  ASSERT(fb->RefCount >= 2);
+                  _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+               }    
             }
 
 	    /* remove from hash table immediately, to free the ID */
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index 329b795..d0c9c00 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -27,7 +27,6 @@
 #include "imports.h"
 #include "formats.h"
 #include "config.h"
-#include "texstore.h"
 
 
 /**
@@ -910,6 +909,7 @@ _mesa_test_formats(void)
             GLuint t = info->RedBits + info->GreenBits
                + info->BlueBits + info->AlphaBits;
             assert(t / 8 == info->BytesPerBlock);
+            (void) t;
          }
       }
 
diff --git a/src/mesa/main/image.c b/src/mesa/main/image.c
index 139e56a..1dfcc48 100644
--- a/src/mesa/main/image.c
+++ b/src/mesa/main/image.c
@@ -36,7 +36,6 @@
 #include "image.h"
 #include "imports.h"
 #include "macros.h"
-#include "pixel.h"
 
 
 /**
@@ -3228,6 +3227,7 @@ extract_float_rgba(GLuint n, GLfloat rgba[][4],
           srcFormat == GL_RGBA ||
           srcFormat == GL_BGRA ||
           srcFormat == GL_ABGR_EXT ||
+          srcFormat == GL_DU8DV8_ATI ||
           srcFormat == GL_DUDV_ATI);
 
    ASSERT(srcType == GL_UNSIGNED_BYTE ||
@@ -3343,6 +3343,7 @@ extract_float_rgba(GLuint n, GLfloat rgba[][4],
          aComp = 0;
          stride = 4;
          break;
+      case GL_DU8DV8_ATI:
       case GL_DUDV_ATI:
          redIndex = 0;
          greenIndex = 1;
diff --git a/src/mesa/main/lines.c b/src/mesa/main/lines.c
index 81d0d33..cc63a75 100644
--- a/src/mesa/main/lines.c
+++ b/src/mesa/main/lines.c
@@ -25,10 +25,8 @@
 
 #include "glheader.h"
 #include "context.h"
-#include "depth.h"
 #include "lines.h"
 #include "macros.h"
-#include "texstate.h"
 #include "mtypes.h"
 
 
diff --git a/src/mesa/main/mipmap.c b/src/mesa/main/mipmap.c
index 7350c7a..77cd1d4 100644
--- a/src/mesa/main/mipmap.c
+++ b/src/mesa/main/mipmap.c
@@ -30,7 +30,6 @@
 #include "imports.h"
 #include "formats.h"
 #include "mipmap.h"
-#include "texcompress.h"
 #include "teximage.h"
 #include "texstore.h"
 #include "image.h"
diff --git a/src/mesa/main/pixel.c b/src/mesa/main/pixel.c
index 3820ebd..f6f9c11 100644
--- a/src/mesa/main/pixel.c
+++ b/src/mesa/main/pixel.c
@@ -32,7 +32,6 @@
 #include "bufferobj.h"
 #include "colormac.h"
 #include "context.h"
-#include "image.h"
 #include "macros.h"
 #include "pixel.h"
 #include "mtypes.h"
diff --git a/src/mesa/main/pixelstore.c b/src/mesa/main/pixelstore.c
index 6a641f8..ec585ef 100644
--- a/src/mesa/main/pixelstore.c
+++ b/src/mesa/main/pixelstore.c
@@ -30,10 +30,7 @@
 
 #include "glheader.h"
 #include "bufferobj.h"
-#include "colormac.h"
 #include "context.h"
-#include "image.h"
-#include "macros.h"
 #include "pixelstore.h"
 #include "mtypes.h"
 
diff --git a/src/mesa/main/points.c b/src/mesa/main/points.c
index dcaeccd..e743a2e 100644
--- a/src/mesa/main/points.c
+++ b/src/mesa/main/points.c
@@ -32,7 +32,6 @@
 #include "context.h"
 #include "macros.h"
 #include "points.h"
-#include "texstate.h"
 #include "mtypes.h"
 
 
diff --git a/src/mesa/main/polygon.c b/src/mesa/main/polygon.c
index 376a87a..dcde675 100644
--- a/src/mesa/main/polygon.c
+++ b/src/mesa/main/polygon.c
@@ -34,7 +34,6 @@
 #include "context.h"
 #include "image.h"
 #include "enums.h"
-#include "macros.h"
 #include "polygon.h"
 #include "mtypes.h"
 
diff --git a/src/mesa/main/scissor.c b/src/mesa/main/scissor.c
index b5f4cde..523f3c3 100644
--- a/src/mesa/main/scissor.c
+++ b/src/mesa/main/scissor.c
@@ -37,14 +37,14 @@ _mesa_Scissor( GLint x, GLint y, GLsizei width, GLsizei height )
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
 
+   if (MESA_VERBOSE & VERBOSE_API)
+      _mesa_debug(ctx, "glScissor %d %d %d %d\n", x, y, width, height);
+
    if (width < 0 || height < 0) {
       _mesa_error( ctx, GL_INVALID_VALUE, "glScissor" );
       return;
    }
 
-   if (MESA_VERBOSE & VERBOSE_API)
-      _mesa_debug(ctx, "glScissor %d %d %d %d\n", x, y, width, height);
-
    _mesa_set_scissor(ctx, x, y, width, height);
 }
 
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index f10e6b0..5e07d1d 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -48,7 +48,6 @@
 #include "texenvprogram.h"
 #include "texobj.h"
 #include "texstate.h"
-#include "viewport.h"
 
 
 static void
@@ -83,12 +82,6 @@ compute_max_element(struct gl_client_array *array)
       } else {
 	 array->_MaxElement = 0;
       }
-      /* Compute the max element we can access in the VBO without going
-       * out of bounds.
-       */
-      array->_MaxElement = ((GLsizeiptrARB) array->BufferObj->Size
-                            - (GLsizeiptrARB) array->Ptr + array->StrideB
-                            - array->_ElementSize) / array->StrideB;
    }
    else {
       /* user-space array, no idea how big it is */
diff --git a/src/mesa/main/texcompress.c b/src/mesa/main/texcompress.c
index a4f1926..cff6de8 100644
--- a/src/mesa/main/texcompress.c
+++ b/src/mesa/main/texcompress.c
@@ -35,10 +35,7 @@
 #include "colormac.h"
 #include "context.h"
 #include "formats.h"
-#include "image.h"
-#include "mipmap.h"
 #include "texcompress.h"
-#include "texstore.h"
 
 
 /**
diff --git a/src/mesa/main/texformat.c b/src/mesa/main/texformat.c
index 1a374e7..096945a 100644
--- a/src/mesa/main/texformat.c
+++ b/src/mesa/main/texformat.c
@@ -35,8 +35,6 @@
 
 #include "context.h"
 #include "texcompress.h"
-#include "texcompress_fxt1.h"
-#include "texcompress_s3tc.h"
 #include "texformat.h"
 
 
diff --git a/src/mesa/main/texgetimage.c b/src/mesa/main/texgetimage.c
index 23765d2..0cc6a56 100644
--- a/src/mesa/main/texgetimage.c
+++ b/src/mesa/main/texgetimage.c
@@ -35,10 +35,8 @@
 #include "context.h"
 #include "formats.h"
 #include "image.h"
-#include "texcompress.h"
 #include "texgetimage.h"
 #include "teximage.h"
-#include "texstate.h"
 
 
 
@@ -103,7 +101,7 @@ get_tex_color_index(GLcontext *ctx, GLuint dimensions,
 
    for (img = 0; img < depth; img++) {
       for (row = 0; row < height; row++) {
-         GLuint indexRow[MAX_WIDTH];
+         GLuint indexRow[MAX_WIDTH] = { 0 };
          void *dest = _mesa_image_address(dimensions, &ctx->Pack, pixels,
                                           width, height, format, type,
                                           img, row, 0);
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index b946f3c..76273b0 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -46,7 +46,6 @@
 #include "texfetch.h"
 #include "teximage.h"
 #include "texstate.h"
-#include "texstore.h"
 #include "mtypes.h"
 
 
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index 237b6eb..7f62557 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -38,7 +38,6 @@
 #include "imports.h"
 #include "macros.h"
 #include "teximage.h"
-#include "texstate.h"
 #include "texobj.h"
 #include "mtypes.h"
 #include "shader/prog_instruction.h"
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index db4c7a5..93c5d6c 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -33,7 +33,6 @@
 #include "main/glheader.h"
 #include "main/colormac.h"
 #include "main/context.h"
-#include "main/enums.h"
 #include "main/formats.h"
 #include "main/macros.h"
 #include "main/texcompress.h"
@@ -1165,6 +1164,7 @@ _mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
       return;
    }
 
+   _mesa_lock_texture(ctx, obj);
    switch (pname) {
       case GL_TEXTURE_MAG_FILTER:
          *params = (GLint) obj->MagFilter;
diff --git a/src/mesa/main/texstate.c b/src/mesa/main/texstate.c
index c735e18..25333d8 100644
--- a/src/mesa/main/texstate.c
+++ b/src/mesa/main/texstate.c
@@ -35,11 +35,9 @@
 #include "context.h"
 #include "enums.h"
 #include "macros.h"
-#include "texcompress.h"
 #include "texobj.h"
 #include "teximage.h"
 #include "texstate.h"
-#include "texenvprogram.h"
 #include "mtypes.h"
 
 
diff --git a/src/mesa/main/texstore.c b/src/mesa/main/texstore.c
index 792c831..fcd0a56 100644
--- a/src/mesa/main/texstore.c
+++ b/src/mesa/main/texstore.c
@@ -263,7 +263,7 @@ compute_component_mapping(GLenum inFormat, GLenum outFormat,
    map[ZERO] = ZERO;
    map[ONE] = ONE;   
 
-/*
+#if 0
    _mesa_printf("from %x/%s to %x/%s map %d %d %d %d %d %d\n",
 		inFormat, _mesa_lookup_enum_by_nr(inFormat),
 		outFormat, _mesa_lookup_enum_by_nr(outFormat),
@@ -273,7 +273,7 @@ compute_component_mapping(GLenum inFormat, GLenum outFormat,
 		map[3], 
 		map[4], 
 		map[5]); 
-*/
+#endif
 }
 
 
diff --git a/src/mesa/main/version.h b/src/mesa/main/version.h
index 9c758ce..1c5749f 100644
--- a/src/mesa/main/version.h
+++ b/src/mesa/main/version.h
@@ -1,9 +1,9 @@
 /*
  * Mesa 3-D graphics library
- * Version:  7.7
+ * Version:  7.7.1
  *
  * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
- * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
+ * Copyright (C) 2009-2010  VMware, Inc.  All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -31,8 +31,8 @@
 /* Mesa version */
 #define MESA_MAJOR 7
 #define MESA_MINOR 7
-#define MESA_PATCH 0
-#define MESA_VERSION_STRING "7.7"
+#define MESA_PATCH 1
+#define MESA_VERSION_STRING "7.7.1-DEVEL"
 
 /* To make version comparison easy */
 #define MESA_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff --git a/src/mesa/main/vtxfmt.c b/src/mesa/main/vtxfmt.c
index c9eea8a..0dd3e5e 100644
--- a/src/mesa/main/vtxfmt.c
+++ b/src/mesa/main/vtxfmt.c
@@ -28,11 +28,9 @@
 
 #include "glheader.h"
 #include "api_arrayelt.h"
-#include "api_loopback.h"
 #include "context.h"
 #include "imports.h"
 #include "mtypes.h"
-#include "state.h"
 #include "vtxfmt.h"
 #include "eval.h"
 #include "dlist.h"
diff --git a/src/mesa/shader/arbprogparse.c b/src/mesa/shader/arbprogparse.c
index dd732b6..a33f510 100644
--- a/src/mesa/shader/arbprogparse.c
+++ b/src/mesa/shader/arbprogparse.c
@@ -54,11 +54,8 @@ having three separate program parameter arrays.
 #include "main/glheader.h"
 #include "main/imports.h"
 #include "main/context.h"
-#include "main/macros.h"
 #include "main/mtypes.h"
-#include "shader/grammar/grammar_mesa.h"
 #include "arbprogparse.h"
-#include "program.h"
 #include "programopt.h"
 #include "prog_parameter.h"
 #include "prog_statevars.h"
diff --git a/src/mesa/shader/arbprogram.c b/src/mesa/shader/arbprogram.c
index eb537cd..3cb2610 100644
--- a/src/mesa/shader/arbprogram.c
+++ b/src/mesa/shader/arbprogram.c
@@ -561,6 +561,8 @@ _mesa_ProgramEnvParameter4fARB(GLenum target, GLuint index,
    }
 }
 
+
+
 /**
  * Set a program env parameter register.
  * \note Called from the GL API dispatcher.
@@ -569,10 +571,35 @@ _mesa_ProgramEnvParameter4fARB(GLenum target, GLuint index,
  */
 void GLAPIENTRY
 _mesa_ProgramEnvParameter4fvARB(GLenum target, GLuint index,
-                                   const GLfloat *params)
+                                const GLfloat *params)
 {
-   _mesa_ProgramEnvParameter4fARB(target, index, params[0], params[1],
-                                  params[2], params[3]);
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   FLUSH_VERTICES(ctx, _NEW_PROGRAM_CONSTANTS);
+
+   if (target == GL_FRAGMENT_PROGRAM_ARB
+       && ctx->Extensions.ARB_fragment_program) {
+      if (index >= ctx->Const.FragmentProgram.MaxEnvParams) {
+         _mesa_error(ctx, GL_INVALID_VALUE, "glProgramEnvParameter4fv(index)");
+         return;
+      }
+      memcpy(ctx->FragmentProgram.Parameters[index], params,
+             4 * sizeof(GLfloat));
+   }
+   else if (target == GL_VERTEX_PROGRAM_ARB /* == GL_VERTEX_PROGRAM_NV */
+       && (ctx->Extensions.ARB_vertex_program || ctx->Extensions.NV_vertex_program)) {
+      if (index >= ctx->Const.VertexProgram.MaxEnvParams) {
+         _mesa_error(ctx, GL_INVALID_VALUE, "glProgramEnvParameter4fv(index)");
+         return;
+      }
+      memcpy(ctx->VertexProgram.Parameters[index], params,
+             4 * sizeof(GLfloat));
+   }
+   else {
+      _mesa_error(ctx, GL_INVALID_ENUM, "glProgramEnvParameter4fv(target)");
+      return;
+   }
 }
 
 
diff --git a/src/mesa/shader/nvfragparse.c b/src/mesa/shader/nvfragparse.c
index b739a6a..8ee7c93 100644
--- a/src/mesa/shader/nvfragparse.c
+++ b/src/mesa/shader/nvfragparse.c
@@ -642,7 +642,7 @@ Parse_SwizzleSuffix(const GLubyte *token, GLuint swizzle[4])
    else {
       /* 4-component swizzle (vector) */
       GLint k;
-      for (k = 0; token[k] && k < 4; k++) {
+      for (k = 0; k < 4 && token[k]; k++) {
          if (token[k] == 'x')
             swizzle[k] = 0;
          else if (token[k] == 'y')
diff --git a/src/mesa/shader/nvvertparse.c b/src/mesa/shader/nvvertparse.c
index 8574016..baff765 100644
--- a/src/mesa/shader/nvvertparse.c
+++ b/src/mesa/shader/nvvertparse.c
@@ -40,7 +40,6 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/imports.h"
-#include "main/macros.h"
 #include "nvprogram.h"
 #include "nvvertparse.h"
 #include "prog_instruction.h"
diff --git a/src/mesa/shader/prog_execute.c b/src/mesa/shader/prog_execute.c
index 192d39a..fb29768 100644
--- a/src/mesa/shader/prog_execute.c
+++ b/src/mesa/shader/prog_execute.c
@@ -38,7 +38,6 @@
 #include "main/glheader.h"
 #include "main/colormac.h"
 #include "main/context.h"
-#include "program.h"
 #include "prog_execute.h"
 #include "prog_instruction.h"
 #include "prog_parameter.h"
@@ -342,6 +341,28 @@ fetch_vector1(const struct prog_src_register *source,
 }
 
 
+static GLuint
+fetch_vector1ui(const struct prog_src_register *source,
+                const struct gl_program_machine *machine)
+{
+   const GLuint *src = (GLuint *) get_src_register_pointer(source, machine);
+   GLuint result;
+
+   ASSERT(src);
+
+   result = src[GET_SWZ(source->Swizzle, 0)];
+
+   if (source->Abs) {
+      result = FABSF(result);
+   }
+   if (source->Negate) {
+      result = -result;
+   }
+
+   return result;
+}
+
+
 /**
  * Fetch texel from texture.  Use partial derivatives when possible.
  */
@@ -1634,12 +1655,11 @@ _mesa_execute_program(GLcontext * ctx,
          break;
       case OPCODE_UP2H:        /* unpack two 16-bit floats */
          {
-            GLfloat a[4], result[4];
-            const GLuint *rawBits = (const GLuint *) a;
+            const GLuint raw = fetch_vector1ui(&inst->SrcReg[0], machine);
+            GLfloat result[4];
             GLhalfNV hx, hy;
-            fetch_vector1(&inst->SrcReg[0], machine, a);
-            hx = rawBits[0] & 0xffff;
-            hy = rawBits[0] >> 16;
+            hx = raw & 0xffff;
+            hy = raw >> 16;
             result[0] = result[2] = _mesa_half_to_float(hx);
             result[1] = result[3] = _mesa_half_to_float(hy);
             store_vector4(inst, machine, result);
@@ -1647,12 +1667,11 @@ _mesa_execute_program(GLcontext * ctx,
          break;
       case OPCODE_UP2US:       /* unpack two GLushorts */
          {
-            GLfloat a[4], result[4];
-            const GLuint *rawBits = (const GLuint *) a;
+            const GLuint raw = fetch_vector1ui(&inst->SrcReg[0], machine);
+            GLfloat result[4];
             GLushort usx, usy;
-            fetch_vector1(&inst->SrcReg[0], machine, a);
-            usx = rawBits[0] & 0xffff;
-            usy = rawBits[0] >> 16;
+            usx = raw & 0xffff;
+            usy = raw >> 16;
             result[0] = result[2] = usx * (1.0f / 65535.0f);
             result[1] = result[3] = usy * (1.0f / 65535.0f);
             store_vector4(inst, machine, result);
@@ -1660,25 +1679,23 @@ _mesa_execute_program(GLcontext * ctx,
          break;
       case OPCODE_UP4B:        /* unpack four GLbytes */
          {
-            GLfloat a[4], result[4];
-            const GLuint *rawBits = (const GLuint *) a;
-            fetch_vector1(&inst->SrcReg[0], machine, a);
-            result[0] = (((rawBits[0] >> 0) & 0xff) - 128) / 127.0F;
-            result[1] = (((rawBits[0] >> 8) & 0xff) - 128) / 127.0F;
-            result[2] = (((rawBits[0] >> 16) & 0xff) - 128) / 127.0F;
-            result[3] = (((rawBits[0] >> 24) & 0xff) - 128) / 127.0F;
+            const GLuint raw = fetch_vector1ui(&inst->SrcReg[0], machine);
+            GLfloat result[4];
+            result[0] = (((raw >> 0) & 0xff) - 128) / 127.0F;
+            result[1] = (((raw >> 8) & 0xff) - 128) / 127.0F;
+            result[2] = (((raw >> 16) & 0xff) - 128) / 127.0F;
+            result[3] = (((raw >> 24) & 0xff) - 128) / 127.0F;
             store_vector4(inst, machine, result);
          }
          break;
       case OPCODE_UP4UB:       /* unpack four GLubytes */
          {
-            GLfloat a[4], result[4];
-            const GLuint *rawBits = (const GLuint *) a;
-            fetch_vector1(&inst->SrcReg[0], machine, a);
-            result[0] = ((rawBits[0] >> 0) & 0xff) / 255.0F;
-            result[1] = ((rawBits[0] >> 8) & 0xff) / 255.0F;
-            result[2] = ((rawBits[0] >> 16) & 0xff) / 255.0F;
-            result[3] = ((rawBits[0] >> 24) & 0xff) / 255.0F;
+            const GLuint raw = fetch_vector1ui(&inst->SrcReg[0], machine);
+            GLfloat result[4];
+            result[0] = ((raw >> 0) & 0xff) / 255.0F;
+            result[1] = ((raw >> 8) & 0xff) / 255.0F;
+            result[2] = ((raw >> 16) & 0xff) / 255.0F;
+            result[3] = ((raw >> 24) & 0xff) / 255.0F;
             store_vector4(inst, machine, result);
          }
          break;
diff --git a/src/mesa/shader/prog_optimize.c b/src/mesa/shader/prog_optimize.c
index 4fe3512..8b9466a 100644
--- a/src/mesa/shader/prog_optimize.c
+++ b/src/mesa/shader/prog_optimize.c
@@ -578,7 +578,7 @@ _mesa_remove_extra_moves(struct gl_program *prog)
 
             /* get pointer to previous instruction */
             prevI = i - 1;
-            while (removeInst[prevI] && prevI > 0)
+            while (prevI > 0 && removeInst[prevI])
                prevI--;
             prevInst = prog->Instructions + prevI;
 
diff --git a/src/mesa/shader/prog_parameter.c b/src/mesa/shader/prog_parameter.c
index f22492e..5822510 100644
--- a/src/mesa/shader/prog_parameter.c
+++ b/src/mesa/shader/prog_parameter.c
@@ -230,9 +230,8 @@ _mesa_add_named_constant(struct gl_program_parameter_list *paramList,
  * Add a new unnamed constant to the parameter list.  This will be used
  * when a fragment/vertex program contains something like this:
  *    MOV r, { 0, 1, 2, 3 };
- * We'll search the parameter list for an existing instance of the
- * constant.  If swizzleOut is non-null, we'll try swizzling when
- * looking for a match.
+ * If swizzleOut is non-null we'll search the parameter list for an
+ * existing instance of the constant which matches with a swizzle.
  *
  * \param paramList  the parameter list
  * \param values  four float values
@@ -248,7 +247,8 @@ _mesa_add_unnamed_constant(struct gl_program_parameter_list *paramList,
    ASSERT(size >= 1);
    ASSERT(size <= 4);
 
-   if (_mesa_lookup_parameter_constant(paramList, values,
+   if (swizzleOut &&
+       _mesa_lookup_parameter_constant(paramList, values,
                                        size, &pos, swizzleOut)) {
       return pos;
    }
diff --git a/src/mesa/shader/prog_parameter_layout.c b/src/mesa/shader/prog_parameter_layout.c
index 1c37b3a..a888573 100644
--- a/src/mesa/shader/prog_parameter_layout.c
+++ b/src/mesa/shader/prog_parameter_layout.c
@@ -72,14 +72,11 @@ copy_indirect_accessed_array(struct gl_program_parameter_list *src,
 			     unsigned first, unsigned count)
 {
    const int base = dst->NumParameters;
-   unsigned i;
-   unsigned j;
-
+   unsigned i, j;
 
    for (i = first; i < (first + count); i++) {
       struct gl_program_parameter *curr = & src->Parameters[i];
 
-
       if (curr->Type == PROGRAM_CONSTANT) {
 	 j = dst->NumParameters;
       } else {
@@ -93,10 +90,15 @@ copy_indirect_accessed_array(struct gl_program_parameter_list *src,
 
       assert(j == dst->NumParameters);
 
+      /* copy src parameter [i] to dest parameter [j] */
       memcpy(& dst->Parameters[j], curr,
 	     sizeof(dst->Parameters[j]));
       memcpy(dst->ParameterValues[j], src->ParameterValues[i],
 	     sizeof(GLfloat) * 4);
+
+      /* Pointer to the string name was copied.  Null-out src param name
+       * to prevent double free later.
+       */
       curr->Name = NULL;
 
       dst->NumParameters++;
@@ -117,11 +119,9 @@ _mesa_layout_parameters(struct asm_parser_state *state)
    struct asm_instruction *inst;
    unsigned i;
 
-
    layout =
       _mesa_new_parameter_list_sized(state->prog->Parameters->NumParameters);
 
-
    /* PASS 1:  Move any parameters that are accessed indirectly from the
     * original parameter list to the new parameter list.
     */
@@ -155,7 +155,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
       }
    }
 
-
    /* PASS 2:  Move any parameters that are not accessed indirectly from the
     * original parameter list to the new parameter list.
     */
@@ -165,7 +164,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 	 const int idx = inst->SrcReg[i].Base.Index;
 	 unsigned swizzle = SWIZZLE_NOOP;
 
-
 	 /* All relative addressed operands were processed on the first
 	  * pass.  Just skip them here.
 	  */
@@ -173,7 +171,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 	    continue;
 	 }
 
-
 	 if ((inst->SrcReg[i].Base.File <= PROGRAM_VARYING )
 	     || (inst->SrcReg[i].Base.File >= PROGRAM_WRITE_ONLY)) {
 	    continue;
@@ -209,7 +206,6 @@ _mesa_layout_parameters(struct asm_parser_state *state)
       }
    }
 
-
    _mesa_free_parameter_list(state->prog->Parameters);
    state->prog->Parameters = layout;
 
diff --git a/src/mesa/shader/prog_print.c b/src/mesa/shader/prog_print.c
index 52c102c..9f9789e 100644
--- a/src/mesa/shader/prog_print.c
+++ b/src/mesa/shader/prog_print.c
@@ -821,8 +821,10 @@ _mesa_print_program(const struct gl_program *prog)
 
 
 /**
- * Return binary representation of value (as a string).
+ * Return binary representation of 64-bit value (as a string).
  * Insert a comma to separate each group of 8 bits.
+ * Note we return a pointer to local static storage so this is not
+ * re-entrant, etc.
  * XXX move to imports.[ch] if useful elsewhere.
  */
 static const char *
@@ -831,7 +833,7 @@ binary(GLbitfield64 val)
    static char buf[80];
    GLint i, len = 0;
    for (i = 63; i >= 0; --i) {
-      if (val & (1 << i))
+      if (val & (1ULL << i))
          buf[len++] = '1';
       else if (len > 0 || i == 0)
          buf[len++] = '0';
@@ -855,7 +857,7 @@ _mesa_fprint_program_parameters(FILE *f,
 
    _mesa_fprintf(f, "InputsRead: 0x%x (0b%s)\n",
                  prog->InputsRead, binary(prog->InputsRead));
-   _mesa_fprintf(f, "OutputsWritten: 0x%x (0b%s)\n",
+   _mesa_fprintf(f, "OutputsWritten: 0x%llx (0b%s)\n",
                  prog->OutputsWritten, binary(prog->OutputsWritten));
    _mesa_fprintf(f, "NumInstructions=%d\n", prog->NumInstructions);
    _mesa_fprintf(f, "NumTemporaries=%d\n", prog->NumTemporaries);
diff --git a/src/mesa/shader/prog_statevars.c b/src/mesa/shader/prog_statevars.c
index 058d4bb..3a446fd 100644
--- a/src/mesa/shader/prog_statevars.c
+++ b/src/mesa/shader/prog_statevars.c
@@ -31,7 +31,6 @@
 
 #include "main/glheader.h"
 #include "main/context.h"
-#include "main/hash.h"
 #include "main/imports.h"
 #include "main/macros.h"
 #include "main/mtypes.h"
diff --git a/src/mesa/shader/program_parse.tab.c b/src/mesa/shader/program_parse.tab.c
index d4f8429..b12dcee 100644
--- a/src/mesa/shader/program_parse.tab.c
+++ b/src/mesa/shader/program_parse.tab.c
@@ -123,7 +123,8 @@ static int initialize_symbol_from_param(struct gl_program *prog,
     struct asm_symbol *param_var, const gl_state_index tokens[STATE_LENGTH]);
 
 static int initialize_symbol_from_const(struct gl_program *prog,
-    struct asm_symbol *param_var, const struct asm_vector *vec);
+    struct asm_symbol *param_var, const struct asm_vector *vec,
+    GLboolean allowSwizzle);
 
 static int yyparse(struct asm_parser_state *state);
 
@@ -145,6 +146,9 @@ static void init_src_reg(struct asm_src_register *r);
 static void set_src_reg(struct asm_src_register *r,
                         gl_register_file file, GLint index);
 
+static void set_src_reg_swz(struct asm_src_register *r,
+                            gl_register_file file, GLint index, GLuint swizzle);
+
 static void asm_instruction_set_operands(struct asm_instruction *inst,
     const struct prog_dst_register *dst, const struct asm_src_register *src0,
     const struct asm_src_register *src1, const struct asm_src_register *src2);
@@ -185,7 +189,7 @@ static struct asm_instruction *asm_instruction_copy_ctor(
 
 
 /* Line 189 of yacc.c  */
-#line 189 "program_parse.tab.c"
+#line 193 "program_parse.tab.c"
 
 /* Enabling traces.  */
 #ifndef YYDEBUG
@@ -327,7 +331,7 @@ typedef union YYSTYPE
 {
 
 /* Line 214 of yacc.c  */
-#line 122 "program_parse.y"
+#line 126 "program_parse.y"
 
    struct asm_instruction *inst;
    struct asm_symbol *sym;
@@ -356,7 +360,7 @@ typedef union YYSTYPE
 
 
 /* Line 214 of yacc.c  */
-#line 360 "program_parse.tab.c"
+#line 364 "program_parse.tab.c"
 } YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
@@ -380,14 +384,14 @@ typedef struct YYLTYPE
 /* Copy the second part of user declarations.  */
 
 /* Line 264 of yacc.c  */
-#line 267 "program_parse.y"
+#line 271 "program_parse.y"
 
 extern int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param,
     void *yyscanner);
 
 
 /* Line 264 of yacc.c  */
-#line 391 "program_parse.tab.c"
+#line 395 "program_parse.tab.c"
 
 #ifdef short
 # undef short
@@ -788,35 +792,35 @@ static const yytype_int16 yyrhs[] =
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   274,   274,   277,   285,   297,   298,   301,   325,   326,
-     329,   344,   347,   352,   359,   360,   361,   362,   363,   364,
-     365,   368,   369,   370,   373,   379,   385,   391,   398,   404,
-     411,   455,   460,   470,   514,   520,   521,   522,   523,   524,
-     525,   526,   527,   528,   529,   530,   531,   534,   546,   554,
-     571,   578,   595,   606,   626,   651,   658,   691,   698,   713,
-     768,   809,   818,   839,   848,   852,   881,   900,   900,   902,
-     909,   921,   922,   923,   926,   940,   954,   974,   985,   997,
-     999,  1000,  1001,  1002,  1005,  1005,  1005,  1005,  1006,  1009,
-    1013,  1018,  1025,  1032,  1039,  1062,  1085,  1086,  1087,  1088,
-    1089,  1090,  1093,  1112,  1116,  1122,  1126,  1130,  1134,  1143,
-    1152,  1156,  1161,  1167,  1178,  1178,  1179,  1181,  1185,  1189,
-    1193,  1199,  1199,  1201,  1218,  1243,  1246,  1257,  1263,  1269,
-    1270,  1277,  1283,  1289,  1297,  1303,  1309,  1317,  1323,  1329,
-    1337,  1338,  1341,  1342,  1343,  1344,  1345,  1346,  1347,  1348,
-    1349,  1350,  1351,  1354,  1363,  1367,  1371,  1377,  1386,  1390,
-    1394,  1403,  1407,  1413,  1419,  1426,  1431,  1439,  1449,  1451,
-    1459,  1465,  1469,  1473,  1479,  1490,  1499,  1503,  1508,  1512,
-    1516,  1520,  1526,  1533,  1537,  1543,  1551,  1562,  1569,  1573,
-    1579,  1589,  1600,  1604,  1622,  1631,  1634,  1640,  1644,  1648,
-    1654,  1665,  1670,  1675,  1680,  1685,  1690,  1698,  1701,  1706,
-    1719,  1727,  1738,  1746,  1746,  1748,  1748,  1750,  1760,  1765,
-    1772,  1782,  1791,  1796,  1803,  1813,  1823,  1835,  1835,  1836,
-    1836,  1838,  1848,  1856,  1866,  1874,  1882,  1891,  1902,  1906,
-    1912,  1913,  1914,  1917,  1917,  1920,  1955,  1959,  1959,  1962,
-    1969,  1978,  1992,  2001,  2010,  2014,  2023,  2032,  2043,  2050,
-    2055,  2064,  2076,  2079,  2088,  2099,  2100,  2101,  2104,  2105,
-    2106,  2109,  2110,  2113,  2114,  2117,  2118,  2121,  2132,  2143,
-    2154,  2180,  2181
+       0,   278,   278,   281,   289,   301,   302,   305,   329,   330,
+     333,   348,   351,   356,   363,   364,   365,   366,   367,   368,
+     369,   372,   373,   374,   377,   383,   389,   395,   402,   408,
+     415,   459,   464,   474,   518,   524,   525,   526,   527,   528,
+     529,   530,   531,   532,   533,   534,   535,   538,   550,   558,
+     575,   582,   601,   612,   632,   657,   664,   697,   704,   719,
+     774,   817,   826,   847,   857,   861,   890,   909,   909,   911,
+     918,   930,   931,   932,   935,   949,   963,   983,   994,  1006,
+    1008,  1009,  1010,  1011,  1014,  1014,  1014,  1014,  1015,  1018,
+    1022,  1027,  1034,  1041,  1048,  1071,  1094,  1095,  1096,  1097,
+    1098,  1099,  1102,  1121,  1125,  1131,  1135,  1139,  1143,  1152,
+    1161,  1165,  1170,  1176,  1187,  1187,  1188,  1190,  1194,  1198,
+    1202,  1208,  1208,  1210,  1228,  1254,  1257,  1268,  1274,  1280,
+    1281,  1288,  1294,  1300,  1308,  1314,  1320,  1328,  1334,  1340,
+    1348,  1349,  1352,  1353,  1354,  1355,  1356,  1357,  1358,  1359,
+    1360,  1361,  1362,  1365,  1374,  1378,  1382,  1388,  1397,  1401,
+    1405,  1414,  1418,  1424,  1430,  1437,  1442,  1450,  1460,  1462,
+    1470,  1476,  1480,  1484,  1490,  1501,  1510,  1514,  1519,  1523,
+    1527,  1531,  1537,  1544,  1548,  1554,  1562,  1573,  1580,  1584,
+    1590,  1600,  1611,  1615,  1633,  1642,  1645,  1651,  1655,  1659,
+    1665,  1676,  1681,  1686,  1691,  1696,  1701,  1709,  1712,  1717,
+    1730,  1738,  1749,  1757,  1757,  1759,  1759,  1761,  1771,  1776,
+    1783,  1793,  1802,  1807,  1814,  1824,  1834,  1846,  1846,  1847,
+    1847,  1849,  1859,  1867,  1877,  1885,  1893,  1902,  1913,  1917,
+    1923,  1924,  1925,  1928,  1928,  1931,  1966,  1970,  1970,  1973,
+    1980,  1989,  2003,  2012,  2021,  2025,  2034,  2043,  2054,  2061,
+    2066,  2075,  2087,  2090,  2099,  2110,  2111,  2112,  2115,  2116,
+    2117,  2120,  2121,  2124,  2125,  2128,  2129,  2132,  2143,  2154,
+    2165,  2191,  2192
 };
 #endif
 
@@ -2125,7 +2129,7 @@ yyreduce:
         case 3:
 
 /* Line 1455 of yacc.c  */
-#line 278 "program_parse.y"
+#line 282 "program_parse.y"
     {
 	   if (state->prog->Target != GL_VERTEX_PROGRAM_ARB) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid fragment program header");
@@ -2138,7 +2142,7 @@ yyreduce:
   case 4:
 
 /* Line 1455 of yacc.c  */
-#line 286 "program_parse.y"
+#line 290 "program_parse.y"
     {
 	   if (state->prog->Target != GL_FRAGMENT_PROGRAM_ARB) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid vertex program header");
@@ -2153,7 +2157,7 @@ yyreduce:
   case 7:
 
 /* Line 1455 of yacc.c  */
-#line 302 "program_parse.y"
+#line 306 "program_parse.y"
     {
 	   int valid = 0;
 
@@ -2180,7 +2184,7 @@ yyreduce:
   case 10:
 
 /* Line 1455 of yacc.c  */
-#line 330 "program_parse.y"
+#line 334 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (2)].inst) != NULL) {
 	      if (state->inst_tail == NULL) {
@@ -2200,7 +2204,7 @@ yyreduce:
   case 12:
 
 /* Line 1455 of yacc.c  */
-#line 348 "program_parse.y"
+#line 352 "program_parse.y"
     {
 	   (yyval.inst) = (yyvsp[(1) - (1)].inst);
 	   state->prog->NumAluInstructions++;
@@ -2210,7 +2214,7 @@ yyreduce:
   case 13:
 
 /* Line 1455 of yacc.c  */
-#line 353 "program_parse.y"
+#line 357 "program_parse.y"
     {
 	   (yyval.inst) = (yyvsp[(1) - (1)].inst);
 	   state->prog->NumTexInstructions++;
@@ -2220,7 +2224,7 @@ yyreduce:
   case 24:
 
 /* Line 1455 of yacc.c  */
-#line 374 "program_parse.y"
+#line 378 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_ARL, & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2229,7 +2233,7 @@ yyreduce:
   case 25:
 
 /* Line 1455 of yacc.c  */
-#line 380 "program_parse.y"
+#line 384 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (4)].temp_inst), & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2238,7 +2242,7 @@ yyreduce:
   case 26:
 
 /* Line 1455 of yacc.c  */
-#line 386 "program_parse.y"
+#line 390 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (4)].temp_inst), & (yyvsp[(2) - (4)].dst_reg), & (yyvsp[(4) - (4)].src_reg), NULL, NULL);
 	;}
@@ -2247,7 +2251,7 @@ yyreduce:
   case 27:
 
 /* Line 1455 of yacc.c  */
-#line 392 "program_parse.y"
+#line 396 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (6)].temp_inst), & (yyvsp[(2) - (6)].dst_reg), & (yyvsp[(4) - (6)].src_reg), & (yyvsp[(6) - (6)].src_reg), NULL);
 	;}
@@ -2256,7 +2260,7 @@ yyreduce:
   case 28:
 
 /* Line 1455 of yacc.c  */
-#line 399 "program_parse.y"
+#line 403 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (6)].temp_inst), & (yyvsp[(2) - (6)].dst_reg), & (yyvsp[(4) - (6)].src_reg), & (yyvsp[(6) - (6)].src_reg), NULL);
 	;}
@@ -2265,7 +2269,7 @@ yyreduce:
   case 29:
 
 /* Line 1455 of yacc.c  */
-#line 406 "program_parse.y"
+#line 410 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (8)].temp_inst), & (yyvsp[(2) - (8)].dst_reg), & (yyvsp[(4) - (8)].src_reg), & (yyvsp[(6) - (8)].src_reg), & (yyvsp[(8) - (8)].src_reg));
 	;}
@@ -2274,7 +2278,7 @@ yyreduce:
   case 30:
 
 /* Line 1455 of yacc.c  */
-#line 412 "program_parse.y"
+#line 416 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (8)].temp_inst), & (yyvsp[(2) - (8)].dst_reg), & (yyvsp[(4) - (8)].src_reg), NULL, NULL);
 	   if ((yyval.inst) != NULL) {
@@ -2321,7 +2325,7 @@ yyreduce:
   case 31:
 
 /* Line 1455 of yacc.c  */
-#line 456 "program_parse.y"
+#line 460 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_KIL, NULL, & (yyvsp[(2) - (2)].src_reg), NULL, NULL);
 	   state->fragment.UsesKill = 1;
@@ -2331,7 +2335,7 @@ yyreduce:
   case 32:
 
 /* Line 1455 of yacc.c  */
-#line 461 "program_parse.y"
+#line 465 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_ctor(OPCODE_KIL_NV, NULL, NULL, NULL, NULL);
 	   (yyval.inst)->Base.DstReg.CondMask = (yyvsp[(2) - (2)].dst_reg).CondMask;
@@ -2344,7 +2348,7 @@ yyreduce:
   case 33:
 
 /* Line 1455 of yacc.c  */
-#line 471 "program_parse.y"
+#line 475 "program_parse.y"
     {
 	   (yyval.inst) = asm_instruction_copy_ctor(& (yyvsp[(1) - (12)].temp_inst), & (yyvsp[(2) - (12)].dst_reg), & (yyvsp[(4) - (12)].src_reg), & (yyvsp[(6) - (12)].src_reg), & (yyvsp[(8) - (12)].src_reg));
 	   if ((yyval.inst) != NULL) {
@@ -2391,7 +2395,7 @@ yyreduce:
   case 34:
 
 /* Line 1455 of yacc.c  */
-#line 515 "program_parse.y"
+#line 519 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (2)].integer);
 	;}
@@ -2400,91 +2404,91 @@ yyreduce:
   case 35:
 
 /* Line 1455 of yacc.c  */
-#line 520 "program_parse.y"
+#line 524 "program_parse.y"
     { (yyval.integer) = TEXTURE_1D_INDEX; ;}
     break;
 
   case 36:
 
 /* Line 1455 of yacc.c  */
-#line 521 "program_parse.y"
+#line 525 "program_parse.y"
     { (yyval.integer) = TEXTURE_2D_INDEX; ;}
     break;
 
   case 37:
 
 /* Line 1455 of yacc.c  */
-#line 522 "program_parse.y"
+#line 526 "program_parse.y"
     { (yyval.integer) = TEXTURE_3D_INDEX; ;}
     break;
 
   case 38:
 
 /* Line 1455 of yacc.c  */
-#line 523 "program_parse.y"
+#line 527 "program_parse.y"
     { (yyval.integer) = TEXTURE_CUBE_INDEX; ;}
     break;
 
   case 39:
 
 /* Line 1455 of yacc.c  */
-#line 524 "program_parse.y"
+#line 528 "program_parse.y"
     { (yyval.integer) = TEXTURE_RECT_INDEX; ;}
     break;
 
   case 40:
 
 /* Line 1455 of yacc.c  */
-#line 525 "program_parse.y"
+#line 529 "program_parse.y"
     { (yyval.integer) = -TEXTURE_1D_INDEX; ;}
     break;
 
   case 41:
 
 /* Line 1455 of yacc.c  */
-#line 526 "program_parse.y"
+#line 530 "program_parse.y"
     { (yyval.integer) = -TEXTURE_2D_INDEX; ;}
     break;
 
   case 42:
 
 /* Line 1455 of yacc.c  */
-#line 527 "program_parse.y"
+#line 531 "program_parse.y"
     { (yyval.integer) = -TEXTURE_RECT_INDEX; ;}
     break;
 
   case 43:
 
 /* Line 1455 of yacc.c  */
-#line 528 "program_parse.y"
+#line 532 "program_parse.y"
     { (yyval.integer) = TEXTURE_1D_ARRAY_INDEX; ;}
     break;
 
   case 44:
 
 /* Line 1455 of yacc.c  */
-#line 529 "program_parse.y"
+#line 533 "program_parse.y"
     { (yyval.integer) = TEXTURE_2D_ARRAY_INDEX; ;}
     break;
 
   case 45:
 
 /* Line 1455 of yacc.c  */
-#line 530 "program_parse.y"
+#line 534 "program_parse.y"
     { (yyval.integer) = -TEXTURE_1D_ARRAY_INDEX; ;}
     break;
 
   case 46:
 
 /* Line 1455 of yacc.c  */
-#line 531 "program_parse.y"
+#line 535 "program_parse.y"
     { (yyval.integer) = -TEXTURE_2D_ARRAY_INDEX; ;}
     break;
 
   case 47:
 
 /* Line 1455 of yacc.c  */
-#line 535 "program_parse.y"
+#line 539 "program_parse.y"
     {
 	   /* FIXME: Is this correct?  Should the extenedSwizzle be applied
 	    * FIXME: to the existing swizzle?
@@ -2499,7 +2503,7 @@ yyreduce:
   case 48:
 
 /* Line 1455 of yacc.c  */
-#line 547 "program_parse.y"
+#line 551 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(2) - (2)].src_reg);
 
@@ -2512,7 +2516,7 @@ yyreduce:
   case 49:
 
 /* Line 1455 of yacc.c  */
-#line 555 "program_parse.y"
+#line 559 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(3) - (4)].src_reg);
 
@@ -2532,7 +2536,7 @@ yyreduce:
   case 50:
 
 /* Line 1455 of yacc.c  */
-#line 572 "program_parse.y"
+#line 576 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(1) - (2)].src_reg);
 
@@ -2544,7 +2548,7 @@ yyreduce:
   case 51:
 
 /* Line 1455 of yacc.c  */
-#line 579 "program_parse.y"
+#line 583 "program_parse.y"
     {
 	   struct asm_symbol temp_sym;
 
@@ -2555,16 +2559,18 @@ yyreduce:
 
 	   memset(& temp_sym, 0, sizeof(temp_sym));
 	   temp_sym.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & temp_sym, & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & temp_sym, & (yyvsp[(1) - (1)].vector), GL_TRUE);
 
-	   set_src_reg(& (yyval.src_reg), PROGRAM_CONSTANT, temp_sym.param_binding_begin);
+	   set_src_reg_swz(& (yyval.src_reg), PROGRAM_CONSTANT,
+                           temp_sym.param_binding_begin,
+                           temp_sym.param_binding_swizzle);
 	;}
     break;
 
   case 52:
 
 /* Line 1455 of yacc.c  */
-#line 596 "program_parse.y"
+#line 602 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(2) - (3)].src_reg);
 
@@ -2580,7 +2586,7 @@ yyreduce:
   case 53:
 
 /* Line 1455 of yacc.c  */
-#line 607 "program_parse.y"
+#line 613 "program_parse.y"
     {
 	   (yyval.src_reg) = (yyvsp[(3) - (5)].src_reg);
 
@@ -2602,7 +2608,7 @@ yyreduce:
   case 54:
 
 /* Line 1455 of yacc.c  */
-#line 627 "program_parse.y"
+#line 633 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (3)].dst_reg);
 	   (yyval.dst_reg).WriteMask = (yyvsp[(2) - (3)].swiz_mask).mask;
@@ -2630,7 +2636,7 @@ yyreduce:
   case 55:
 
 /* Line 1455 of yacc.c  */
-#line 652 "program_parse.y"
+#line 658 "program_parse.y"
     {
 	   set_dst_reg(& (yyval.dst_reg), PROGRAM_ADDRESS, 0);
 	   (yyval.dst_reg).WriteMask = (yyvsp[(2) - (2)].swiz_mask).mask;
@@ -2640,7 +2646,7 @@ yyreduce:
   case 56:
 
 /* Line 1455 of yacc.c  */
-#line 659 "program_parse.y"
+#line 665 "program_parse.y"
     {
 	   const unsigned xyzw_valid =
 	      ((yyvsp[(1) - (7)].ext_swizzle).xyzw_valid << 0)
@@ -2676,7 +2682,7 @@ yyreduce:
   case 57:
 
 /* Line 1455 of yacc.c  */
-#line 692 "program_parse.y"
+#line 698 "program_parse.y"
     {
 	   (yyval.ext_swizzle) = (yyvsp[(2) - (2)].ext_swizzle);
 	   (yyval.ext_swizzle).negate = ((yyvsp[(1) - (2)].negate)) ? 1 : 0;
@@ -2686,7 +2692,7 @@ yyreduce:
   case 58:
 
 /* Line 1455 of yacc.c  */
-#line 699 "program_parse.y"
+#line 705 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) != 0) && ((yyvsp[(1) - (1)].integer) != 1)) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid extended swizzle selector");
@@ -2706,7 +2712,7 @@ yyreduce:
   case 59:
 
 /* Line 1455 of yacc.c  */
-#line 714 "program_parse.y"
+#line 720 "program_parse.y"
     {
 	   char s;
 
@@ -2764,7 +2770,7 @@ yyreduce:
   case 60:
 
 /* Line 1455 of yacc.c  */
-#line 769 "program_parse.y"
+#line 775 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2789,7 +2795,9 @@ yyreduce:
 	      set_src_reg(& (yyval.src_reg), PROGRAM_TEMPORARY, s->temp_binding);
 	      break;
 	   case at_param:
-	      set_src_reg(& (yyval.src_reg), s->param_binding_type, s->param_binding_begin);
+              set_src_reg_swz(& (yyval.src_reg), s->param_binding_type,
+                              s->param_binding_begin,
+                              s->param_binding_swizzle);
 	      break;
 	   case at_attrib:
 	      set_src_reg(& (yyval.src_reg), PROGRAM_INPUT, s->attrib_binding);
@@ -2810,7 +2818,7 @@ yyreduce:
   case 61:
 
 /* Line 1455 of yacc.c  */
-#line 810 "program_parse.y"
+#line 818 "program_parse.y"
     {
 	   set_src_reg(& (yyval.src_reg), PROGRAM_INPUT, (yyvsp[(1) - (1)].attrib));
 	   state->prog->InputsRead |= (1U << (yyval.src_reg).Base.Index);
@@ -2824,7 +2832,7 @@ yyreduce:
   case 62:
 
 /* Line 1455 of yacc.c  */
-#line 819 "program_parse.y"
+#line 827 "program_parse.y"
     {
 	   if (! (yyvsp[(3) - (4)].src_reg).Base.RelAddr
 	       && ((unsigned) (yyvsp[(3) - (4)].src_reg).Base.Index >= (yyvsp[(1) - (4)].sym)->param_binding_length)) {
@@ -2850,19 +2858,20 @@ yyreduce:
   case 63:
 
 /* Line 1455 of yacc.c  */
-#line 840 "program_parse.y"
+#line 848 "program_parse.y"
     {
            gl_register_file file = ((yyvsp[(1) - (1)].temp_sym).name != NULL) 
 	      ? (yyvsp[(1) - (1)].temp_sym).param_binding_type
 	      : PROGRAM_CONSTANT;
-	   set_src_reg(& (yyval.src_reg), file, (yyvsp[(1) - (1)].temp_sym).param_binding_begin);
+           set_src_reg_swz(& (yyval.src_reg), file, (yyvsp[(1) - (1)].temp_sym).param_binding_begin,
+                           (yyvsp[(1) - (1)].temp_sym).param_binding_swizzle);
 	;}
     break;
 
   case 64:
 
 /* Line 1455 of yacc.c  */
-#line 849 "program_parse.y"
+#line 858 "program_parse.y"
     {
 	   set_dst_reg(& (yyval.dst_reg), PROGRAM_OUTPUT, (yyvsp[(1) - (1)].result));
 	;}
@@ -2871,7 +2880,7 @@ yyreduce:
   case 65:
 
 /* Line 1455 of yacc.c  */
-#line 853 "program_parse.y"
+#line 862 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2903,7 +2912,7 @@ yyreduce:
   case 66:
 
 /* Line 1455 of yacc.c  */
-#line 882 "program_parse.y"
+#line 891 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -2925,7 +2934,7 @@ yyreduce:
   case 69:
 
 /* Line 1455 of yacc.c  */
-#line 903 "program_parse.y"
+#line 912 "program_parse.y"
     {
 	   init_src_reg(& (yyval.src_reg));
 	   (yyval.src_reg).Base.Index = (yyvsp[(1) - (1)].integer);
@@ -2935,7 +2944,7 @@ yyreduce:
   case 70:
 
 /* Line 1455 of yacc.c  */
-#line 910 "program_parse.y"
+#line 919 "program_parse.y"
     {
 	   /* FINISHME: Add support for multiple address registers.
 	    */
@@ -2950,28 +2959,28 @@ yyreduce:
   case 71:
 
 /* Line 1455 of yacc.c  */
-#line 921 "program_parse.y"
+#line 930 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 72:
 
 /* Line 1455 of yacc.c  */
-#line 922 "program_parse.y"
+#line 931 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 73:
 
 /* Line 1455 of yacc.c  */
-#line 923 "program_parse.y"
+#line 932 "program_parse.y"
     { (yyval.integer) = -(yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 74:
 
 /* Line 1455 of yacc.c  */
-#line 927 "program_parse.y"
+#line 936 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 0) || ((yyvsp[(1) - (1)].integer) > 63)) {
               char s[100];
@@ -2988,7 +2997,7 @@ yyreduce:
   case 75:
 
 /* Line 1455 of yacc.c  */
-#line 941 "program_parse.y"
+#line 950 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 0) || ((yyvsp[(1) - (1)].integer) > 64)) {
               char s[100];
@@ -3005,7 +3014,7 @@ yyreduce:
   case 76:
 
 /* Line 1455 of yacc.c  */
-#line 955 "program_parse.y"
+#line 964 "program_parse.y"
     {
 	   struct asm_symbol *const s = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(1) - (1)].string));
@@ -3028,7 +3037,7 @@ yyreduce:
   case 77:
 
 /* Line 1455 of yacc.c  */
-#line 975 "program_parse.y"
+#line 984 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].swiz_mask).mask != WRITEMASK_X) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid address component selector");
@@ -3042,7 +3051,7 @@ yyreduce:
   case 78:
 
 /* Line 1455 of yacc.c  */
-#line 986 "program_parse.y"
+#line 995 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].swiz_mask).mask != WRITEMASK_X) {
 	      yyerror(& (yylsp[(1) - (1)]), state,
@@ -3057,21 +3066,21 @@ yyreduce:
   case 83:
 
 /* Line 1455 of yacc.c  */
-#line 1002 "program_parse.y"
+#line 1011 "program_parse.y"
     { (yyval.swiz_mask).swizzle = SWIZZLE_NOOP; (yyval.swiz_mask).mask = WRITEMASK_XYZW; ;}
     break;
 
   case 88:
 
 /* Line 1455 of yacc.c  */
-#line 1006 "program_parse.y"
+#line 1015 "program_parse.y"
     { (yyval.swiz_mask).swizzle = SWIZZLE_NOOP; (yyval.swiz_mask).mask = WRITEMASK_XYZW; ;}
     break;
 
   case 89:
 
 /* Line 1455 of yacc.c  */
-#line 1010 "program_parse.y"
+#line 1019 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(2) - (3)].dst_reg);
 	;}
@@ -3080,7 +3089,7 @@ yyreduce:
   case 90:
 
 /* Line 1455 of yacc.c  */
-#line 1014 "program_parse.y"
+#line 1023 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(2) - (3)].dst_reg);
 	;}
@@ -3089,7 +3098,7 @@ yyreduce:
   case 91:
 
 /* Line 1455 of yacc.c  */
-#line 1018 "program_parse.y"
+#line 1027 "program_parse.y"
     {
 	   (yyval.dst_reg).CondMask = COND_TR;
 	   (yyval.dst_reg).CondSwizzle = SWIZZLE_NOOP;
@@ -3100,7 +3109,7 @@ yyreduce:
   case 92:
 
 /* Line 1455 of yacc.c  */
-#line 1026 "program_parse.y"
+#line 1035 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (2)].dst_reg);
 	   (yyval.dst_reg).CondSwizzle = (yyvsp[(2) - (2)].swiz_mask).swizzle;
@@ -3110,7 +3119,7 @@ yyreduce:
   case 93:
 
 /* Line 1455 of yacc.c  */
-#line 1033 "program_parse.y"
+#line 1042 "program_parse.y"
     {
 	   (yyval.dst_reg) = (yyvsp[(1) - (2)].dst_reg);
 	   (yyval.dst_reg).CondSwizzle = (yyvsp[(2) - (2)].swiz_mask).swizzle;
@@ -3120,7 +3129,7 @@ yyreduce:
   case 94:
 
 /* Line 1455 of yacc.c  */
-#line 1040 "program_parse.y"
+#line 1049 "program_parse.y"
     {
 	   const int cond = _mesa_parse_cc((yyvsp[(1) - (1)].string));
 	   if ((cond == 0) || ((yyvsp[(1) - (1)].string)[2] != '\0')) {
@@ -3146,7 +3155,7 @@ yyreduce:
   case 95:
 
 /* Line 1455 of yacc.c  */
-#line 1063 "program_parse.y"
+#line 1072 "program_parse.y"
     {
 	   const int cond = _mesa_parse_cc((yyvsp[(1) - (1)].string));
 	   if ((cond == 0) || ((yyvsp[(1) - (1)].string)[2] != '\0')) {
@@ -3172,7 +3181,7 @@ yyreduce:
   case 102:
 
 /* Line 1455 of yacc.c  */
-#line 1094 "program_parse.y"
+#line 1103 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(2) - (4)].string), at_attrib, & (yylsp[(2) - (4)]));
@@ -3194,7 +3203,7 @@ yyreduce:
   case 103:
 
 /* Line 1455 of yacc.c  */
-#line 1113 "program_parse.y"
+#line 1122 "program_parse.y"
     {
 	   (yyval.attrib) = (yyvsp[(2) - (2)].attrib);
 	;}
@@ -3203,7 +3212,7 @@ yyreduce:
   case 104:
 
 /* Line 1455 of yacc.c  */
-#line 1117 "program_parse.y"
+#line 1126 "program_parse.y"
     {
 	   (yyval.attrib) = (yyvsp[(2) - (2)].attrib);
 	;}
@@ -3212,7 +3221,7 @@ yyreduce:
   case 105:
 
 /* Line 1455 of yacc.c  */
-#line 1123 "program_parse.y"
+#line 1132 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_POS;
 	;}
@@ -3221,7 +3230,7 @@ yyreduce:
   case 106:
 
 /* Line 1455 of yacc.c  */
-#line 1127 "program_parse.y"
+#line 1136 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_WEIGHT;
 	;}
@@ -3230,7 +3239,7 @@ yyreduce:
   case 107:
 
 /* Line 1455 of yacc.c  */
-#line 1131 "program_parse.y"
+#line 1140 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_NORMAL;
 	;}
@@ -3239,7 +3248,7 @@ yyreduce:
   case 108:
 
 /* Line 1455 of yacc.c  */
-#line 1135 "program_parse.y"
+#line 1144 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_secondary_color) {
 	      yyerror(& (yylsp[(2) - (2)]), state, "GL_EXT_secondary_color not supported");
@@ -3253,7 +3262,7 @@ yyreduce:
   case 109:
 
 /* Line 1455 of yacc.c  */
-#line 1144 "program_parse.y"
+#line 1153 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_fog_coord) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "GL_EXT_fog_coord not supported");
@@ -3267,7 +3276,7 @@ yyreduce:
   case 110:
 
 /* Line 1455 of yacc.c  */
-#line 1153 "program_parse.y"
+#line 1162 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_TEX0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3276,7 +3285,7 @@ yyreduce:
   case 111:
 
 /* Line 1455 of yacc.c  */
-#line 1157 "program_parse.y"
+#line 1166 "program_parse.y"
     {
 	   yyerror(& (yylsp[(1) - (4)]), state, "GL_ARB_matrix_palette not supported");
 	   YYERROR;
@@ -3286,7 +3295,7 @@ yyreduce:
   case 112:
 
 /* Line 1455 of yacc.c  */
-#line 1162 "program_parse.y"
+#line 1171 "program_parse.y"
     {
 	   (yyval.attrib) = VERT_ATTRIB_GENERIC0 + (yyvsp[(3) - (4)].integer);
 	;}
@@ -3295,7 +3304,7 @@ yyreduce:
   case 113:
 
 /* Line 1455 of yacc.c  */
-#line 1168 "program_parse.y"
+#line 1177 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxAttribs) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid vertex attribute reference");
@@ -3309,7 +3318,7 @@ yyreduce:
   case 117:
 
 /* Line 1455 of yacc.c  */
-#line 1182 "program_parse.y"
+#line 1191 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_WPOS;
 	;}
@@ -3318,7 +3327,7 @@ yyreduce:
   case 118:
 
 /* Line 1455 of yacc.c  */
-#line 1186 "program_parse.y"
+#line 1195 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_COL0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3327,7 +3336,7 @@ yyreduce:
   case 119:
 
 /* Line 1455 of yacc.c  */
-#line 1190 "program_parse.y"
+#line 1199 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_FOGC;
 	;}
@@ -3336,7 +3345,7 @@ yyreduce:
   case 120:
 
 /* Line 1455 of yacc.c  */
-#line 1194 "program_parse.y"
+#line 1203 "program_parse.y"
     {
 	   (yyval.attrib) = FRAG_ATTRIB_TEX0 + (yyvsp[(2) - (2)].integer);
 	;}
@@ -3345,7 +3354,7 @@ yyreduce:
   case 123:
 
 /* Line 1455 of yacc.c  */
-#line 1202 "program_parse.y"
+#line 1211 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(2) - (3)].string), at_param, & (yylsp[(2) - (3)]));
@@ -3357,6 +3366,7 @@ yyreduce:
 	      s->param_binding_type = (yyvsp[(3) - (3)].temp_sym).param_binding_type;
 	      s->param_binding_begin = (yyvsp[(3) - (3)].temp_sym).param_binding_begin;
 	      s->param_binding_length = (yyvsp[(3) - (3)].temp_sym).param_binding_length;
+              s->param_binding_swizzle = SWIZZLE_XYZW;
 	      s->param_is_array = 0;
 	   }
 	;}
@@ -3365,7 +3375,7 @@ yyreduce:
   case 124:
 
 /* Line 1455 of yacc.c  */
-#line 1219 "program_parse.y"
+#line 1229 "program_parse.y"
     {
 	   if (((yyvsp[(4) - (6)].integer) != 0) && ((unsigned) (yyvsp[(4) - (6)].integer) != (yyvsp[(6) - (6)].temp_sym).param_binding_length)) {
 	      free((yyvsp[(2) - (6)].string));
@@ -3383,6 +3393,7 @@ yyreduce:
 		 s->param_binding_type = (yyvsp[(6) - (6)].temp_sym).param_binding_type;
 		 s->param_binding_begin = (yyvsp[(6) - (6)].temp_sym).param_binding_begin;
 		 s->param_binding_length = (yyvsp[(6) - (6)].temp_sym).param_binding_length;
+                 s->param_binding_swizzle = SWIZZLE_XYZW;
 		 s->param_is_array = 1;
 	      }
 	   }
@@ -3392,7 +3403,7 @@ yyreduce:
   case 125:
 
 /* Line 1455 of yacc.c  */
-#line 1243 "program_parse.y"
+#line 1254 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -3401,7 +3412,7 @@ yyreduce:
   case 126:
 
 /* Line 1455 of yacc.c  */
-#line 1247 "program_parse.y"
+#line 1258 "program_parse.y"
     {
 	   if (((yyvsp[(1) - (1)].integer) < 1) || ((unsigned) (yyvsp[(1) - (1)].integer) > state->limits->MaxParameters)) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid parameter array size");
@@ -3415,7 +3426,7 @@ yyreduce:
   case 127:
 
 /* Line 1455 of yacc.c  */
-#line 1258 "program_parse.y"
+#line 1269 "program_parse.y"
     {
 	   (yyval.temp_sym) = (yyvsp[(2) - (2)].temp_sym);
 	;}
@@ -3424,7 +3435,7 @@ yyreduce:
   case 128:
 
 /* Line 1455 of yacc.c  */
-#line 1264 "program_parse.y"
+#line 1275 "program_parse.y"
     {
 	   (yyval.temp_sym) = (yyvsp[(3) - (4)].temp_sym);
 	;}
@@ -3433,7 +3444,7 @@ yyreduce:
   case 130:
 
 /* Line 1455 of yacc.c  */
-#line 1271 "program_parse.y"
+#line 1282 "program_parse.y"
     {
 	   (yyvsp[(1) - (3)].temp_sym).param_binding_length += (yyvsp[(3) - (3)].temp_sym).param_binding_length;
 	   (yyval.temp_sym) = (yyvsp[(1) - (3)].temp_sym);
@@ -3443,7 +3454,7 @@ yyreduce:
   case 131:
 
 /* Line 1455 of yacc.c  */
-#line 1278 "program_parse.y"
+#line 1289 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3454,7 +3465,7 @@ yyreduce:
   case 132:
 
 /* Line 1455 of yacc.c  */
-#line 1284 "program_parse.y"
+#line 1295 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3465,18 +3476,18 @@ yyreduce:
   case 133:
 
 /* Line 1455 of yacc.c  */
-#line 1290 "program_parse.y"
+#line 1301 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_TRUE);
 	;}
     break;
 
   case 134:
 
 /* Line 1455 of yacc.c  */
-#line 1298 "program_parse.y"
+#line 1309 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3487,7 +3498,7 @@ yyreduce:
   case 135:
 
 /* Line 1455 of yacc.c  */
-#line 1304 "program_parse.y"
+#line 1315 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3498,18 +3509,18 @@ yyreduce:
   case 136:
 
 /* Line 1455 of yacc.c  */
-#line 1310 "program_parse.y"
+#line 1321 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_TRUE);
 	;}
     break;
 
   case 137:
 
 /* Line 1455 of yacc.c  */
-#line 1318 "program_parse.y"
+#line 1329 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3520,7 +3531,7 @@ yyreduce:
   case 138:
 
 /* Line 1455 of yacc.c  */
-#line 1324 "program_parse.y"
+#line 1335 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
@@ -3531,109 +3542,109 @@ yyreduce:
   case 139:
 
 /* Line 1455 of yacc.c  */
-#line 1330 "program_parse.y"
+#line 1341 "program_parse.y"
     {
 	   memset(& (yyval.temp_sym), 0, sizeof((yyval.temp_sym)));
 	   (yyval.temp_sym).param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector));
+	   initialize_symbol_from_const(state->prog, & (yyval.temp_sym), & (yyvsp[(1) - (1)].vector), GL_FALSE);
 	;}
     break;
 
   case 140:
 
 /* Line 1455 of yacc.c  */
-#line 1337 "program_parse.y"
+#line 1348 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(1) - (1)].state), sizeof((yyval.state))); ;}
     break;
 
   case 141:
 
 /* Line 1455 of yacc.c  */
-#line 1338 "program_parse.y"
+#line 1349 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 142:
 
 /* Line 1455 of yacc.c  */
-#line 1341 "program_parse.y"
+#line 1352 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 143:
 
 /* Line 1455 of yacc.c  */
-#line 1342 "program_parse.y"
+#line 1353 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 144:
 
 /* Line 1455 of yacc.c  */
-#line 1343 "program_parse.y"
+#line 1354 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 145:
 
 /* Line 1455 of yacc.c  */
-#line 1344 "program_parse.y"
+#line 1355 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 146:
 
 /* Line 1455 of yacc.c  */
-#line 1345 "program_parse.y"
+#line 1356 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 147:
 
 /* Line 1455 of yacc.c  */
-#line 1346 "program_parse.y"
+#line 1357 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 148:
 
 /* Line 1455 of yacc.c  */
-#line 1347 "program_parse.y"
+#line 1358 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 149:
 
 /* Line 1455 of yacc.c  */
-#line 1348 "program_parse.y"
+#line 1359 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 150:
 
 /* Line 1455 of yacc.c  */
-#line 1349 "program_parse.y"
+#line 1360 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 151:
 
 /* Line 1455 of yacc.c  */
-#line 1350 "program_parse.y"
+#line 1361 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 152:
 
 /* Line 1455 of yacc.c  */
-#line 1351 "program_parse.y"
+#line 1362 "program_parse.y"
     { memcpy((yyval.state), (yyvsp[(2) - (2)].state), sizeof((yyval.state))); ;}
     break;
 
   case 153:
 
 /* Line 1455 of yacc.c  */
-#line 1355 "program_parse.y"
+#line 1366 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_MATERIAL;
@@ -3645,7 +3656,7 @@ yyreduce:
   case 154:
 
 /* Line 1455 of yacc.c  */
-#line 1364 "program_parse.y"
+#line 1375 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -3654,7 +3665,7 @@ yyreduce:
   case 155:
 
 /* Line 1455 of yacc.c  */
-#line 1368 "program_parse.y"
+#line 1379 "program_parse.y"
     {
 	   (yyval.integer) = STATE_EMISSION;
 	;}
@@ -3663,7 +3674,7 @@ yyreduce:
   case 156:
 
 /* Line 1455 of yacc.c  */
-#line 1372 "program_parse.y"
+#line 1383 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SHININESS;
 	;}
@@ -3672,7 +3683,7 @@ yyreduce:
   case 157:
 
 /* Line 1455 of yacc.c  */
-#line 1378 "program_parse.y"
+#line 1389 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHT;
@@ -3684,7 +3695,7 @@ yyreduce:
   case 158:
 
 /* Line 1455 of yacc.c  */
-#line 1387 "program_parse.y"
+#line 1398 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -3693,7 +3704,7 @@ yyreduce:
   case 159:
 
 /* Line 1455 of yacc.c  */
-#line 1391 "program_parse.y"
+#line 1402 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POSITION;
 	;}
@@ -3702,7 +3713,7 @@ yyreduce:
   case 160:
 
 /* Line 1455 of yacc.c  */
-#line 1395 "program_parse.y"
+#line 1406 "program_parse.y"
     {
 	   if (!state->ctx->Extensions.EXT_point_parameters) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "GL_ARB_point_parameters not supported");
@@ -3716,7 +3727,7 @@ yyreduce:
   case 161:
 
 /* Line 1455 of yacc.c  */
-#line 1404 "program_parse.y"
+#line 1415 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (2)].integer);
 	;}
@@ -3725,7 +3736,7 @@ yyreduce:
   case 162:
 
 /* Line 1455 of yacc.c  */
-#line 1408 "program_parse.y"
+#line 1419 "program_parse.y"
     {
 	   (yyval.integer) = STATE_HALF_VECTOR;
 	;}
@@ -3734,7 +3745,7 @@ yyreduce:
   case 163:
 
 /* Line 1455 of yacc.c  */
-#line 1414 "program_parse.y"
+#line 1425 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SPOT_DIRECTION;
 	;}
@@ -3743,7 +3754,7 @@ yyreduce:
   case 164:
 
 /* Line 1455 of yacc.c  */
-#line 1420 "program_parse.y"
+#line 1431 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].state)[1];
@@ -3753,7 +3764,7 @@ yyreduce:
   case 165:
 
 /* Line 1455 of yacc.c  */
-#line 1427 "program_parse.y"
+#line 1438 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTMODEL_AMBIENT;
@@ -3763,7 +3774,7 @@ yyreduce:
   case 166:
 
 /* Line 1455 of yacc.c  */
-#line 1432 "program_parse.y"
+#line 1443 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTMODEL_SCENECOLOR;
@@ -3774,7 +3785,7 @@ yyreduce:
   case 167:
 
 /* Line 1455 of yacc.c  */
-#line 1440 "program_parse.y"
+#line 1451 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_LIGHTPROD;
@@ -3787,7 +3798,7 @@ yyreduce:
   case 169:
 
 /* Line 1455 of yacc.c  */
-#line 1452 "program_parse.y"
+#line 1463 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(3) - (3)].integer);
@@ -3798,7 +3809,7 @@ yyreduce:
   case 170:
 
 /* Line 1455 of yacc.c  */
-#line 1460 "program_parse.y"
+#line 1471 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXENV_COLOR;
 	;}
@@ -3807,7 +3818,7 @@ yyreduce:
   case 171:
 
 /* Line 1455 of yacc.c  */
-#line 1466 "program_parse.y"
+#line 1477 "program_parse.y"
     {
 	   (yyval.integer) = STATE_AMBIENT;
 	;}
@@ -3816,7 +3827,7 @@ yyreduce:
   case 172:
 
 /* Line 1455 of yacc.c  */
-#line 1470 "program_parse.y"
+#line 1481 "program_parse.y"
     {
 	   (yyval.integer) = STATE_DIFFUSE;
 	;}
@@ -3825,7 +3836,7 @@ yyreduce:
   case 173:
 
 /* Line 1455 of yacc.c  */
-#line 1474 "program_parse.y"
+#line 1485 "program_parse.y"
     {
 	   (yyval.integer) = STATE_SPECULAR;
 	;}
@@ -3834,7 +3845,7 @@ yyreduce:
   case 174:
 
 /* Line 1455 of yacc.c  */
-#line 1480 "program_parse.y"
+#line 1491 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxLights) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid light selector");
@@ -3848,7 +3859,7 @@ yyreduce:
   case 175:
 
 /* Line 1455 of yacc.c  */
-#line 1491 "program_parse.y"
+#line 1502 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_TEXGEN;
@@ -3860,7 +3871,7 @@ yyreduce:
   case 176:
 
 /* Line 1455 of yacc.c  */
-#line 1500 "program_parse.y"
+#line 1511 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_S;
 	;}
@@ -3869,7 +3880,7 @@ yyreduce:
   case 177:
 
 /* Line 1455 of yacc.c  */
-#line 1504 "program_parse.y"
+#line 1515 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_OBJECT_S;
 	;}
@@ -3878,7 +3889,7 @@ yyreduce:
   case 178:
 
 /* Line 1455 of yacc.c  */
-#line 1509 "program_parse.y"
+#line 1520 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_S - STATE_TEXGEN_EYE_S;
 	;}
@@ -3887,7 +3898,7 @@ yyreduce:
   case 179:
 
 /* Line 1455 of yacc.c  */
-#line 1513 "program_parse.y"
+#line 1524 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_T - STATE_TEXGEN_EYE_S;
 	;}
@@ -3896,7 +3907,7 @@ yyreduce:
   case 180:
 
 /* Line 1455 of yacc.c  */
-#line 1517 "program_parse.y"
+#line 1528 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_R - STATE_TEXGEN_EYE_S;
 	;}
@@ -3905,7 +3916,7 @@ yyreduce:
   case 181:
 
 /* Line 1455 of yacc.c  */
-#line 1521 "program_parse.y"
+#line 1532 "program_parse.y"
     {
 	   (yyval.integer) = STATE_TEXGEN_EYE_Q - STATE_TEXGEN_EYE_S;
 	;}
@@ -3914,7 +3925,7 @@ yyreduce:
   case 182:
 
 /* Line 1455 of yacc.c  */
-#line 1527 "program_parse.y"
+#line 1538 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].integer);
@@ -3924,7 +3935,7 @@ yyreduce:
   case 183:
 
 /* Line 1455 of yacc.c  */
-#line 1534 "program_parse.y"
+#line 1545 "program_parse.y"
     {
 	   (yyval.integer) = STATE_FOG_COLOR;
 	;}
@@ -3933,7 +3944,7 @@ yyreduce:
   case 184:
 
 /* Line 1455 of yacc.c  */
-#line 1538 "program_parse.y"
+#line 1549 "program_parse.y"
     {
 	   (yyval.integer) = STATE_FOG_PARAMS;
 	;}
@@ -3942,7 +3953,7 @@ yyreduce:
   case 185:
 
 /* Line 1455 of yacc.c  */
-#line 1544 "program_parse.y"
+#line 1555 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_CLIPPLANE;
@@ -3953,7 +3964,7 @@ yyreduce:
   case 186:
 
 /* Line 1455 of yacc.c  */
-#line 1552 "program_parse.y"
+#line 1563 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxClipPlanes) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid clip plane selector");
@@ -3967,7 +3978,7 @@ yyreduce:
   case 187:
 
 /* Line 1455 of yacc.c  */
-#line 1563 "program_parse.y"
+#line 1574 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = (yyvsp[(2) - (2)].integer);
@@ -3977,7 +3988,7 @@ yyreduce:
   case 188:
 
 /* Line 1455 of yacc.c  */
-#line 1570 "program_parse.y"
+#line 1581 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POINT_SIZE;
 	;}
@@ -3986,7 +3997,7 @@ yyreduce:
   case 189:
 
 /* Line 1455 of yacc.c  */
-#line 1574 "program_parse.y"
+#line 1585 "program_parse.y"
     {
 	   (yyval.integer) = STATE_POINT_ATTENUATION;
 	;}
@@ -3995,7 +4006,7 @@ yyreduce:
   case 190:
 
 /* Line 1455 of yacc.c  */
-#line 1580 "program_parse.y"
+#line 1591 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (5)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(1) - (5)].state)[1];
@@ -4008,7 +4019,7 @@ yyreduce:
   case 191:
 
 /* Line 1455 of yacc.c  */
-#line 1590 "program_parse.y"
+#line 1601 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (2)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(1) - (2)].state)[1];
@@ -4021,7 +4032,7 @@ yyreduce:
   case 192:
 
 /* Line 1455 of yacc.c  */
-#line 1600 "program_parse.y"
+#line 1611 "program_parse.y"
     {
 	   (yyval.state)[2] = 0;
 	   (yyval.state)[3] = 3;
@@ -4031,7 +4042,7 @@ yyreduce:
   case 193:
 
 /* Line 1455 of yacc.c  */
-#line 1605 "program_parse.y"
+#line 1616 "program_parse.y"
     {
 	   /* It seems logical that the matrix row range specifier would have
 	    * to specify a range or more than one row (i.e., $5 > $3).
@@ -4052,7 +4063,7 @@ yyreduce:
   case 194:
 
 /* Line 1455 of yacc.c  */
-#line 1623 "program_parse.y"
+#line 1634 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(2) - (3)].state)[0];
 	   (yyval.state)[1] = (yyvsp[(2) - (3)].state)[1];
@@ -4063,7 +4074,7 @@ yyreduce:
   case 195:
 
 /* Line 1455 of yacc.c  */
-#line 1631 "program_parse.y"
+#line 1642 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -4072,7 +4083,7 @@ yyreduce:
   case 196:
 
 /* Line 1455 of yacc.c  */
-#line 1635 "program_parse.y"
+#line 1646 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(1) - (1)].integer);
 	;}
@@ -4081,7 +4092,7 @@ yyreduce:
   case 197:
 
 /* Line 1455 of yacc.c  */
-#line 1641 "program_parse.y"
+#line 1652 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_INVERSE;
 	;}
@@ -4090,7 +4101,7 @@ yyreduce:
   case 198:
 
 /* Line 1455 of yacc.c  */
-#line 1645 "program_parse.y"
+#line 1656 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_TRANSPOSE;
 	;}
@@ -4099,7 +4110,7 @@ yyreduce:
   case 199:
 
 /* Line 1455 of yacc.c  */
-#line 1649 "program_parse.y"
+#line 1660 "program_parse.y"
     {
 	   (yyval.integer) = STATE_MATRIX_INVTRANS;
 	;}
@@ -4108,7 +4119,7 @@ yyreduce:
   case 200:
 
 /* Line 1455 of yacc.c  */
-#line 1655 "program_parse.y"
+#line 1666 "program_parse.y"
     {
 	   if ((yyvsp[(1) - (1)].integer) > 3) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid matrix row reference");
@@ -4122,7 +4133,7 @@ yyreduce:
   case 201:
 
 /* Line 1455 of yacc.c  */
-#line 1666 "program_parse.y"
+#line 1677 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_MODELVIEW_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].integer);
@@ -4132,7 +4143,7 @@ yyreduce:
   case 202:
 
 /* Line 1455 of yacc.c  */
-#line 1671 "program_parse.y"
+#line 1682 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_PROJECTION_MATRIX;
 	   (yyval.state)[1] = 0;
@@ -4142,7 +4153,7 @@ yyreduce:
   case 203:
 
 /* Line 1455 of yacc.c  */
-#line 1676 "program_parse.y"
+#line 1687 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_MVP_MATRIX;
 	   (yyval.state)[1] = 0;
@@ -4152,7 +4163,7 @@ yyreduce:
   case 204:
 
 /* Line 1455 of yacc.c  */
-#line 1681 "program_parse.y"
+#line 1692 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_TEXTURE_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(2) - (2)].integer);
@@ -4162,7 +4173,7 @@ yyreduce:
   case 205:
 
 /* Line 1455 of yacc.c  */
-#line 1686 "program_parse.y"
+#line 1697 "program_parse.y"
     {
 	   yyerror(& (yylsp[(1) - (4)]), state, "GL_ARB_matrix_palette not supported");
 	   YYERROR;
@@ -4172,7 +4183,7 @@ yyreduce:
   case 206:
 
 /* Line 1455 of yacc.c  */
-#line 1691 "program_parse.y"
+#line 1702 "program_parse.y"
     {
 	   (yyval.state)[0] = STATE_PROGRAM_MATRIX;
 	   (yyval.state)[1] = (yyvsp[(3) - (4)].integer);
@@ -4182,7 +4193,7 @@ yyreduce:
   case 207:
 
 /* Line 1455 of yacc.c  */
-#line 1698 "program_parse.y"
+#line 1709 "program_parse.y"
     {
 	   (yyval.integer) = 0;
 	;}
@@ -4191,7 +4202,7 @@ yyreduce:
   case 208:
 
 /* Line 1455 of yacc.c  */
-#line 1702 "program_parse.y"
+#line 1713 "program_parse.y"
     {
 	   (yyval.integer) = (yyvsp[(2) - (3)].integer);
 	;}
@@ -4200,7 +4211,7 @@ yyreduce:
   case 209:
 
 /* Line 1455 of yacc.c  */
-#line 1707 "program_parse.y"
+#line 1718 "program_parse.y"
     {
 	   /* Since GL_ARB_vertex_blend isn't supported, only modelview matrix
 	    * zero is valid.
@@ -4217,7 +4228,7 @@ yyreduce:
   case 210:
 
 /* Line 1455 of yacc.c  */
-#line 1720 "program_parse.y"
+#line 1731 "program_parse.y"
     {
 	   /* Since GL_ARB_matrix_palette isn't supported, just let any value
 	    * through here.  The error will be generated later.
@@ -4229,7 +4240,7 @@ yyreduce:
   case 211:
 
 /* Line 1455 of yacc.c  */
-#line 1728 "program_parse.y"
+#line 1739 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxProgramMatrices) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid program matrix selector");
@@ -4243,7 +4254,7 @@ yyreduce:
   case 212:
 
 /* Line 1455 of yacc.c  */
-#line 1739 "program_parse.y"
+#line 1750 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = STATE_DEPTH_RANGE;
@@ -4253,7 +4264,7 @@ yyreduce:
   case 217:
 
 /* Line 1455 of yacc.c  */
-#line 1751 "program_parse.y"
+#line 1762 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4266,7 +4277,7 @@ yyreduce:
   case 218:
 
 /* Line 1455 of yacc.c  */
-#line 1761 "program_parse.y"
+#line 1772 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (1)].integer);
 	   (yyval.state)[1] = (yyvsp[(1) - (1)].integer);
@@ -4276,7 +4287,7 @@ yyreduce:
   case 219:
 
 /* Line 1455 of yacc.c  */
-#line 1766 "program_parse.y"
+#line 1777 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (3)].integer);
 	   (yyval.state)[1] = (yyvsp[(3) - (3)].integer);
@@ -4286,7 +4297,7 @@ yyreduce:
   case 220:
 
 /* Line 1455 of yacc.c  */
-#line 1773 "program_parse.y"
+#line 1784 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4299,7 +4310,7 @@ yyreduce:
   case 221:
 
 /* Line 1455 of yacc.c  */
-#line 1783 "program_parse.y"
+#line 1794 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4312,7 +4323,7 @@ yyreduce:
   case 222:
 
 /* Line 1455 of yacc.c  */
-#line 1792 "program_parse.y"
+#line 1803 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (1)].integer);
 	   (yyval.state)[1] = (yyvsp[(1) - (1)].integer);
@@ -4322,7 +4333,7 @@ yyreduce:
   case 223:
 
 /* Line 1455 of yacc.c  */
-#line 1797 "program_parse.y"
+#line 1808 "program_parse.y"
     {
 	   (yyval.state)[0] = (yyvsp[(1) - (3)].integer);
 	   (yyval.state)[1] = (yyvsp[(3) - (3)].integer);
@@ -4332,7 +4343,7 @@ yyreduce:
   case 224:
 
 /* Line 1455 of yacc.c  */
-#line 1804 "program_parse.y"
+#line 1815 "program_parse.y"
     {
 	   memset((yyval.state), 0, sizeof((yyval.state)));
 	   (yyval.state)[0] = state->state_param_enum;
@@ -4345,7 +4356,7 @@ yyreduce:
   case 225:
 
 /* Line 1455 of yacc.c  */
-#line 1814 "program_parse.y"
+#line 1825 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxEnvParams) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid environment parameter reference");
@@ -4358,7 +4369,7 @@ yyreduce:
   case 226:
 
 /* Line 1455 of yacc.c  */
-#line 1824 "program_parse.y"
+#line 1835 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxLocalParams) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid local parameter reference");
@@ -4371,7 +4382,7 @@ yyreduce:
   case 231:
 
 /* Line 1455 of yacc.c  */
-#line 1839 "program_parse.y"
+#line 1850 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(1) - (1)].real);
@@ -4384,7 +4395,7 @@ yyreduce:
   case 232:
 
 /* Line 1455 of yacc.c  */
-#line 1849 "program_parse.y"
+#line 1860 "program_parse.y"
     {
 	   (yyval.vector).count = 1;
 	   (yyval.vector).data[0] = (yyvsp[(1) - (1)].real);
@@ -4397,7 +4408,7 @@ yyreduce:
   case 233:
 
 /* Line 1455 of yacc.c  */
-#line 1857 "program_parse.y"
+#line 1868 "program_parse.y"
     {
 	   (yyval.vector).count = 1;
 	   (yyval.vector).data[0] = (float) (yyvsp[(1) - (1)].integer);
@@ -4410,7 +4421,7 @@ yyreduce:
   case 234:
 
 /* Line 1455 of yacc.c  */
-#line 1867 "program_parse.y"
+#line 1878 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (3)].real);
@@ -4423,7 +4434,7 @@ yyreduce:
   case 235:
 
 /* Line 1455 of yacc.c  */
-#line 1875 "program_parse.y"
+#line 1886 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (5)].real);
@@ -4436,7 +4447,7 @@ yyreduce:
   case 236:
 
 /* Line 1455 of yacc.c  */
-#line 1884 "program_parse.y"
+#line 1895 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (7)].real);
@@ -4449,7 +4460,7 @@ yyreduce:
   case 237:
 
 /* Line 1455 of yacc.c  */
-#line 1893 "program_parse.y"
+#line 1904 "program_parse.y"
     {
 	   (yyval.vector).count = 4;
 	   (yyval.vector).data[0] = (yyvsp[(2) - (9)].real);
@@ -4462,7 +4473,7 @@ yyreduce:
   case 238:
 
 /* Line 1455 of yacc.c  */
-#line 1903 "program_parse.y"
+#line 1914 "program_parse.y"
     {
 	   (yyval.real) = ((yyvsp[(1) - (2)].negate)) ? -(yyvsp[(2) - (2)].real) : (yyvsp[(2) - (2)].real);
 	;}
@@ -4471,7 +4482,7 @@ yyreduce:
   case 239:
 
 /* Line 1455 of yacc.c  */
-#line 1907 "program_parse.y"
+#line 1918 "program_parse.y"
     {
 	   (yyval.real) = (float)(((yyvsp[(1) - (2)].negate)) ? -(yyvsp[(2) - (2)].integer) : (yyvsp[(2) - (2)].integer));
 	;}
@@ -4480,35 +4491,35 @@ yyreduce:
   case 240:
 
 /* Line 1455 of yacc.c  */
-#line 1912 "program_parse.y"
+#line 1923 "program_parse.y"
     { (yyval.negate) = FALSE; ;}
     break;
 
   case 241:
 
 /* Line 1455 of yacc.c  */
-#line 1913 "program_parse.y"
+#line 1924 "program_parse.y"
     { (yyval.negate) = TRUE;  ;}
     break;
 
   case 242:
 
 /* Line 1455 of yacc.c  */
-#line 1914 "program_parse.y"
+#line 1925 "program_parse.y"
     { (yyval.negate) = FALSE; ;}
     break;
 
   case 243:
 
 /* Line 1455 of yacc.c  */
-#line 1917 "program_parse.y"
+#line 1928 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (2)].integer); ;}
     break;
 
   case 245:
 
 /* Line 1455 of yacc.c  */
-#line 1921 "program_parse.y"
+#line 1932 "program_parse.y"
     {
 	   /* NV_fragment_program_option defines the size qualifiers in a
 	    * fairly broken way.  "SHORT" or "LONG" can optionally be used
@@ -4547,7 +4558,7 @@ yyreduce:
   case 246:
 
 /* Line 1455 of yacc.c  */
-#line 1955 "program_parse.y"
+#line 1966 "program_parse.y"
     {
 	;}
     break;
@@ -4555,14 +4566,14 @@ yyreduce:
   case 247:
 
 /* Line 1455 of yacc.c  */
-#line 1959 "program_parse.y"
+#line 1970 "program_parse.y"
     { (yyval.integer) = (yyvsp[(1) - (1)].integer); ;}
     break;
 
   case 249:
 
 /* Line 1455 of yacc.c  */
-#line 1963 "program_parse.y"
+#line 1974 "program_parse.y"
     {
 	   if (!declare_variable(state, (yyvsp[(3) - (3)].string), (yyvsp[(0) - (3)].integer), & (yylsp[(3) - (3)]))) {
 	      free((yyvsp[(3) - (3)].string));
@@ -4574,7 +4585,7 @@ yyreduce:
   case 250:
 
 /* Line 1455 of yacc.c  */
-#line 1970 "program_parse.y"
+#line 1981 "program_parse.y"
     {
 	   if (!declare_variable(state, (yyvsp[(1) - (1)].string), (yyvsp[(0) - (1)].integer), & (yylsp[(1) - (1)]))) {
 	      free((yyvsp[(1) - (1)].string));
@@ -4586,7 +4597,7 @@ yyreduce:
   case 251:
 
 /* Line 1455 of yacc.c  */
-#line 1979 "program_parse.y"
+#line 1990 "program_parse.y"
     {
 	   struct asm_symbol *const s =
 	      declare_variable(state, (yyvsp[(3) - (5)].string), at_output, & (yylsp[(3) - (5)]));
@@ -4603,7 +4614,7 @@ yyreduce:
   case 252:
 
 /* Line 1455 of yacc.c  */
-#line 1993 "program_parse.y"
+#line 2004 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_HPOS;
@@ -4617,7 +4628,7 @@ yyreduce:
   case 253:
 
 /* Line 1455 of yacc.c  */
-#line 2002 "program_parse.y"
+#line 2013 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_FOGC;
@@ -4631,7 +4642,7 @@ yyreduce:
   case 254:
 
 /* Line 1455 of yacc.c  */
-#line 2011 "program_parse.y"
+#line 2022 "program_parse.y"
     {
 	   (yyval.result) = (yyvsp[(2) - (2)].result);
 	;}
@@ -4640,7 +4651,7 @@ yyreduce:
   case 255:
 
 /* Line 1455 of yacc.c  */
-#line 2015 "program_parse.y"
+#line 2026 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_PSIZ;
@@ -4654,7 +4665,7 @@ yyreduce:
   case 256:
 
 /* Line 1455 of yacc.c  */
-#line 2024 "program_parse.y"
+#line 2035 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.result) = VERT_RESULT_TEX0 + (yyvsp[(3) - (3)].integer);
@@ -4668,7 +4679,7 @@ yyreduce:
   case 257:
 
 /* Line 1455 of yacc.c  */
-#line 2033 "program_parse.y"
+#line 2044 "program_parse.y"
     {
 	   if (state->mode == ARB_fragment) {
 	      (yyval.result) = FRAG_RESULT_DEPTH;
@@ -4682,7 +4693,7 @@ yyreduce:
   case 258:
 
 /* Line 1455 of yacc.c  */
-#line 2044 "program_parse.y"
+#line 2055 "program_parse.y"
     {
 	   (yyval.result) = (yyvsp[(2) - (3)].integer) + (yyvsp[(3) - (3)].integer);
 	;}
@@ -4691,7 +4702,7 @@ yyreduce:
   case 259:
 
 /* Line 1455 of yacc.c  */
-#line 2050 "program_parse.y"
+#line 2061 "program_parse.y"
     {
 	   (yyval.integer) = (state->mode == ARB_vertex)
 	      ? VERT_RESULT_COL0
@@ -4702,7 +4713,7 @@ yyreduce:
   case 260:
 
 /* Line 1455 of yacc.c  */
-#line 2056 "program_parse.y"
+#line 2067 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = VERT_RESULT_COL0;
@@ -4716,7 +4727,7 @@ yyreduce:
   case 261:
 
 /* Line 1455 of yacc.c  */
-#line 2065 "program_parse.y"
+#line 2076 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = VERT_RESULT_BFC0;
@@ -4730,7 +4741,7 @@ yyreduce:
   case 262:
 
 /* Line 1455 of yacc.c  */
-#line 2076 "program_parse.y"
+#line 2087 "program_parse.y"
     {
 	   (yyval.integer) = 0; 
 	;}
@@ -4739,7 +4750,7 @@ yyreduce:
   case 263:
 
 /* Line 1455 of yacc.c  */
-#line 2080 "program_parse.y"
+#line 2091 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = 0;
@@ -4753,7 +4764,7 @@ yyreduce:
   case 264:
 
 /* Line 1455 of yacc.c  */
-#line 2089 "program_parse.y"
+#line 2100 "program_parse.y"
     {
 	   if (state->mode == ARB_vertex) {
 	      (yyval.integer) = 1;
@@ -4767,91 +4778,91 @@ yyreduce:
   case 265:
 
 /* Line 1455 of yacc.c  */
-#line 2099 "program_parse.y"
+#line 2110 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 266:
 
 /* Line 1455 of yacc.c  */
-#line 2100 "program_parse.y"
+#line 2111 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 267:
 
 /* Line 1455 of yacc.c  */
-#line 2101 "program_parse.y"
+#line 2112 "program_parse.y"
     { (yyval.integer) = 1; ;}
     break;
 
   case 268:
 
 /* Line 1455 of yacc.c  */
-#line 2104 "program_parse.y"
+#line 2115 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 269:
 
 /* Line 1455 of yacc.c  */
-#line 2105 "program_parse.y"
+#line 2116 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 270:
 
 /* Line 1455 of yacc.c  */
-#line 2106 "program_parse.y"
+#line 2117 "program_parse.y"
     { (yyval.integer) = 1; ;}
     break;
 
   case 271:
 
 /* Line 1455 of yacc.c  */
-#line 2109 "program_parse.y"
+#line 2120 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 272:
 
 /* Line 1455 of yacc.c  */
-#line 2110 "program_parse.y"
+#line 2121 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 273:
 
 /* Line 1455 of yacc.c  */
-#line 2113 "program_parse.y"
+#line 2124 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 274:
 
 /* Line 1455 of yacc.c  */
-#line 2114 "program_parse.y"
+#line 2125 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 275:
 
 /* Line 1455 of yacc.c  */
-#line 2117 "program_parse.y"
+#line 2128 "program_parse.y"
     { (yyval.integer) = 0; ;}
     break;
 
   case 276:
 
 /* Line 1455 of yacc.c  */
-#line 2118 "program_parse.y"
+#line 2129 "program_parse.y"
     { (yyval.integer) = (yyvsp[(2) - (3)].integer); ;}
     break;
 
   case 277:
 
 /* Line 1455 of yacc.c  */
-#line 2122 "program_parse.y"
+#line 2133 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureCoordUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture coordinate unit selector");
@@ -4865,7 +4876,7 @@ yyreduce:
   case 278:
 
 /* Line 1455 of yacc.c  */
-#line 2133 "program_parse.y"
+#line 2144 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureImageUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture image unit selector");
@@ -4879,7 +4890,7 @@ yyreduce:
   case 279:
 
 /* Line 1455 of yacc.c  */
-#line 2144 "program_parse.y"
+#line 2155 "program_parse.y"
     {
 	   if ((unsigned) (yyvsp[(1) - (1)].integer) >= state->MaxTextureUnits) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid texture unit selector");
@@ -4893,7 +4904,7 @@ yyreduce:
   case 280:
 
 /* Line 1455 of yacc.c  */
-#line 2155 "program_parse.y"
+#line 2166 "program_parse.y"
     {
 	   struct asm_symbol *exist = (struct asm_symbol *)
 	      _mesa_symbol_table_find_symbol(state->st, 0, (yyvsp[(2) - (4)].string));
@@ -4922,7 +4933,7 @@ yyreduce:
 
 
 /* Line 1455 of yacc.c  */
-#line 4926 "program_parse.tab.c"
+#line 4937 "program_parse.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -5141,7 +5152,7 @@ yyreturn:
 
 
 /* Line 1675 of yacc.c  */
-#line 2184 "program_parse.y"
+#line 2195 "program_parse.y"
 
 
 void
@@ -5248,7 +5259,9 @@ set_dst_reg(struct prog_dst_register *r, gl_register_file file, GLint index)
    const GLint maxIndex = 1 << INST_INDEX_BITS;
    const GLint minIndex = 0;
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
+   (void) maxIndex;
    ASSERT(file == PROGRAM_TEMPORARY ||
 	  file == PROGRAM_ADDRESS ||
 	  file == PROGRAM_OUTPUT);
@@ -5271,19 +5284,31 @@ init_src_reg(struct asm_src_register *r)
 }
 
 
-/** Like init_src_reg() but set the File and Index fields. */
+/** Like init_src_reg() but set the File and Index fields.
+ * \return GL_TRUE if a valid src register, GL_FALSE otherwise
+ */
 void
 set_src_reg(struct asm_src_register *r, gl_register_file file, GLint index)
 {
+   set_src_reg_swz(r, file, index, SWIZZLE_XYZW);
+}
+
+
+void
+set_src_reg_swz(struct asm_src_register *r, gl_register_file file, GLint index,
+                GLuint swizzle)
+{
    const GLint maxIndex = (1 << INST_INDEX_BITS) - 1;
    const GLint minIndex = -(1 << INST_INDEX_BITS);
+   ASSERT(file < PROGRAM_FILE_MAX);
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
-   ASSERT(file < PROGRAM_FILE_MAX);
+   (void) maxIndex;
    memset(r, 0, sizeof(*r));
    r->Base.File = file;
    r->Base.Index = index;
-   r->Base.Swizzle = SWIZZLE_NOOP;
+   r->Base.Swizzle = swizzle;
    r->Symbol = NULL;
 }
 
@@ -5415,15 +5440,20 @@ initialize_symbol_from_state(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
+
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -5447,9 +5477,12 @@ initialize_symbol_from_param(struct gl_program *prog,
    assert((state_tokens[1] == STATE_ENV)
 	  || (state_tokens[1] == STATE_LOCAL));
 
+   /*
+    * The param type is STATE_VAR.  The program parameter entry will
+    * effectively be a pointer into the LOCAL or ENV parameter array.
+    */
    param_var->type = at_param;
-   param_var->param_binding_type = (state_tokens[1] == STATE_ENV)
-     ? PROGRAM_ENV_PARAM : PROGRAM_LOCAL_PARAM;
+   param_var->param_binding_type = PROGRAM_STATE_VAR;
 
    /* If we are adding a STATE_ENV or STATE_LOCAL that has multiple elements,
     * we need to unroll it and call add_state_reference() for each row
@@ -5463,15 +5496,19 @@ initialize_symbol_from_param(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -5479,20 +5516,34 @@ initialize_symbol_from_param(struct gl_program *prog,
 }
 
 
+/**
+ * Put a float/vector constant/literal into the parameter list.
+ * \param param_var  returns info about the parameter/constant's location,
+ *                   binding, type, etc.
+ * \param vec  the vector/constant to add
+ * \param allowSwizzle  if true, try to consolidate constants which only differ
+ *                      by a swizzle.  We don't want to do this when building
+ *                      arrays of constants that may be indexed indirectly.
+ * \return index of the constant in the parameter list.
+ */
 int
 initialize_symbol_from_const(struct gl_program *prog,
 			     struct asm_symbol *param_var, 
-			     const struct asm_vector *vec)
+			     const struct asm_vector *vec,
+                             GLboolean allowSwizzle)
 {
-   const int idx = _mesa_add_parameter(prog->Parameters, PROGRAM_CONSTANT,
-				       NULL, vec->count, GL_NONE, vec->data,
-				       NULL, 0x0);
+   unsigned swizzle;
+   const int idx = _mesa_add_unnamed_constant(prog->Parameters,
+                                              vec->data, vec->count,
+                                              allowSwizzle ? &swizzle : NULL);
 
    param_var->type = at_param;
    param_var->param_binding_type = PROGRAM_CONSTANT;
 
-   if (param_var->param_binding_begin == ~0U)
+   if (param_var->param_binding_begin == ~0U) {
       param_var->param_binding_begin = idx;
+      param_var->param_binding_swizzle = allowSwizzle ? swizzle : SWIZZLE_XYZW;
+   }
    param_var->param_binding_length++;
 
    return idx;
diff --git a/src/mesa/shader/program_parse.tab.h b/src/mesa/shader/program_parse.tab.h
index 406100c..045241d 100644
--- a/src/mesa/shader/program_parse.tab.h
+++ b/src/mesa/shader/program_parse.tab.h
@@ -154,7 +154,7 @@ typedef union YYSTYPE
 {
 
 /* Line 1676 of yacc.c  */
-#line 122 "program_parse.y"
+#line 126 "program_parse.y"
 
    struct asm_instruction *inst;
    struct asm_symbol *sym;
diff --git a/src/mesa/shader/program_parse.y b/src/mesa/shader/program_parse.y
index 8ca6f98..5c5d8d7 100644
--- a/src/mesa/shader/program_parse.y
+++ b/src/mesa/shader/program_parse.y
@@ -52,7 +52,8 @@ static int initialize_symbol_from_param(struct gl_program *prog,
     struct asm_symbol *param_var, const gl_state_index tokens[STATE_LENGTH]);
 
 static int initialize_symbol_from_const(struct gl_program *prog,
-    struct asm_symbol *param_var, const struct asm_vector *vec);
+    struct asm_symbol *param_var, const struct asm_vector *vec,
+    GLboolean allowSwizzle);
 
 static int yyparse(struct asm_parser_state *state);
 
@@ -74,6 +75,9 @@ static void init_src_reg(struct asm_src_register *r);
 static void set_src_reg(struct asm_src_register *r,
                         gl_register_file file, GLint index);
 
+static void set_src_reg_swz(struct asm_src_register *r,
+                            gl_register_file file, GLint index, GLuint swizzle);
+
 static void asm_instruction_set_operands(struct asm_instruction *inst,
     const struct prog_dst_register *dst, const struct asm_src_register *src0,
     const struct asm_src_register *src1, const struct asm_src_register *src2);
@@ -586,9 +590,11 @@ scalarUse:  srcReg scalarSuffix
 
 	   memset(& temp_sym, 0, sizeof(temp_sym));
 	   temp_sym.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & temp_sym, & $1);
+	   initialize_symbol_from_const(state->prog, & temp_sym, & $1, GL_TRUE);
 
-	   set_src_reg(& $$, PROGRAM_CONSTANT, temp_sym.param_binding_begin);
+	   set_src_reg_swz(& $$, PROGRAM_CONSTANT,
+                           temp_sym.param_binding_begin,
+                           temp_sym.param_binding_swizzle);
 	}
 	;
 
@@ -790,7 +796,9 @@ srcReg: USED_IDENTIFIER /* temporaryReg | progParamSingle */
 	      set_src_reg(& $$, PROGRAM_TEMPORARY, s->temp_binding);
 	      break;
 	   case at_param:
-	      set_src_reg(& $$, s->param_binding_type, s->param_binding_begin);
+              set_src_reg_swz(& $$, s->param_binding_type,
+                              s->param_binding_begin,
+                              s->param_binding_swizzle);
 	      break;
 	   case at_attrib:
 	      set_src_reg(& $$, PROGRAM_INPUT, s->attrib_binding);
@@ -841,7 +849,8 @@ srcReg: USED_IDENTIFIER /* temporaryReg | progParamSingle */
            gl_register_file file = ($1.name != NULL) 
 	      ? $1.param_binding_type
 	      : PROGRAM_CONSTANT;
-	   set_src_reg(& $$, file, $1.param_binding_begin);
+           set_src_reg_swz(& $$, file, $1.param_binding_begin,
+                           $1.param_binding_swizzle);
 	}
 	;
 
@@ -1210,6 +1219,7 @@ PARAM_singleStmt: PARAM IDENTIFIER paramSingleInit
 	      s->param_binding_type = $3.param_binding_type;
 	      s->param_binding_begin = $3.param_binding_begin;
 	      s->param_binding_length = $3.param_binding_length;
+              s->param_binding_swizzle = SWIZZLE_XYZW;
 	      s->param_is_array = 0;
 	   }
 	}
@@ -1233,6 +1243,7 @@ PARAM_multipleStmt: PARAM IDENTIFIER '[' optArraySize ']' paramMultipleInit
 		 s->param_binding_type = $6.param_binding_type;
 		 s->param_binding_begin = $6.param_binding_begin;
 		 s->param_binding_length = $6.param_binding_length;
+                 s->param_binding_swizzle = SWIZZLE_XYZW;
 		 s->param_is_array = 1;
 	      }
 	   }
@@ -1290,7 +1301,7 @@ paramSingleItemDecl: stateSingleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_TRUE);
 	}
 	;
 
@@ -1310,7 +1321,7 @@ paramSingleItemUse: stateSingleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_TRUE);
 	}
 	;
 
@@ -1330,7 +1341,7 @@ paramMultipleItem: stateMultipleItem
 	{
 	   memset(& $$, 0, sizeof($$));
 	   $$.param_binding_begin = ~0;
-	   initialize_symbol_from_const(state->prog, & $$, & $1);
+	   initialize_symbol_from_const(state->prog, & $$, & $1, GL_FALSE);
 	}
 	;
 
@@ -2287,7 +2298,9 @@ set_dst_reg(struct prog_dst_register *r, gl_register_file file, GLint index)
    const GLint maxIndex = 1 << INST_INDEX_BITS;
    const GLint minIndex = 0;
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
+   (void) maxIndex;
    ASSERT(file == PROGRAM_TEMPORARY ||
 	  file == PROGRAM_ADDRESS ||
 	  file == PROGRAM_OUTPUT);
@@ -2310,19 +2323,31 @@ init_src_reg(struct asm_src_register *r)
 }
 
 
-/** Like init_src_reg() but set the File and Index fields. */
+/** Like init_src_reg() but set the File and Index fields.
+ * \return GL_TRUE if a valid src register, GL_FALSE otherwise
+ */
 void
 set_src_reg(struct asm_src_register *r, gl_register_file file, GLint index)
 {
+   set_src_reg_swz(r, file, index, SWIZZLE_XYZW);
+}
+
+
+void
+set_src_reg_swz(struct asm_src_register *r, gl_register_file file, GLint index,
+                GLuint swizzle)
+{
    const GLint maxIndex = (1 << INST_INDEX_BITS) - 1;
    const GLint minIndex = -(1 << INST_INDEX_BITS);
+   ASSERT(file < PROGRAM_FILE_MAX);
    ASSERT(index >= minIndex);
+   (void) minIndex;
    ASSERT(index <= maxIndex);
-   ASSERT(file < PROGRAM_FILE_MAX);
+   (void) maxIndex;
    memset(r, 0, sizeof(*r));
    r->Base.File = file;
    r->Base.Index = index;
-   r->Base.Swizzle = SWIZZLE_NOOP;
+   r->Base.Swizzle = swizzle;
    r->Symbol = NULL;
 }
 
@@ -2454,15 +2479,20 @@ initialize_symbol_from_state(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
+
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -2486,9 +2516,12 @@ initialize_symbol_from_param(struct gl_program *prog,
    assert((state_tokens[1] == STATE_ENV)
 	  || (state_tokens[1] == STATE_LOCAL));
 
+   /*
+    * The param type is STATE_VAR.  The program parameter entry will
+    * effectively be a pointer into the LOCAL or ENV parameter array.
+    */
    param_var->type = at_param;
-   param_var->param_binding_type = (state_tokens[1] == STATE_ENV)
-     ? PROGRAM_ENV_PARAM : PROGRAM_LOCAL_PARAM;
+   param_var->param_binding_type = PROGRAM_STATE_VAR;
 
    /* If we are adding a STATE_ENV or STATE_LOCAL that has multiple elements,
     * we need to unroll it and call add_state_reference() for each row
@@ -2502,15 +2535,19 @@ initialize_symbol_from_param(struct gl_program *prog,
 	 state_tokens[2] = state_tokens[3] = row;
 
 	 idx = add_state_reference(prog->Parameters, state_tokens);
-	 if (param_var->param_binding_begin == ~0U)
+	 if (param_var->param_binding_begin == ~0U) {
 	    param_var->param_binding_begin = idx;
+            param_var->param_binding_swizzle = SWIZZLE_XYZW;
+         }
 	 param_var->param_binding_length++;
       }
    }
    else {
       idx = add_state_reference(prog->Parameters, state_tokens);
-      if (param_var->param_binding_begin == ~0U)
+      if (param_var->param_binding_begin == ~0U) {
 	 param_var->param_binding_begin = idx;
+         param_var->param_binding_swizzle = SWIZZLE_XYZW;
+      }
       param_var->param_binding_length++;
    }
 
@@ -2518,20 +2555,34 @@ initialize_symbol_from_param(struct gl_program *prog,
 }
 
 
+/**
+ * Put a float/vector constant/literal into the parameter list.
+ * \param param_var  returns info about the parameter/constant's location,
+ *                   binding, type, etc.
+ * \param vec  the vector/constant to add
+ * \param allowSwizzle  if true, try to consolidate constants which only differ
+ *                      by a swizzle.  We don't want to do this when building
+ *                      arrays of constants that may be indexed indirectly.
+ * \return index of the constant in the parameter list.
+ */
 int
 initialize_symbol_from_const(struct gl_program *prog,
 			     struct asm_symbol *param_var, 
-			     const struct asm_vector *vec)
+			     const struct asm_vector *vec,
+                             GLboolean allowSwizzle)
 {
-   const int idx = _mesa_add_parameter(prog->Parameters, PROGRAM_CONSTANT,
-				       NULL, vec->count, GL_NONE, vec->data,
-				       NULL, 0x0);
+   unsigned swizzle;
+   const int idx = _mesa_add_unnamed_constant(prog->Parameters,
+                                              vec->data, vec->count,
+                                              allowSwizzle ? &swizzle : NULL);
 
    param_var->type = at_param;
    param_var->param_binding_type = PROGRAM_CONSTANT;
 
-   if (param_var->param_binding_begin == ~0U)
+   if (param_var->param_binding_begin == ~0U) {
       param_var->param_binding_begin = idx;
+      param_var->param_binding_swizzle = allowSwizzle ? swizzle : SWIZZLE_XYZW;
+   }
    param_var->param_binding_length++;
 
    return idx;
diff --git a/src/mesa/shader/program_parser.h b/src/mesa/shader/program_parser.h
index c170948..69396ca 100644
--- a/src/mesa/shader/program_parser.h
+++ b/src/mesa/shader/program_parser.h
@@ -56,6 +56,12 @@ struct asm_symbol {
     */
    unsigned param_binding_begin;
 
+   /**
+    * Constants put into the parameter list may be swizzled.  This
+    * field contain's the symbol's swizzle. (SWIZZLE_X/Y/Z/W)
+    */
+   unsigned param_binding_swizzle;
+
    /* This is how many entries in the the program_parameter_list we take up
     * with our state tokens or constants. Note that this is _not_ the same as
     * the number of param registers we eventually use.
diff --git a/src/mesa/shader/shader_api.c b/src/mesa/shader/shader_api.c
index 453cd39..e522d70 100644
--- a/src/mesa/shader/shader_api.c
+++ b/src/mesa/shader/shader_api.c
@@ -39,10 +39,8 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/hash.h"
-#include "main/macros.h"
 #include "shader/program.h"
 #include "shader/prog_parameter.h"
-#include "shader/prog_print.h"
 #include "shader/prog_statevars.h"
 #include "shader/prog_uniform.h"
 #include "shader/shader_api.h"
diff --git a/src/mesa/shader/slang/slang_builtin.c b/src/mesa/shader/slang/slang_builtin.c
index e580950..0a9f0b9 100644
--- a/src/mesa/shader/slang/slang_builtin.c
+++ b/src/mesa/shader/slang/slang_builtin.c
@@ -36,7 +36,6 @@
 #include "shader/prog_parameter.h"
 #include "shader/prog_statevars.h"
 #include "shader/slang/slang_ir.h"
-#include "shader/slang/slang_emit.h"
 #include "shader/slang/slang_builtin.h"
 
 
diff --git a/src/mesa/shader/slang/slang_codegen.c b/src/mesa/shader/slang/slang_codegen.c
index ee5a50c..372a9ac 100644
--- a/src/mesa/shader/slang/slang_codegen.c
+++ b/src/mesa/shader/slang/slang_codegen.c
@@ -3763,6 +3763,14 @@ _slang_gen_var_decl(slang_assemble_ctx *A, slang_variable *var,
 #endif
       }
 
+      if (var->type.qualifier == SLANG_QUAL_UNIFORM &&
+          !A->allow_uniform_initializers) {
+         slang_info_log_error(A->log,
+                              "initializer for uniform %s not allowed",
+                              varName);
+         return NULL;
+      }
+
       /* IR for the variable we're initializing */
       varRef = new_var(A, var);
       if (!varRef) {
@@ -4241,14 +4249,15 @@ _slang_gen_assignment(slang_assemble_ctx * A, slang_operation *oper)
 
    if (oper->children[0].type == SLANG_OPER_IDENTIFIER) {
       /* Check that var is writeable */
+      const char *varName = (char *) oper->children[0].a_id;
       slang_variable *var
          = _slang_variable_locate(oper->children[0].locals,
                                   oper->children[0].a_id, GL_TRUE);
       if (!var) {
-         slang_info_log_error(A->log, "undefined variable '%s'",
-                              (char *) oper->children[0].a_id);
+         slang_info_log_error(A->log, "undefined variable '%s'", varName);
          return NULL;
       }
+
       if (var->type.qualifier == SLANG_QUAL_CONST ||
           var->type.qualifier == SLANG_QUAL_ATTRIBUTE ||
           var->type.qualifier == SLANG_QUAL_UNIFORM ||
@@ -4256,7 +4265,7 @@ _slang_gen_assignment(slang_assemble_ctx * A, slang_operation *oper)
            A->program->Target == GL_FRAGMENT_PROGRAM_ARB)) {
          slang_info_log_error(A->log,
                               "illegal assignment to read-only variable '%s'",
-                              (char *) oper->children[0].a_id);
+                              varName);
          return NULL;
       }
 
diff --git a/src/mesa/shader/slang/slang_codegen.h b/src/mesa/shader/slang/slang_codegen.h
index ee3be55..461633f 100644
--- a/src/mesa/shader/slang/slang_codegen.h
+++ b/src/mesa/shader/slang/slang_codegen.h
@@ -42,6 +42,7 @@ typedef struct slang_assemble_ctx_
    struct gl_sl_pragmas *pragmas;
    slang_var_table *vartable;
    slang_info_log *log;
+   GLboolean allow_uniform_initializers;
 
    /* current loop stack */
    const slang_operation *LoopOperStack[MAX_LOOP_DEPTH];
diff --git a/src/mesa/shader/slang/slang_compile.c b/src/mesa/shader/slang/slang_compile.c
index 499e16e..6a91d0f 100644
--- a/src/mesa/shader/slang/slang_compile.c
+++ b/src/mesa/shader/slang/slang_compile.c
@@ -40,14 +40,11 @@
 #include "slang_compile.h"
 #include "slang_preprocess.h"
 #include "slang_storage.h"
-#include "slang_emit.h"
 #include "slang_log.h"
 #include "slang_mem.h"
 #include "slang_vartable.h"
 #include "slang_simplify.h"
 
-#include "slang_print.h"
-
 /*
  * This is a straightforward implementation of the slang front-end
  * compiler.  Lots of error-checking functionality is missing but
@@ -2058,6 +2055,7 @@ parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
    if (C->global_scope) {
       slang_assemble_ctx A;
       memset(&A, 0, sizeof(slang_assemble_ctx));
+      A.allow_uniform_initializers = C->version > 110;
       A.atoms = C->atoms;
       A.space.funcs = O->funs;
       A.space.structs = O->structs;
@@ -2077,6 +2075,7 @@ parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
       if (var->initializer != NULL) {
          slang_assemble_ctx A;
          memset(&A, 0, sizeof(slang_assemble_ctx));
+         A.allow_uniform_initializers = C->version > 110;
          A.atoms = C->atoms;
          A.space.funcs = O->funs;
          A.space.structs = O->structs;
@@ -2434,6 +2433,7 @@ parse_code_unit(slang_parse_ctx * C, slang_code_unit * unit,
       A.vartable = o.vartable;
       A.EmitContReturn = ctx->Shader.EmitContReturn;
       A.log = C->L;
+      A.allow_uniform_initializers = C->version > 110;
 
       /* main() takes no parameters */
       if (mainFunc->param_count > 0) {
diff --git a/src/mesa/shader/slang/slang_compile_operation.c b/src/mesa/shader/slang/slang_compile_operation.c
index be73094..3a15d9d 100644
--- a/src/mesa/shader/slang/slang_compile_operation.c
+++ b/src/mesa/shader/slang/slang_compile_operation.c
@@ -46,6 +46,7 @@ slang_operation_construct(slang_operation * oper)
    oper->literal_size = 1;
    oper->array_constructor = GL_FALSE;
    oper->a_id = SLANG_ATOM_NULL;
+   oper->a_obj = SLANG_ATOM_NULL;
    oper->locals = _slang_variable_scope_new(NULL);
    if (oper->locals == NULL)
       return GL_FALSE;
diff --git a/src/mesa/shader/slang/slang_emit.c b/src/mesa/shader/slang/slang_emit.c
index c0e4b27..f812a3f 100644
--- a/src/mesa/shader/slang/slang_emit.c
+++ b/src/mesa/shader/slang/slang_emit.c
@@ -38,7 +38,6 @@
 
 #include "main/imports.h"
 #include "main/context.h"
-#include "main/macros.h"
 #include "shader/program.h"
 #include "shader/prog_instruction.h"
 #include "shader/prog_parameter.h"
diff --git a/src/mesa/shader/slang/slang_link.c b/src/mesa/shader/slang/slang_link.c
index 0a2bc49..e9f1ee4 100644
--- a/src/mesa/shader/slang/slang_link.c
+++ b/src/mesa/shader/slang/slang_link.c
@@ -31,7 +31,6 @@
 
 #include "main/imports.h"
 #include "main/context.h"
-#include "main/hash.h"
 #include "main/macros.h"
 #include "shader/program.h"
 #include "shader/prog_instruction.h"
diff --git a/src/mesa/shader/slang/slang_log.c b/src/mesa/shader/slang/slang_log.c
index d7d2b4f..4f6b854 100644
--- a/src/mesa/shader/slang/slang_log.c
+++ b/src/mesa/shader/slang/slang_log.c
@@ -24,7 +24,6 @@
  */
 
 #include "main/imports.h"
-#include "main/context.h"
 #include "slang_log.h"
 #include "slang_utility.h"
 
diff --git a/src/mesa/state_tracker/st_atom_framebuffer.c b/src/mesa/state_tracker/st_atom_framebuffer.c
index e18c0f6..1e18497 100644
--- a/src/mesa/state_tracker/st_atom_framebuffer.c
+++ b/src/mesa/state_tracker/st_atom_framebuffer.c
@@ -37,7 +37,6 @@
 #include "st_public.h"
 #include "st_texture.h"
 #include "pipe/p_context.h"
-#include "pipe/p_inlines.h"
 #include "cso_cache/cso_context.h"
 #include "util/u_rect.h"
 
diff --git a/src/mesa/state_tracker/st_atom_pixeltransfer.c b/src/mesa/state_tracker/st_atom_pixeltransfer.c
index babfcc8..8300300 100644
--- a/src/mesa/state_tracker/st_atom_pixeltransfer.c
+++ b/src/mesa/state_tracker/st_atom_pixeltransfer.c
@@ -43,7 +43,6 @@
 
 #include "st_context.h"
 #include "st_format.h"
-#include "st_program.h"
 #include "st_texture.h"
 #include "st_inlines.h"
 
diff --git a/src/mesa/state_tracker/st_atom_sampler.c b/src/mesa/state_tracker/st_atom_sampler.c
index 6611956..7b1734c 100644
--- a/src/mesa/state_tracker/st_atom_sampler.c
+++ b/src/mesa/state_tracker/st_atom_sampler.c
@@ -37,7 +37,6 @@
 #include "st_context.h"
 #include "st_cb_texture.h"
 #include "st_atom.h"
-#include "st_program.h"
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
 
diff --git a/src/mesa/state_tracker/st_atom_scissor.c b/src/mesa/state_tracker/st_atom_scissor.c
index 3fd59e1..5e0c51c 100644
--- a/src/mesa/state_tracker/st_atom_scissor.c
+++ b/src/mesa/state_tracker/st_atom_scissor.c
@@ -31,6 +31,7 @@
   */
  
 
+#include "main/macros.h"
 #include "st_context.h"
 #include "pipe/p_context.h"
 #include "st_atom.h"
@@ -52,15 +53,19 @@ update_scissor( struct st_context *st )
    scissor.maxy = fb->Height;
 
    if (st->ctx->Scissor.Enabled) {
-      if ((GLuint)st->ctx->Scissor.X > scissor.minx)
+      /* need to be careful here with xmax or ymax < 0 */
+      GLint xmax = MAX2(0, st->ctx->Scissor.X + st->ctx->Scissor.Width);
+      GLint ymax = MAX2(0, st->ctx->Scissor.Y + st->ctx->Scissor.Height);
+
+      if (st->ctx->Scissor.X > (GLint)scissor.minx)
          scissor.minx = st->ctx->Scissor.X;
-      if ((GLuint)st->ctx->Scissor.Y > scissor.miny)
+      if (st->ctx->Scissor.Y > (GLint)scissor.miny)
          scissor.miny = st->ctx->Scissor.Y;
 
-      if ((GLuint)st->ctx->Scissor.X + st->ctx->Scissor.Width < scissor.maxx)
-         scissor.maxx = st->ctx->Scissor.X + st->ctx->Scissor.Width;
-      if ((GLuint)st->ctx->Scissor.Y + st->ctx->Scissor.Height < scissor.maxy)
-         scissor.maxy = st->ctx->Scissor.Y + st->ctx->Scissor.Height;
+      if (xmax < (GLint) scissor.maxx)
+         scissor.maxx = xmax;
+      if (ymax < (GLint) scissor.maxy)
+         scissor.maxy = ymax;
 
       /* check for null space */
       if (scissor.minx >= scissor.maxx || scissor.miny >= scissor.maxy)
diff --git a/src/mesa/state_tracker/st_atom_shader.c b/src/mesa/state_tracker/st_atom_shader.c
index 9208f3f..4c106eb 100644
--- a/src/mesa/state_tracker/st_atom_shader.c
+++ b/src/mesa/state_tracker/st_atom_shader.c
@@ -53,7 +53,6 @@
 #include "st_atom.h"
 #include "st_program.h"
 #include "st_atom_shader.h"
-#include "st_mesa_to_tgsi.h"
 
 
 /**
@@ -147,7 +146,7 @@ find_translated_vp(struct st_context *st,
 
       stfp->num_input_slots = numIn;
 
-      assert(stfp->Base.Base.NumInstructions > 1);
+      assert(stfp->Base.Base.NumInstructions > 0);
 
       st_translate_fragment_program(st, stfp, stfp->input_to_slot);
    }
diff --git a/src/mesa/state_tracker/st_cb_accum.c b/src/mesa/state_tracker/st_cb_accum.c
index a6b9765..6625dfb 100644
--- a/src/mesa/state_tracker/st_cb_accum.c
+++ b/src/mesa/state_tracker/st_cb_accum.c
@@ -38,9 +38,7 @@
 #include "st_context.h"
 #include "st_cb_accum.h"
 #include "st_cb_fbo.h"
-#include "st_draw.h"
 #include "st_public.h"
-#include "st_format.h"
 #include "st_texture.h"
 #include "st_inlines.h"
 #include "pipe/p_context.h"
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index 1960d17..8602f6d 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -34,9 +34,7 @@
 #include "main/image.h"
 #include "main/bufferobj.h"
 #include "main/macros.h"
-#include "main/texformat.h"
 #include "shader/program.h"
-#include "shader/prog_parameter.h"
 #include "shader/prog_print.h"
 
 #include "st_context.h"
@@ -44,15 +42,12 @@
 #include "st_atom_constbuf.h"
 #include "st_program.h"
 #include "st_cb_bitmap.h"
-#include "st_cb_program.h"
-#include "st_mesa_to_tgsi.h"
 #include "st_texture.h"
 #include "st_inlines.h"
 
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
 #include "pipe/p_inlines.h"
-#include "util/u_tile.h"
 #include "util/u_draw_quad.h"
 #include "util/u_simple_shaders.h"
 #include "shader/prog_instruction.h"
@@ -391,11 +386,11 @@ setup_bitmap_vertex_data(struct st_context *st,
    }
 
    /* put vertex data into vbuf */
-   st_no_flush_pipe_buffer_write(st,
-				 st->bitmap.vbuf,
-				 st->bitmap.vbuf_slot * sizeof st->bitmap.vertices,
-				 sizeof st->bitmap.vertices,
-				 st->bitmap.vertices);
+   st_no_flush_pipe_buffer_write_nooverlap(st,
+                                           st->bitmap.vbuf,
+                                           st->bitmap.vbuf_slot * sizeof st->bitmap.vertices,
+                                           sizeof st->bitmap.vertices,
+                                           st->bitmap.vertices);
 
    return st->bitmap.vbuf_slot++ * sizeof st->bitmap.vertices;
 }
diff --git a/src/mesa/state_tracker/st_cb_blit.c b/src/mesa/state_tracker/st_cb_blit.c
index 563615e..65aa2a2 100644
--- a/src/mesa/state_tracker/st_cb_blit.c
+++ b/src/mesa/state_tracker/st_cb_blit.c
@@ -33,14 +33,10 @@
 #include "main/imports.h"
 #include "main/image.h"
 #include "main/macros.h"
-#include "main/texformat.h"
 #include "shader/program.h"
-#include "shader/prog_parameter.h"
-#include "shader/prog_print.h"
 
 #include "st_context.h"
 #include "st_texture.h"
-#include "st_program.h"
 #include "st_cb_blit.h"
 #include "st_cb_fbo.h"
 
diff --git a/src/mesa/state_tracker/st_cb_bufferobjects.c b/src/mesa/state_tracker/st_cb_bufferobjects.c
index 63196af..0102d8a 100644
--- a/src/mesa/state_tracker/st_cb_bufferobjects.c
+++ b/src/mesa/state_tracker/st_cb_bufferobjects.c
@@ -103,6 +103,17 @@ st_bufferobj_subdata(GLcontext *ctx,
    ASSERT(size >= 0);
    ASSERT(offset + size <= obj->Size);
 
+   if (!size)
+      return;
+
+   /*
+    * According to ARB_vertex_buffer_object specification, if data is null,
+    * then the contents of the buffer object's data store is undefined. We just
+    * ignore, and leave it unchanged.
+    */
+   if (!data)
+      return;
+
    st_cond_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer,
 				   offset, size, data);
 }
@@ -125,6 +136,9 @@ st_bufferobj_get_subdata(GLcontext *ctx,
    ASSERT(size >= 0);
    ASSERT(offset + size <= obj->Size);
 
+   if (!size)
+      return;
+
    st_cond_flush_pipe_buffer_read(st_context(ctx), st_obj->buffer,
 				  offset, size, data);
 }
@@ -170,15 +184,19 @@ st_bufferobj_data(GLcontext *ctx,
 
    pipe_buffer_reference( &st_obj->buffer, NULL );
 
-   st_obj->buffer = pipe_buffer_create( pipe->screen, 32, buffer_usage, size );
+   if (size != 0) {
+      st_obj->buffer = pipe_buffer_create(pipe->screen, 32, buffer_usage, size);
+
+      if (!st_obj->buffer) {
+         return GL_FALSE;
+      }
 
-   if (!st_obj->buffer) {
-      return GL_FALSE;
+      if (data)
+         st_no_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer, 0,
+				       size, data);
+      return GL_TRUE;
    }
 
-   if (data)
-      st_no_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer, 0,
-				    size, data);
    return GL_TRUE;
 }
 
@@ -219,6 +237,13 @@ st_bufferobj_map(GLcontext *ctx, GLenum target, GLenum access,
 
 
 /**
+ * Dummy data whose's pointer is used for zero length ranges.
+ */
+static long
+st_bufferobj_zero_length_range = 0;
+
+
+/**
  * Called via glMapBufferRange().
  */
 static void *
@@ -253,14 +278,26 @@ st_bufferobj_map_range(GLcontext *ctx, GLenum target,
    assert(offset < obj->Size);
    assert(offset + length <= obj->Size);
 
-   obj->Pointer = pipe_buffer_map_range(pipe->screen, st_obj->buffer, offset, length, flags);
+   /*
+    * We go out of way here to hide the degenerate yet valid case of zero
+    * length range from the pipe driver.
+    */
+   if (!length) {
+      obj->Pointer = &st_bufferobj_zero_length_range;
+   }
+   else {
+      obj->Pointer = pipe_buffer_map_range(pipe->screen, st_obj->buffer, offset, length, flags);
+      if (obj->Pointer) {
+         obj->Pointer = (ubyte *) obj->Pointer + offset;
+      }
+   }
+   
    if (obj->Pointer) {
-      obj->Pointer = (ubyte *) obj->Pointer + offset;
       obj->Offset = offset;
       obj->Length = length;
       obj->AccessFlags = access;
    }
-   
+
    return obj->Pointer;
 }
 
@@ -278,6 +315,9 @@ st_bufferobj_flush_mapped_range(GLcontext *ctx, GLenum target,
    assert(length >= 0);
    assert(offset + length <= obj->Length);
    
+   if (!length)
+      return;
+
    pipe_buffer_flush_mapped_range(pipe->screen, st_obj->buffer, 
                                   obj->Offset + offset, length);
 }
@@ -292,7 +332,9 @@ st_bufferobj_unmap(GLcontext *ctx, GLenum target, struct gl_buffer_object *obj)
    struct pipe_context *pipe = st_context(ctx)->pipe;
    struct st_buffer_object *st_obj = st_buffer_object(obj);
 
-   pipe_buffer_unmap(pipe->screen, st_obj->buffer);
+   if(obj->Length)
+      pipe_buffer_unmap(pipe->screen, st_obj->buffer);
+
    obj->Pointer = NULL;
    obj->Offset = 0;
    obj->Length = 0;
@@ -315,6 +357,9 @@ st_copy_buffer_subdata(GLcontext *ctx,
    struct st_buffer_object *dstObj = st_buffer_object(dst);
    ubyte *srcPtr, *dstPtr;
 
+   if(!size)
+      return;
+
    /* buffer should not already be mapped */
    assert(!src->Pointer);
    assert(!dst->Pointer);
diff --git a/src/mesa/state_tracker/st_cb_clear.c b/src/mesa/state_tracker/st_cb_clear.c
index e83b6c9..3aa4b03 100644
--- a/src/mesa/state_tracker/st_cb_clear.c
+++ b/src/mesa/state_tracker/st_cb_clear.c
@@ -42,17 +42,14 @@
 #include "st_cb_accum.h"
 #include "st_cb_clear.h"
 #include "st_cb_fbo.h"
-#include "st_draw.h"
 #include "st_program.h"
 #include "st_public.h"
-#include "st_mesa_to_tgsi.h"
 #include "st_inlines.h"
 
 #include "pipe/p_context.h"
 #include "pipe/p_inlines.h"
 #include "pipe/p_state.h"
 #include "pipe/p_defines.h"
-#include "util/u_pack_color.h"
 #include "util/u_simple_shaders.h"
 #include "util/u_draw_quad.h"
 
@@ -165,10 +162,10 @@ draw_quad(GLcontext *ctx,
    }
 
    /* put vertex data into vbuf */
-   st_no_flush_pipe_buffer_write(st, st->clear.vbuf,
-				 st->clear.vbuf_slot * sizeof(st->clear.vertices),
-				 sizeof(st->clear.vertices),
-				 st->clear.vertices);
+   st_no_flush_pipe_buffer_write_nooverlap(st, st->clear.vbuf,
+                                           st->clear.vbuf_slot * sizeof(st->clear.vertices),
+                                           sizeof(st->clear.vertices),
+                                           st->clear.vertices);
 
    /* draw */
    util_draw_vertex_buffer(pipe, 
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 1d33e81..23db3f1 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -36,24 +36,18 @@
 #include "main/macros.h"
 #include "main/texformat.h"
 #include "main/texstore.h"
-#include "main/state.h"
 #include "shader/program.h"
-#include "shader/prog_parameter.h"
 #include "shader/prog_print.h"
 
 #include "st_debug.h"
 #include "st_context.h"
 #include "st_atom.h"
 #include "st_atom_constbuf.h"
-#include "st_draw.h"
 #include "st_program.h"
 #include "st_cb_drawpixels.h"
 #include "st_cb_readpixels.h"
 #include "st_cb_fbo.h"
-#include "st_cb_texture.h"
-#include "st_draw.h"
 #include "st_format.h"
-#include "st_mesa_to_tgsi.h"
 #include "st_texture.h"
 #include "st_inlines.h"
 
diff --git a/src/mesa/state_tracker/st_cb_fbo.c b/src/mesa/state_tracker/st_cb_fbo.c
index 65ce12c..9cdff53 100644
--- a/src/mesa/state_tracker/st_cb_fbo.c
+++ b/src/mesa/state_tracker/st_cb_fbo.c
@@ -44,7 +44,6 @@
 #include "pipe/p_screen.h"
 #include "st_context.h"
 #include "st_cb_fbo.h"
-#include "st_cb_texture.h"
 #include "st_format.h"
 #include "st_public.h"
 #include "st_texture.h"
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index 93f7145..17261f8 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -45,14 +45,11 @@
 #include "vbo/vbo.h"
 
 #include "st_context.h"
-#include "st_atom.h"
 #include "st_draw.h"
 #include "st_cb_feedback.h"
-#include "st_cb_bufferobjects.h"
 
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
-#include "cso_cache/cso_cache.h"
 
 #include "draw/draw_context.h"
 #include "draw/draw_pipe.h"
diff --git a/src/mesa/state_tracker/st_cb_program.c b/src/mesa/state_tracker/st_cb_program.c
index b2d5c39..22cb61c 100644
--- a/src/mesa/state_tracker/st_cb_program.c
+++ b/src/mesa/state_tracker/st_cb_program.c
@@ -36,7 +36,6 @@
 #include "shader/prog_instruction.h"
 #include "shader/prog_parameter.h"
 #include "shader/program.h"
-#include "shader/programopt.h"
 #include "shader/shader_api.h"
 
 #include "cso_cache/cso_context.h"
diff --git a/src/mesa/state_tracker/st_cb_queryobj.c b/src/mesa/state_tracker/st_cb_queryobj.c
index dcf4c38..5ef7765 100644
--- a/src/mesa/state_tracker/st_cb_queryobj.c
+++ b/src/mesa/state_tracker/st_cb_queryobj.c
@@ -41,7 +41,6 @@
 #include "pipe/p_defines.h"
 #include "st_context.h"
 #include "st_cb_queryobj.h"
-#include "st_public.h"
 
 
 struct st_query_object
diff --git a/src/mesa/state_tracker/st_cb_rasterpos.c b/src/mesa/state_tracker/st_cb_rasterpos.c
index d82b2a2..42a1377 100644
--- a/src/mesa/state_tracker/st_cb_rasterpos.c
+++ b/src/mesa/state_tracker/st_cb_rasterpos.c
@@ -47,7 +47,6 @@
 #include "st_draw.h"
 #include "draw/draw_context.h"
 #include "draw/draw_pipe.h"
-#include "shader/prog_instruction.h"
 #include "vbo/vbo.h"
 
 
diff --git a/src/mesa/state_tracker/st_cb_readpixels.c b/src/mesa/state_tracker/st_cb_readpixels.c
index 772bb3b..be98195 100644
--- a/src/mesa/state_tracker/st_cb_readpixels.c
+++ b/src/mesa/state_tracker/st_cb_readpixels.c
@@ -45,10 +45,8 @@
 
 #include "st_debug.h"
 #include "st_context.h"
-#include "st_cb_bitmap.h"
 #include "st_cb_readpixels.h"
 #include "st_cb_fbo.h"
-#include "st_format.h"
 #include "st_public.h"
 #include "st_texture.h"
 #include "st_inlines.h"
diff --git a/src/mesa/state_tracker/st_cb_strings.c b/src/mesa/state_tracker/st_cb_strings.c
index bb931f1..f22c536 100644
--- a/src/mesa/state_tracker/st_cb_strings.c
+++ b/src/mesa/state_tracker/st_cb_strings.c
@@ -33,7 +33,6 @@
 
 #include "main/glheader.h"
 #include "main/macros.h"
-#include "main/version.h"
 #include "pipe/p_context.h"
 #include "pipe/p_screen.h"
 #include "st_context.h"
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index d4630a5..a0dc016 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -31,15 +31,14 @@
 #include "main/convolve.h"
 #endif
 #include "main/enums.h"
+#include "main/fbobject.h"
 #include "main/formats.h"
 #include "main/image.h"
 #include "main/imports.h"
 #include "main/macros.h"
 #include "main/mipmap.h"
-#include "main/pixel.h"
 #include "main/texcompress.h"
 #include "main/texfetch.h"
-#include "main/texformat.h"
 #include "main/texgetimage.h"
 #include "main/teximage.h"
 #include "main/texobj.h"
@@ -1090,7 +1089,7 @@ st_TexSubimage(GLcontext *ctx, GLint dims, GLenum target, GLint level,
 done:
    _mesa_unmap_teximage_pbo(ctx, packing);
 
-   if (stImage->pt) {
+   if (stImage->pt && texImage->Data) {
       st_texture_image_unmap(ctx->st, stImage);
       texImage->Data = NULL;
    }
@@ -1354,33 +1353,64 @@ fallback_copy_texsubimage(GLcontext *ctx, GLenum target, GLint level,
 }
 
 
+
+/**
+ * If the format of the src renderbuffer and the format of the dest
+ * texture are compatible (in terms of blitting), return a TGSI writemask
+ * to be used during the blit.
+ * If the src/dest are incompatible, return 0.
+ */
 static unsigned
-compatible_src_dst_formats(const struct gl_renderbuffer *src,
+compatible_src_dst_formats(GLcontext *ctx,
+                           const struct gl_renderbuffer *src,
                            const struct gl_texture_image *dst)
 {
-   const GLenum srcFormat = _mesa_get_format_base_format(src->Format);
-   const GLenum dstLogicalFormat = _mesa_get_format_base_format(dst->TexFormat);
+   /* Get logical base formats for the src and dest.
+    * That is, use the user-requested formats and not the actual, device-
+    * chosen formats.
+    * For example, the user may have requested an A8 texture but the
+    * driver may actually be using an RGBA texture format.  When we
+    * copy/blit to that texture, we only want to copy the Alpha channel
+    * and not the RGB channels.
+    *
+    * Similarly, when the src FBO was created an RGB format may have been
+    * requested but the driver actually chose an RGBA format.  In that case,
+    * we don't want to copy the undefined Alpha channel to the dest texture
+    * (it should be 1.0).
+    */
+   const GLenum srcFormat = _mesa_base_fbo_format(ctx, src->InternalFormat);
+   const GLenum dstFormat = _mesa_base_tex_format(ctx, dst->InternalFormat);
 
-   if (srcFormat == dstLogicalFormat) {
+   /**
+    * XXX when we have red-only and red/green renderbuffers we'll need
+    * to add more cases here (or implement a general-purpose routine that
+    * queries the existance of the R,G,B,A channels in the src and dest).
+    */
+   if (srcFormat == dstFormat) {
       /* This is the same as matching_base_formats, which should
        * always pass, as it did previously.
        */
       return TGSI_WRITEMASK_XYZW;
    }
-   else if (srcFormat == GL_RGBA &&
-            dstLogicalFormat == GL_RGB) {
-      /* Add a single special case to cope with RGBA->RGB transfers,
-       * setting A to 1.0 to cope with situations where the RGB
-       * destination is actually stored as RGBA.
+   else if (srcFormat == GL_RGB && dstFormat == GL_RGBA) {
+      /* Make sure that A in the dest is 1.  The actual src format
+       * may be RGBA and have undefined A values.
+       */
+      return TGSI_WRITEMASK_XYZ;
+   }
+   else if (srcFormat == GL_RGBA && dstFormat == GL_RGB) {
+      /* Make sure that A in the dest is 1.  The actual dst format
+       * may be RGBA and will need A=1 to provide proper alpha values
+       * when sampled later.
        */
-      return TGSI_WRITEMASK_XYZ; /* A ==> 1.0 */
+      return TGSI_WRITEMASK_XYZ;
    }
    else {
       if (ST_DEBUG & DEBUG_FALLBACK)
          debug_printf("%s failed for src %s, dst %s\n",
                       __FUNCTION__, 
                       _mesa_lookup_enum_by_nr(srcFormat),
-                      _mesa_lookup_enum_by_nr(dstLogicalFormat));
+                      _mesa_lookup_enum_by_nr(dstFormat));
 
       /* Otherwise fail.
        */
@@ -1491,7 +1521,7 @@ st_copy_texsubimage(GLcontext *ctx,
    matching_base_formats =
       (_mesa_get_format_base_format(strb->Base.Format) ==
        _mesa_get_format_base_format(texImage->TexFormat));
-   format_writemask = compatible_src_dst_formats(&strb->Base, texImage);
+   format_writemask = compatible_src_dst_formats(ctx, &strb->Base, texImage);
 
    if (ctx->_ImageTransferState == 0x0) {
 
diff --git a/src/mesa/state_tracker/st_cb_viewport.c b/src/mesa/state_tracker/st_cb_viewport.c
index 75b0a21..b29191a 100644
--- a/src/mesa/state_tracker/st_cb_viewport.c
+++ b/src/mesa/state_tracker/st_cb_viewport.c
@@ -27,14 +27,11 @@
 
 #include "main/glheader.h"
 #include "st_context.h"
-#include "st_public.h"
 #include "st_cb_viewport.h"
 
 #include "pipe/p_context.h"
-#include "pipe/p_inlines.h"
 #include "pipe/p_state.h"
 #include "pipe/p_defines.h"
-#include "pipe/internal/p_winsys_screen.h"
 
 
 static void st_viewport(GLcontext * ctx, GLint x, GLint y,
@@ -42,8 +39,8 @@ static void st_viewport(GLcontext * ctx, GLint x, GLint y,
 {
    struct st_context *st = ctx->st;
 
-   if (st->pipe->winsys && st->pipe->winsys->update_buffer)
-      st->pipe->winsys->update_buffer( st->pipe->winsys,
+   if (st->pipe->screen && st->pipe->screen->update_buffer)
+      st->pipe->screen->update_buffer( st->pipe->screen,
                                        st->pipe->priv );
 }
 
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index d18a25a..6c463ca 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -27,11 +27,6 @@
 
 #include "main/imports.h"
 #include "main/context.h"
-#include "main/extensions.h"
-#include "main/matrix.h"
-#include "main/buffers.h"
-#include "main/scissor.h"
-#include "main/viewport.h"
 #include "vbo/vbo.h"
 #include "shader/shader_api.h"
 #include "glapi/glapi.h"
@@ -68,7 +63,6 @@
 #include "st_program.h"
 #include "pipe/p_context.h"
 #include "draw/draw_context.h"
-#include "cso_cache/cso_cache.h"
 #include "cso_cache/cso_context.h"
 
 
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index b2d682e..0660a2c 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -28,7 +28,6 @@
 #include "main/imports.h"
 #include "main/image.h"
 #include "main/macros.h"
-#include "shader/prog_uniform.h"
 
 #include "vbo/vbo.h"
 
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 57fe72d..54d7c61 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -28,7 +28,6 @@
 
 #include "main/imports.h"
 #include "main/context.h"
-#include "main/extensions.h"
 #include "main/macros.h"
 
 #include "pipe/p_context.h"
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index 02f8005..d2bc0dc 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -35,7 +35,6 @@
 #include "main/imports.h"
 #include "main/context.h"
 #include "main/texstore.h"
-#include "main/texformat.h"
 #include "main/enums.h"
 #include "main/macros.h"
 
@@ -99,7 +98,8 @@ st_get_format_info(enum pipe_format format, struct pipe_format_info *pinfo)
       if (format == PIPE_FORMAT_A1R5G5B5_UNORM || format == PIPE_FORMAT_R5G6B5_UNORM) {
          pinfo->datatype = GL_UNSIGNED_SHORT;
       }
-      else if (format == PIPE_FORMAT_S8Z24_UNORM) {
+      else if (format == PIPE_FORMAT_S8Z24_UNORM ||
+               format == PIPE_FORMAT_Z24S8_UNORM) {
          pinfo->datatype = GL_UNSIGNED_INT_24_8;
       }
       else {
@@ -291,6 +291,10 @@ st_pipe_format_to_mesa_format(enum pipe_format pipeFormat)
       return MESA_FORMAT_ARGB8888;
    case PIPE_FORMAT_X8R8G8B8_UNORM:
       return MESA_FORMAT_XRGB8888;
+   case PIPE_FORMAT_B8G8R8A8_UNORM:
+      return MESA_FORMAT_ARGB8888_REV;
+   case PIPE_FORMAT_B8G8R8X8_UNORM:
+      return MESA_FORMAT_XRGB8888_REV;
    case PIPE_FORMAT_A1R5G5B5_UNORM:
       return MESA_FORMAT_ARGB1555;
    case PIPE_FORMAT_A4R4G4B4_UNORM:
diff --git a/src/mesa/state_tracker/st_framebuffer.c b/src/mesa/state_tracker/st_framebuffer.c
index a5d1ae3..835142e 100644
--- a/src/mesa/state_tracker/st_framebuffer.c
+++ b/src/mesa/state_tracker/st_framebuffer.c
@@ -30,15 +30,11 @@
 #include "main/buffers.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
-#include "main/matrix.h"
 #include "main/renderbuffer.h"
-#include "main/scissor.h"
-#include "main/viewport.h"
 #include "st_context.h"
 #include "st_cb_fbo.h"
 #include "st_public.h"
 #include "pipe/p_defines.h"
-#include "pipe/p_context.h"
 
 
 struct st_framebuffer *
diff --git a/src/mesa/state_tracker/st_gen_mipmap.c b/src/mesa/state_tracker/st_gen_mipmap.c
index 2d404d5..cffb880 100644
--- a/src/mesa/state_tracker/st_gen_mipmap.c
+++ b/src/mesa/state_tracker/st_gen_mipmap.c
@@ -44,9 +44,7 @@
 
 #include "st_debug.h"
 #include "st_context.h"
-#include "st_draw.h"
 #include "st_gen_mipmap.h"
-#include "st_program.h"
 #include "st_texture.h"
 #include "st_cb_texture.h"
 #include "st_inlines.h"
diff --git a/src/mesa/state_tracker/st_inlines.h b/src/mesa/state_tracker/st_inlines.h
index a41cfeb..dccc46f 100644
--- a/src/mesa/state_tracker/st_inlines.h
+++ b/src/mesa/state_tracker/st_inlines.h
@@ -126,6 +126,16 @@ st_no_flush_pipe_buffer_write(struct st_context *st,
 }
 
 static INLINE void
+st_no_flush_pipe_buffer_write_nooverlap(struct st_context *st,
+                                        struct pipe_buffer *buf,
+                                        unsigned int offset,
+                                        unsigned int size,
+                                        const void * data)
+{
+   pipe_buffer_write_nooverlap(st->pipe->screen, buf, offset, size, data);
+}
+
+static INLINE void
 st_cond_flush_pipe_buffer_read(struct st_context *st,
 			       struct pipe_buffer *buf,
 			       unsigned int offset,
diff --git a/src/mesa/state_tracker/st_mesa_to_tgsi.c b/src/mesa/state_tracker/st_mesa_to_tgsi.c
index bd94c9d..0b7786c 100644
--- a/src/mesa/state_tracker/st_mesa_to_tgsi.c
+++ b/src/mesa/state_tracker/st_mesa_to_tgsi.c
@@ -160,13 +160,14 @@ dst_register( struct st_translate *t,
 static struct ureg_src
 src_register( struct st_translate *t,
               gl_register_file file,
-              GLuint index )
+              GLint index )
 {
    switch( file ) {
    case PROGRAM_UNDEFINED:
       return ureg_src_undef();
 
    case PROGRAM_TEMPORARY:
+      ASSERT(index >= 0);
       if (ureg_dst_is_undef(t->temps[index]))
          t->temps[index] = ureg_DECL_temporary( t->ureg );
       return ureg_src(t->temps[index]);
@@ -174,9 +175,15 @@ src_register( struct st_translate *t,
    case PROGRAM_STATE_VAR:
    case PROGRAM_NAMED_PARAM:
    case PROGRAM_ENV_PARAM:
+   case PROGRAM_LOCAL_PARAM:
    case PROGRAM_UNIFORM:
-   case PROGRAM_CONSTANT:       /* ie, immediate */
+      ASSERT(index >= 0);
       return t->constants[index];
+   case PROGRAM_CONSTANT:       /* ie, immediate */
+      if (index < 0)
+         return ureg_DECL_constant( t->ureg, 0 );
+      else
+         return t->constants[index];
 
    case PROGRAM_INPUT:
       return t->inputs[t->inputMapping[index]];
@@ -263,9 +270,14 @@ translate_src( struct st_translate *t,
    if (SrcReg->Abs) 
       src = ureg_abs(src);
 
-   if (SrcReg->RelAddr) 
+   if (SrcReg->RelAddr) {
       src = ureg_src_indirect( src, ureg_src(t->address[0]));
-   
+      /* If SrcReg->Index was negative, it was set to zero in
+       * src_register().  Reassign it now.
+       */
+      src.Index = SrcReg->Index;
+   }
+
    return src;
 }
 
@@ -805,6 +817,7 @@ st_translate_mesa_program(
       for (i = 0; i < program->Parameters->NumParameters; i++) {
          switch (program->Parameters->Parameters[i].Type) {
          case PROGRAM_ENV_PARAM:
+         case PROGRAM_LOCAL_PARAM:
          case PROGRAM_STATE_VAR:
          case PROGRAM_NAMED_PARAM:
          case PROGRAM_UNIFORM:
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index cf19f8f..07a06b9 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -44,7 +44,6 @@
 
 #include "st_debug.h"
 #include "st_context.h"
-#include "st_atom.h"
 #include "st_program.h"
 #include "st_mesa_to_tgsi.h"
 #include "cso_cache/cso_context.h"
diff --git a/src/mesa/state_tracker/st_texture.c b/src/mesa/state_tracker/st_texture.c
index 10f1351..cda3791 100644
--- a/src/mesa/state_tracker/st_texture.c
+++ b/src/mesa/state_tracker/st_texture.c
@@ -35,7 +35,6 @@
 #include "main/texfetch.h"
 #include "main/teximage.h"
 #include "main/texobj.h"
-#include "main/texstore.h"
 
 #undef Elements  /* fix re-defined macro warning */
 
diff --git a/src/mesa/swrast/s_accum.c b/src/mesa/swrast/s_accum.c
index c6c7dbf..6accdc5 100644
--- a/src/mesa/swrast/s_accum.c
+++ b/src/mesa/swrast/s_accum.c
@@ -27,7 +27,6 @@
 #include "main/context.h"
 #include "main/macros.h"
 #include "main/imports.h"
-#include "main/fbobject.h"
 
 #include "s_accum.h"
 #include "s_context.h"
diff --git a/src/mesa/swrast/s_atifragshader.c b/src/mesa/swrast/s_atifragshader.c
index e88ff19..353e999 100644
--- a/src/mesa/swrast/s_atifragshader.c
+++ b/src/mesa/swrast/s_atifragshader.c
@@ -23,7 +23,6 @@
 #include "main/colormac.h"
 #include "main/context.h"
 #include "main/macros.h"
-#include "shader/program.h"
 #include "shader/atifragshader.h"
 #include "swrast/s_atifragshader.h"
 
diff --git a/src/mesa/swrast/s_bitmap.c b/src/mesa/swrast/s_bitmap.c
index 3dbdf2a..57a42b3 100644
--- a/src/mesa/swrast/s_bitmap.c
+++ b/src/mesa/swrast/s_bitmap.c
@@ -32,7 +32,6 @@
 #include "main/bufferobj.h"
 #include "main/image.h"
 #include "main/macros.h"
-#include "main/pixel.h"
 
 #include "s_context.h"
 #include "s_span.h"
diff --git a/src/mesa/swrast/s_copypix.c b/src/mesa/swrast/s_copypix.c
index 5ecfb1e..da98730 100644
--- a/src/mesa/swrast/s_copypix.c
+++ b/src/mesa/swrast/s_copypix.c
@@ -27,11 +27,9 @@
 #include "main/context.h"
 #include "main/colormac.h"
 #include "main/convolve.h"
-#include "main/histogram.h"
 #include "main/image.h"
 #include "main/macros.h"
 #include "main/imports.h"
-#include "main/pixel.h"
 
 #include "s_context.h"
 #include "s_depth.h"
diff --git a/src/mesa/swrast/s_depth.c b/src/mesa/swrast/s_depth.c
index c37a54e..ac5dae2 100644
--- a/src/mesa/swrast/s_depth.c
+++ b/src/mesa/swrast/s_depth.c
@@ -28,7 +28,6 @@
 #include "main/formats.h"
 #include "main/macros.h"
 #include "main/imports.h"
-#include "main/fbobject.h"
 
 #include "s_depth.h"
 #include "s_context.h"
@@ -498,17 +497,24 @@ depth_test_span32( GLcontext *ctx, GLuint n,
    return passed;
 }
 
-/* Apply ARB_depth_clamp to span of fragments. */
+
+
+/**
+ * Clamp fragment Z values to the depth near/far range (glDepthRange()).
+ * This is used when GL_ARB_depth_clamp/GL_DEPTH_CLAMP is turned on.
+ * In that case, vertexes are not clipped against the near/far planes
+ * so rasterization will produce fragment Z values outside the usual
+ * [0,1] range.
+ */
 void
 _swrast_depth_clamp_span( GLcontext *ctx, SWspan *span )
 {
    struct gl_framebuffer *fb = ctx->DrawBuffer;
-   struct gl_renderbuffer *rb = fb->_DepthBuffer;
    const GLuint count = span->end;
-   GLuint *zValues = span->array->z;
-   GLuint min, max;
+   GLint *zValues = (GLint *) span->array->z; /* sign change */
+   GLint min, max;
    GLfloat min_f, max_f;
-   int i;
+   GLuint i;
 
    if (ctx->Viewport.Near < ctx->Viewport.Far) {
       min_f = ctx->Viewport.Near;
@@ -518,15 +524,21 @@ _swrast_depth_clamp_span( GLcontext *ctx, SWspan *span )
       max_f = ctx->Viewport.Near;
    }
 
-   if (rb->DataType == GL_UNSIGNED_SHORT) {
-      CLAMPED_FLOAT_TO_USHORT(min, min_f);
-      CLAMPED_FLOAT_TO_USHORT(max, max_f);
-   } else {
-      assert(rb->DataType == GL_UNSIGNED_INT);
-      min = FLOAT_TO_UINT(min_f);
-      max = FLOAT_TO_UINT(max_f);
-   }
-
+   /* Convert floating point values in [0,1] to device Z coordinates in
+    * [0, DepthMax].
+    * ex: If the the Z buffer has 24 bits, DepthMax = 0xffffff.
+    * 
+    * XXX this all falls apart if we have 31 or more bits of Z because
+    * the triangle rasterization code produces unsigned Z values.  Negative
+    * vertex Z values come out as large fragment Z uints.
+    */
+   min = (GLint) (min_f * fb->_DepthMaxF);
+   max = (GLint) (max_f * fb->_DepthMaxF);
+   if (max < 0)
+      max = 0x7fffffff; /* catch over flow for 30-bit z */
+
+   /* Note that we do the comparisons here using signed integers.
+    */
    for (i = 0; i < count; i++) {
       if (zValues[i] < min)
 	 zValues[i] = min;
diff --git a/src/mesa/swrast/s_drawpix.c b/src/mesa/swrast/s_drawpix.c
index 6970b2e..59dfd65 100644
--- a/src/mesa/swrast/s_drawpix.c
+++ b/src/mesa/swrast/s_drawpix.c
@@ -30,7 +30,6 @@
 #include "main/image.h"
 #include "main/macros.h"
 #include "main/imports.h"
-#include "main/pixel.h"
 #include "main/state.h"
 
 #include "s_context.h"
diff --git a/src/mesa/swrast/s_feedback.c b/src/mesa/swrast/s_feedback.c
index 47ed25e..2e60669 100644
--- a/src/mesa/swrast/s_feedback.c
+++ b/src/mesa/swrast/s_feedback.c
@@ -25,7 +25,6 @@
 #include "main/glheader.h"
 #include "main/colormac.h"
 #include "main/context.h"
-#include "main/enums.h"
 #include "main/feedback.h"
 #include "main/macros.h"
 
diff --git a/src/mesa/swrast/s_fragprog.c b/src/mesa/swrast/s_fragprog.c
index a22d344..9ac33a2 100644
--- a/src/mesa/swrast/s_fragprog.c
+++ b/src/mesa/swrast/s_fragprog.c
@@ -25,7 +25,6 @@
 #include "main/glheader.h"
 #include "main/colormac.h"
 #include "main/context.h"
-#include "main/texstate.h"
 #include "shader/prog_instruction.h"
 
 #include "s_fragprog.h"
diff --git a/src/mesa/swrast/s_lines.c b/src/mesa/swrast/s_lines.c
index 23cb9b5..5411229 100644
--- a/src/mesa/swrast/s_lines.c
+++ b/src/mesa/swrast/s_lines.c
@@ -29,7 +29,6 @@
 #include "main/macros.h"
 #include "s_aaline.h"
 #include "s_context.h"
-#include "s_depth.h"
 #include "s_feedback.h"
 #include "s_lines.h"
 #include "s_span.h"
diff --git a/src/mesa/swrast/s_points.c b/src/mesa/swrast/s_points.c
index 50ec206..6b95542 100644
--- a/src/mesa/swrast/s_points.c
+++ b/src/mesa/swrast/s_points.c
@@ -27,7 +27,6 @@
 #include "main/colormac.h"
 #include "main/context.h"
 #include "main/macros.h"
-#include "main/texstate.h"
 #include "s_context.h"
 #include "s_feedback.h"
 #include "s_points.h"
diff --git a/src/mesa/swrast/s_readpix.c b/src/mesa/swrast/s_readpix.c
index 44a11cd..94fb974 100644
--- a/src/mesa/swrast/s_readpix.c
+++ b/src/mesa/swrast/s_readpix.c
@@ -33,7 +33,6 @@
 #include "main/image.h"
 #include "main/macros.h"
 #include "main/imports.h"
-#include "main/pixel.h"
 #include "main/state.h"
 
 #include "s_context.h"
diff --git a/src/mesa/swrast/s_span.c b/src/mesa/swrast/s_span.c
index d36c813..07248c7 100644
--- a/src/mesa/swrast/s_span.c
+++ b/src/mesa/swrast/s_span.c
@@ -1316,6 +1316,13 @@ _swrast_write_rgba_span( GLcontext *ctx, SWspan *span)
 
    ASSERT(span->end <= MAX_WIDTH);
 
+   /* Depth bounds test */
+   if (ctx->Depth.BoundsTest && fb->Visual.depthBits > 0) {
+      if (!_swrast_depth_bounds_test(ctx, span)) {
+         return;
+      }
+   }
+
 #ifdef DEBUG
    /* Make sure all fragments are within window bounds */
    if (span->arrayMask & SPAN_XY) {
@@ -1766,9 +1773,7 @@ _swrast_get_row(GLcontext *ctx, struct gl_renderbuffer *rb,
 
 
 /**
- * Get RGBA pixels from the given renderbuffer.  Put the pixel colors into
- * the span's specular color arrays.  The specular color arrays should no
- * longer be needed by time this function is called.
+ * Get RGBA pixels from the given renderbuffer.
  * Used by blending, logicop and masking functions.
  * \return pointer to the colors we read.
  */
@@ -1779,10 +1784,8 @@ _swrast_get_dest_rgba(GLcontext *ctx, struct gl_renderbuffer *rb,
    const GLuint pixelSize = RGBA_PIXEL_SIZE(span->array->ChanType);
    void *rbPixels;
 
-   /*
-    * Point rbPixels to a temporary space (use specular color arrays).
-    */
-   rbPixels = span->array->attribs[FRAG_ATTRIB_COL1];
+   /* Point rbPixels to a temporary space */
+   rbPixels = span->array->attribs[FRAG_ATTRIB_MAX - 1];
 
    /* Get destination values from renderbuffer */
    if (span->arrayMask & SPAN_XY) {
diff --git a/src/mesa/swrast/s_texcombine.c b/src/mesa/swrast/s_texcombine.c
index 889164b..594b71a 100644
--- a/src/mesa/swrast/s_texcombine.c
+++ b/src/mesa/swrast/s_texcombine.c
@@ -29,7 +29,6 @@
 #include "main/colormac.h"
 #include "main/image.h"
 #include "main/imports.h"
-#include "main/pixel.h"
 #include "shader/prog_instruction.h"
 
 #include "s_context.h"
diff --git a/src/mesa/tnl/t_context.c b/src/mesa/tnl/t_context.c
index db21b45..5a14e59 100644
--- a/src/mesa/tnl/t_context.c
+++ b/src/mesa/tnl/t_context.c
@@ -38,7 +38,6 @@
 #include "tnl.h"
 #include "t_context.h"
 #include "t_pipeline.h"
-#include "t_vp_build.h"
 
 #include "vbo/vbo.h"
 
diff --git a/src/mesa/tnl/t_draw.c b/src/mesa/tnl/t_draw.c
index 04fa106..9a888ce 100644
--- a/src/mesa/tnl/t_draw.c
+++ b/src/mesa/tnl/t_draw.c
@@ -28,15 +28,11 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/imports.h"
-#include "main/state.h"
 #include "main/mtypes.h"
 #include "main/macros.h"
 #include "main/enums.h"
 
 #include "t_context.h"
-#include "t_pipeline.h"
-#include "t_vp_build.h"
-#include "t_vertex.h"
 #include "tnl.h"
 
 
diff --git a/src/mesa/tnl/t_pipeline.c b/src/mesa/tnl/t_pipeline.c
index 357ef1e..2cc677e 100644
--- a/src/mesa/tnl/t_pipeline.c
+++ b/src/mesa/tnl/t_pipeline.c
@@ -28,7 +28,6 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/imports.h"
-#include "main/state.h"
 #include "main/mtypes.h"
 
 #include "t_context.h"
diff --git a/src/mesa/tnl/t_rasterpos.c b/src/mesa/tnl/t_rasterpos.c
index 99b6787..13b84a7 100644
--- a/src/mesa/tnl/t_rasterpos.c
+++ b/src/mesa/tnl/t_rasterpos.c
@@ -29,7 +29,6 @@
 #include "main/feedback.h"
 #include "main/light.h"
 #include "main/macros.h"
-#include "main/rastpos.h"
 #include "main/simple_list.h"
 #include "main/mtypes.h"
 
diff --git a/src/mesa/tnl/t_vb_program.c b/src/mesa/tnl/t_vb_program.c
index e69f7d5..f3de6b6 100644
--- a/src/mesa/tnl/t_vb_program.c
+++ b/src/mesa/tnl/t_vb_program.c
@@ -40,7 +40,6 @@
 #include "shader/prog_statevars.h"
 #include "shader/prog_execute.h"
 #include "swrast/s_context.h"
-#include "swrast/s_texfilter.h"
 
 #include "tnl/tnl.h"
 #include "tnl/t_context.h"
@@ -390,6 +389,13 @@ run_vp( GLcontext *ctx, struct tnl_pipeline_stage *stage )
 #endif
          COPY_4V(store->results[attr].data[i], machine.Outputs[attr]);
       }
+
+      /* FOGC is a special case.  Fragment shader expects (f,0,0,1) */
+      if (program->Base.OutputsWritten & BITFIELD64_BIT(VERT_RESULT_FOGC)) {
+         store->results[VERT_RESULT_FOGC].data[i][1] = 0.0;
+         store->results[VERT_RESULT_FOGC].data[i][2] = 0.0;
+         store->results[VERT_RESULT_FOGC].data[i][3] = 1.0;
+      }
 #ifdef NAN_CHECK
       ASSERT(machine.Outputs[0][3] != 0.0F);
 #endif
diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index e168a89..a057bef 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -28,9 +28,6 @@
 
 #include "main/api_arrayelt.h"
 #include "main/glheader.h"
-#include "main/imports.h"
-#include "main/context.h"
-#include "main/macros.h"
 #include "main/mtypes.h"
 #include "main/vtxfmt.h"
 
diff --git a/src/mesa/vbo/vbo_exec_array.c b/src/mesa/vbo/vbo_exec_array.c
index 6de8f05..bd2fccd 100644
--- a/src/mesa/vbo/vbo_exec_array.c
+++ b/src/mesa/vbo/vbo_exec_array.c
@@ -35,7 +35,6 @@
 #include "main/bufferobj.h"
 #include "main/enums.h"
 #include "main/macros.h"
-#include "glapi/dispatch.h"
 
 #include "vbo_context.h"
 
@@ -689,6 +688,16 @@ vbo_exec_DrawRangeElementsBaseVertex(GLenum mode,
     * or we can read/write out of memory in several different places!
     */
 
+   /* Catch/fix some potential user errors */
+   if (type == GL_UNSIGNED_BYTE) {
+      start = MIN2(start, 0xff);
+      end = MIN2(end, 0xff);
+   }
+   else if (type == GL_UNSIGNED_SHORT) {
+      start = MIN2(start, 0xffff);
+      end = MIN2(end, 0xffff);
+   }
+
    if (end >= ctx->Array.ArrayObj->_MaxElement) {
       /* the max element is out of bounds of one or more enabled arrays */
       warnCount++;
@@ -739,6 +748,10 @@ vbo_exec_DrawRangeElementsBaseVertex(GLenum mode,
           */
       }
 #endif
+
+      /* Set 'end' to the max possible legal value */
+      assert(ctx->Array.ArrayObj->_MaxElement >= 1);
+      end = ctx->Array.ArrayObj->_MaxElement - 1;
    }
    else if (0) {
       _mesa_printf("glDraw[Range]Elements{,BaseVertex}"
diff --git a/src/mesa/vbo/vbo_exec_draw.c b/src/mesa/vbo/vbo_exec_draw.c
index 4f43856..d7dbbce 100644
--- a/src/mesa/vbo/vbo_exec_draw.c
+++ b/src/mesa/vbo/vbo_exec_draw.c
@@ -30,7 +30,6 @@
 #include "main/context.h"
 #include "main/enums.h"
 #include "main/state.h"
-#include "main/macros.h"
 
 #include "vbo_context.h"
 
diff --git a/src/mesa/vbo/vbo_save.c b/src/mesa/vbo/vbo_save.c
index 9757c3d..10f705c 100644
--- a/src/mesa/vbo/vbo_save.c
+++ b/src/mesa/vbo/vbo_save.c
@@ -28,8 +28,6 @@
 
 #include "main/mtypes.h"
 #include "main/bufferobj.h"
-#include "main/dlist.h"
-#include "main/vtxfmt.h"
 #include "main/imports.h"
 
 #include "vbo_context.h"
diff --git a/src/mesa/vbo/vbo_save_loopback.c b/src/mesa/vbo/vbo_save_loopback.c
index b7a74e4..f13a16e 100644
--- a/src/mesa/vbo/vbo_save_loopback.c
+++ b/src/mesa/vbo/vbo_save_loopback.c
@@ -29,7 +29,6 @@
 #include "main/glheader.h"
 #include "main/enums.h"
 #include "main/imports.h"
-#include "main/macros.h"
 #include "main/mtypes.h"
 #include "glapi/dispatch.h"
 #include "glapi/glapi.h"
diff --git a/src/mesa/vbo/vbo_split_copy.c b/src/mesa/vbo/vbo_split_copy.c
index c45190b..2ca1112 100644
--- a/src/mesa/vbo/vbo_split_copy.c
+++ b/src/mesa/vbo/vbo_split_copy.c
@@ -34,7 +34,6 @@
 #include "main/imports.h"
 #include "main/image.h"
 #include "main/macros.h"
-#include "main/enums.h"
 #include "main/mtypes.h"
 
 #include "vbo_split.h"
@@ -221,8 +220,6 @@ begin( struct copy_context *copy, GLenum mode, GLboolean begin_flag )
 {
    struct _mesa_prim *prim = &copy->dstprim[copy->dstprim_nr];
 
-/*    _mesa_printf("begin %s (%d)\n", _mesa_lookup_prim_by_nr(mode), begin_flag); */
-		
    prim->mode = mode;
    prim->begin = begin_flag;
 }
diff --git a/src/mesa/x86/assyntax.h b/src/mesa/x86/assyntax.h
index 524944f..de1f6a4 100644
--- a/src/mesa/x86/assyntax.h
+++ b/src/mesa/x86/assyntax.h
@@ -1735,9 +1735,9 @@ SECTION _DATA public align=16 class=DATA use32 flat
  * If we build with gcc's -fvisibility=hidden flag, we'll need to change
  * the symbol visibility mode to 'default'.
  */
-#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__)
+#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__)
 #  define HIDDEN(x) .hidden x
-#elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 303 && !defined(__DJGPP__) && !defined(__MINGW32__)
+#elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 303 && !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__)
 #  pragma GCC visibility push(default)
 #  define HIDDEN(x) .hidden x
 #else
diff --git a/src/mesa/x86/gen_matypes.c b/src/mesa/x86/gen_matypes.c
index d56b701..771d9df 100644
--- a/src/mesa/x86/gen_matypes.c
+++ b/src/mesa/x86/gen_matypes.c
@@ -61,21 +61,11 @@ do {									\
    printf( "\n" );							\
 } while (0)
 
-#if defined(__BEOS__) || defined(__HAIKU__) || defined(_LP64)
 #define OFFSET( s, t, m )						\
-   printf( "#define %s\t%ld\n", s, offsetof( t, m ) );
-#else
-#define OFFSET( s, t, m )						\
-   printf( "#define %s\t%d\n", s, offsetof( t, m ) );
-#endif
+   printf( "#define %s\t%lu\n", s, (unsigned long) offsetof( t, m ) );
 
-#if defined(__BEOS__) || defined(__HAIKU__) || defined(_LP64)
-#define SIZEOF( s, t )							\
-   printf( "#define %s\t%ld\n", s, sizeof(t) );
-#else
 #define SIZEOF( s, t )							\
-   printf( "#define %s\t%d\n", s, sizeof(t) );
-#endif
+   printf( "#define %s\t%lu\n", s, (unsigned long) sizeof(t) );
 
 #define DEFINE( s, d )							\
    printf( "#define %s\t0x%x\n", s, d );
diff --git a/src/mesa/x86/glapi_x86.S b/src/mesa/x86/glapi_x86.S
index 0da924c..849fbce 100644
--- a/src/mesa/x86/glapi_x86.S
+++ b/src/mesa/x86/glapi_x86.S
@@ -46,7 +46,7 @@
 
 #define GL_OFFSET(x) CODEPTR(REGOFF(4 * x, EAX))
 
-#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__)
+#if defined(GNU_ASSEMBLER) && !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__)
 #define GLOBL_FN(x) GLOBL x ; .type x, function
 #else
 #define GLOBL_FN(x) GLOBL x
diff --git a/src/mesa/x86/read_rgba_span_x86.S b/src/mesa/x86/read_rgba_span_x86.S
index 92b1c2d..3886a51 100644
--- a/src/mesa/x86/read_rgba_span_x86.S
+++ b/src/mesa/x86/read_rgba_span_x86.S
@@ -31,7 +31,7 @@
  */
 
 	.file	"read_rgba_span_x86.S"
-#if !defined(__DJGPP__) && !defined(__MINGW32__) /* this one cries for assyntax.h */
+#if !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__) /* this one cries for assyntax.h */
 /* Kevin F. Quinn 2nd July 2006
  * Replaced data segment constants with text-segment instructions.
  */
@@ -671,7 +671,7 @@ _generic_read_RGBA_span_RGB565_MMX:
 	emms
 #endif
 	ret
-#endif /* !defined(__DJGPP__) && !defined(__MINGW32__) */
+#endif /* !defined(__DJGPP__) && !defined(__MINGW32__) && !defined(__APPLE__) */
 	
 #if defined (__ELF__) && defined (__linux__)
 	.section .note.GNU-stack,"",%progbits
diff --git a/src/mesa/x86/x86_xform.c b/src/mesa/x86/x86_xform.c
index 52f6b25..c834e2b 100644
--- a/src/mesa/x86/x86_xform.c
+++ b/src/mesa/x86/x86_xform.c
@@ -30,7 +30,6 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "math/m_xform.h"
-#include "tnl/t_context.h"
 
 #include "x86_xform.h"
 #include "common_x86_asm.h"
