diff --git a/src/gallium/drivers/iris/iris_resource.c b/src/gallium/drivers/iris/iris_resource.c
index 8747ef4aa8a..3b34e32cd21 100644
--- a/src/gallium/drivers/iris/iris_resource.c
+++ b/src/gallium/drivers/iris/iris_resource.c
@@ -1125,6 +1125,20 @@ iris_flush_resource(struct pipe_context *ctx, struct pipe_resource *resource)
                                 0, INTEL_REMAINING_LAYERS,
                                 mod ? mod->aux_usage : ISL_AUX_USAGE_NONE,
                                 mod ? mod->supports_clear_color : false);
+
+   if (!res->mod_info && res->aux.usage != ISL_AUX_USAGE_NONE) {
+      /* flush_resource may be used to prepare an image for sharing external
+       * to the driver (e.g. via eglCreateImage). To account for this, make
+       * sure to get rid of any compression that a consumer wouldn't know how
+       * to handle.
+       */
+      for (int i = 0; i < IRIS_BATCH_COUNT; i++) {
+         if (iris_batch_references(&ice->batches[i], res->bo))
+            iris_batch_flush(&ice->batches[i]);
+      }
+
+      iris_resource_disable_aux(res);
+   }
 }
 
 static void
diff --git a/src/gallium/frontends/dri/dri_helpers.c b/src/gallium/frontends/dri/dri_helpers.c
index 01a1fb3d96c..5e87df35a55 100644
--- a/src/gallium/frontends/dri/dri_helpers.c
+++ b/src/gallium/frontends/dri/dri_helpers.c
@@ -258,7 +258,9 @@ dri2_create_image_from_renderbuffer2(__DRIcontext *context,
 				     int renderbuffer, void *loaderPrivate,
                                      unsigned *error)
 {
-   struct gl_context *ctx = ((struct st_context *)dri_context(context)->st)->ctx;
+   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;
+   struct gl_context *ctx = st_ctx->ctx;
+   struct pipe_context *p_ctx = st_ctx->pipe;
    struct gl_renderbuffer *rb;
    struct pipe_resource *tex;
    __DRIimage *img;
@@ -299,6 +301,13 @@ dri2_create_image_from_renderbuffer2(__DRIcontext *context,
 
    pipe_resource_reference(&img->texture, tex);
 
+   /* If the resource supports EGL_MESA_image_dma_buf_export, make sure that
+    * it's in a shareable state. Do this now while we still have the access to
+    * the context.
+    */
+   if (dri2_get_mapping_by_format(img->dri_format))
+      p_ctx->flush_resource(p_ctx, tex);
+
    *error = __DRI_IMAGE_ERROR_SUCCESS;
    return img;
 }
@@ -326,7 +335,9 @@ dri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,
                          void *loaderPrivate)
 {
    __DRIimage *img;
-   struct gl_context *ctx = ((struct st_context *)dri_context(context)->st)->ctx;
+   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;
+   struct gl_context *ctx = st_ctx->ctx;
+   struct pipe_context *p_ctx = st_ctx->pipe;
    struct gl_texture_object *obj;
    struct pipe_resource *tex;
    GLuint face = 0;
@@ -376,6 +387,13 @@ dri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,
 
    pipe_resource_reference(&img->texture, tex);
 
+   /* If the resource supports EGL_MESA_image_dma_buf_export, make sure that
+    * it's in a shareable state. Do this now while we still have the access to
+    * the context.
+    */
+   if (dri2_get_mapping_by_format(img->dri_format))
+      p_ctx->flush_resource(p_ctx, tex);
+
    *error = __DRI_IMAGE_ERROR_SUCCESS;
    return img;
 }
@@ -547,6 +565,9 @@ dri2_get_mapping_by_fourcc(int fourcc)
 const struct dri2_format_mapping *
 dri2_get_mapping_by_format(int format)
 {
+   if (format == __DRI_IMAGE_FORMAT_NONE)
+      return NULL;
+
    for (unsigned i = 0; i < ARRAY_SIZE(dri2_format_table); i++) {
       if (dri2_format_table[i].dri_format == format)
          return &dri2_format_table[i];
